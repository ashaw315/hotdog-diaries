name: Post-Deploy Check
on:
  deployment_status:
  push:
    branches:
      - main
  workflow_run:
    workflows:
      - Vercel Production Deployment
    types:
      - completed
  workflow_dispatch:
    inputs:
      skip_refill_check:
        description: Skip refill dry-run check
        type: boolean
        default: false
      target_url:
        description: Target URL to check (defaults to production)
        type: string
        default: https://hotdog-diaries.vercel.app
  workflow_call:
    inputs:
      skip_refill_check:
        description: Skip refill dry-run check
        type: boolean
        default: false
      target_url:
        description: Target URL to check
        type: string
        default: https://hotdog-diaries.vercel.app
permissions:
  contents: read
  actions: read
  checks: write
concurrency:
  group: post-deploy-${{ github.ref }}
  cancel-in-progress: false
env:
  PROD_URL: ${{ inputs.target_url || 'https://hotdog-diaries.vercel.app' }}
jobs:
  context:
    runs-on: ubuntu-latest
    name: Deployment Context Analysis
    outputs:
      state: ${{ steps.ctx.outputs.state }}
      url: ${{ steps.ctx.outputs.url }}
      commit: ${{ steps.ctx.outputs.commit }}
      reason: ${{ steps.ctx.outputs.reason }}
      proceed: ${{ steps.ctx.outputs.proceed }}
      environment: ${{ steps.ctx.outputs.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Setup pnpm
        run: |
          corepack enable
          corepack prepare pnpm@9 --activate
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Analyze deployment context
        id: ctx
        run: |
          echo "üîç Analyzing deployment context for post-deploy checks..."
          
          # For push events, wait longer for deployment to materialize
          MAX_WAIT=5
          if [ "${{ github.event_name }}" = "push" ]; then
            MAX_WAIT=8
            echo "üìå Push event: will wait up to ${MAX_WAIT} minutes for Vercel deployment"
          fi
          
          # Run deployment context analysis
          if ! pnpm tsx scripts/ci/lib/deploy-context.ts analyze --max-wait=$MAX_WAIT; then
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 78 ]; then
              echo "‚è∏Ô∏è Deployment not ready - will conclude neutrally"
              echo "proceed=false" >> $GITHUB_OUTPUT
              echo "neutralized=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ùå Hard error analyzing deployment context"
              exit 1
            fi
          fi
          
          echo "‚úÖ Deployment ready for post-deploy validation"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_TEAM_ID: ${{ secrets.VERCEL_TEAM_ID }}
          
      - name: Neutralize on deployment failure
        if: steps.ctx.outputs.proceed != 'true'
        run: |
          echo "‚è∏Ô∏è Neutralizing post-deploy check due to upstream deployment issue"
          echo "State: ${{ steps.ctx.outputs.state }}"
          echo "Reason: ${{ steps.ctx.outputs.reason }}"
          
          # Write neutral summary
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ‚è∏Ô∏è Post-Deploy Check Neutralized
          
          The post-deploy check has been neutralized because the upstream deployment is not ready for validation.
          
          | Field | Value |
          |-------|-------|
          | **Deployment State** | `${{ steps.ctx.outputs.state }}` |
          | **Reason** | ${{ steps.ctx.outputs.reason }} |
          | **URL Available** | ${{ steps.ctx.outputs.url && 'Yes' || 'No' }} |
          | **Commit** | `${{ steps.ctx.outputs.commit }}` |
          
          ### üîÑ Next Steps
          
          This is normal and expected for:
          - Failed deployments (fix deployment issues first)
          - Deployments still in progress (wait for completion)
          - Missing preview URLs (check Vercel configuration)
          
          **No action required** - checks will automatically re-run when the deployment succeeds.
          EOF
          
          exit 0

  guard:
    uses: ./.github/workflows/_posting-guard.yml
    needs: context
    if: |
      needs.context.outputs.proceed == 'true' && (
        github.event_name != 'deployment_status' ||
        (github.event_name == 'deployment_status' && github.event.deployment_status.state == 'success')
      )
  
  health-check:
    runs-on: ubuntu-latest
    name: Health & Metrics Validation
    needs: [context, guard]
    if: |
      needs.context.outputs.proceed == 'true' && (
        github.event_name != 'deployment_status' ||
        (github.event_name == 'deployment_status' && github.event.deployment_status.state == 'success')
      )
    timeout-minutes: 10
    outputs:
      health-status: ${{ steps.health.outputs.status }}
      metrics-snapshot: ${{ steps.metrics.outputs.snapshot }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      - name: Setup pnpm
        run: |
          corepack enable
          corepack prepare pnpm@9 --activate
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      - name: Set deployment URL
        run: |
          echo "üåê Using deployment URL from context analysis..."
          DEPLOY_URL="${{ needs.context.outputs.url }}"
          if [ -n "$DEPLOY_URL" ]; then
            echo "‚úÖ Using resolved deployment URL: $DEPLOY_URL"
            echo "TARGET_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "üìå No deployment URL, using fallback from inputs/env"
            echo "TARGET_URL=${{ env.PROD_URL }}" >> $GITHUB_ENV
          fi
      - name: Mint runtime JWT token
        run: |
          echo "üîê Minting runtime JWT token for post-deploy checks..."
          
          # Try runtime token first, fall back to legacy AUTH_TOKEN if minting fails
          if TOKEN=$(pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 20m --sub post-deploy --aud ci --iss hotdog-diaries 2>/dev/null); then
            echo "‚úÖ Successfully minted runtime JWT token"
            echo "TOKEN=$TOKEN" >> $GITHUB_ENV
            echo "TOKEN_TYPE=runtime" >> $GITHUB_ENV
          elif [ -n "${{ secrets.AUTH_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Runtime token minting failed, falling back to legacy AUTH_TOKEN"
            echo "TOKEN=${{ secrets.AUTH_TOKEN }}" >> $GITHUB_ENV
            echo "TOKEN_TYPE=legacy" >> $GITHUB_ENV
          else
            echo "‚ùå No token available for post-deploy checks"
            exit 1
          fi
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
      - name: Test auth self-test endpoint
        run: |
          echo "üîç Testing auth self-test endpoint..."
          echo "Token type: $TOKEN_TYPE"
          
          SELFTEST_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            --max-time 15 \
            "$TARGET_URL/api/health/auth-selftest")
          
          SELFTEST_STATUS=$(echo $SELFTEST_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          SELFTEST_BODY=$(echo $SELFTEST_RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "Auth Self-Test Status: $SELFTEST_STATUS"
          
          if [ "$SELFTEST_STATUS" -eq 200 ]; then
            echo "‚úÖ Auth self-test passed"
            
            # Parse auth details
            if echo "$SELFTEST_BODY" | jq -e '.ok == true' > /dev/null; then
              ISS=$(echo "$SELFTEST_BODY" | jq -r '.iss // "unknown"')
              AUD=$(echo "$SELFTEST_BODY" | jq -r '.aud // "unknown"')
              SUB=$(echo "$SELFTEST_BODY" | jq -r '.sub // "unknown"')
              KEY_VERSION=$(echo "$SELFTEST_BODY" | jq -r '.keyVersion // "null"')
              EXP=$(echo "$SELFTEST_BODY" | jq -r '.exp // "unknown"')
              
              echo "üìä Auth Details:"
              echo "  - Token Type: $TOKEN_TYPE"
              echo "  - Issuer: $ISS"
              echo "  - Audience: $AUD"
              echo "  - Subject: $SUB"
              echo "  - Key Version: $KEY_VERSION"
              echo "  - Expires: $EXP"
            fi
          else
            echo "‚ùå Auth self-test failed with status $SELFTEST_STATUS"
            
            if [ "$SELFTEST_STATUS" -eq 401 ]; then
              CODE=$(echo "$SELFTEST_BODY" | jq -r '.code // "unknown"')
              echo "üö® Auth error: $CODE"
              if [ "$CODE" = "INVALID_SIGNATURE" ]; then
                echo "JWT_SECRET mismatch detected - deployment may need rollback"
              fi
            fi
            
            exit 1
          fi
      - name: Test deep health endpoint
        id: health
        run: |
          echo "üè• Testing /admin/health/deep endpoint..."

          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            --max-time 30 \
            "$TARGET_URL/api/admin/health/deep")

          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')

          echo "HTTP Status: $HTTP_STATUS"
          echo "Response Body: $BODY"

          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Deep health check passed"
            
            # Verify 'ok' status in response
            OK_STATUS=$(echo "$BODY" | jq -r '.ok // false')
            if [ "$OK_STATUS" = "true" ]; then
              echo "‚úÖ Health status is OK"
              echo "status=healthy" >> $GITHUB_OUTPUT
              
              # Extract component details for artifact
              echo "$BODY" | jq '.components // {}' > health_components.json
              
            else
              echo "‚ùå Health status indicates issues"
              echo "status=degraded" >> $GITHUB_OUTPUT
              echo "$BODY" | jq '.components // {}' > health_components.json
              
              # Don't fail immediately - continue to refill check
              echo "‚ö†Ô∏è Health check shows degraded status but continuing..."
            fi
          else
            echo "‚ùå Deep health check failed with status $HTTP_STATUS"
            echo "status=failed" >> $GITHUB_OUTPUT
            echo '{"error": "health_check_failed", "status": '$HTTP_STATUS'}' > health_components.json
            exit 1
          fi
      - name: Get system metrics snapshot
        id: metrics
        run: >
          echo "üìä Collecting system metrics snapshot..."


          METRICS_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            --max-time 15 \
            "$TARGET_URL/api/system/metrics")

          METRICS_HTTP_STATUS=$(echo $METRICS_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')

          METRICS_BODY=$(echo $METRICS_RESPONSE | sed -e 's/HTTPSTATUS:.*//g')


          echo "Metrics HTTP Status: $METRICS_HTTP_STATUS"


          if [ "$METRICS_HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ System metrics collected"
            echo "$METRICS_BODY" > metrics_snapshot.json
            echo "snapshot=available" >> $GITHUB_OUTPUT
            
            # Extract key metrics for logs
            QUEUE_DEPTH=$(echo "$METRICS_BODY" | jq '[.queue_depth_by_platform | to_entries[]] | map(.value) | add // 0')
            POSTS_TODAY=$(echo "$METRICS_BODY" | jq '.posts_today // 0')
            HEALTH_STATUS=$(echo "$METRICS_BODY" | jq -r '.health_status // "unknown"')
            
            echo "üìà Key Metrics:"
            echo "  Total queue depth: $QUEUE_DEPTH"
            echo "  Posts today: $POSTS_TODAY"
            echo "  Health status: $HEALTH_STATUS"

            
          else
            echo "‚ö†Ô∏è Could not collect metrics (status $METRICS_HTTP_STATUS)"
            echo '{"error": "metrics_unavailable", "timestamp": "'$(date -Iseconds)'"}' > metrics_snapshot.json
            echo "snapshot=failed" >> $GITHUB_OUTPUT
          fi
    needs: guard
    concurrency:
      group: health-check-${{ github.ref }}
      cancel-in-progress: true
  refill-check:
    runs-on: ubuntu-latest
    name: Two-Day Refill Validation
    needs: [context, health-check]
    if: |
      needs.context.outputs.proceed == 'true' && 
      needs.health-check.outputs.health-status != 'failed' && 
      inputs.skip_refill_check != true && (
        github.event_name != 'deployment_status' ||
        (github.event_name == 'deployment_status' && github.event.deployment_status.state == 'success')
      )
    timeout-minutes: 8
    outputs:
      refill-status: ${{ steps.refill.outputs.status }}
      diversity-score: ${{ steps.refill.outputs.diversity_score }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      - name: Setup pnpm
        run: |
          corepack enable
          corepack prepare pnpm@9 --activate
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      - name: Set deployment URL
        run: |
          echo "üåê Using deployment URL from context analysis..."
          DEPLOY_URL="${{ needs.context.outputs.url }}"
          if [ -n "$DEPLOY_URL" ]; then
            echo "‚úÖ Using resolved deployment URL: $DEPLOY_URL"
            echo "TARGET_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "üìå No deployment URL, using fallback from inputs/env"
            echo "TARGET_URL=${{ env.PROD_URL }}" >> $GITHUB_ENV
          fi
      - name: Mint runtime JWT token for refill check
        run: |
          echo "üîê Minting runtime JWT token for refill validation..."
          
          if TOKEN=$(pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 15m --sub refill-check --aud ci --iss hotdog-diaries 2>/dev/null); then
            echo "‚úÖ Successfully minted runtime JWT token"
            echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          elif [ -n "${{ secrets.AUTH_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Runtime token minting failed, falling back to legacy AUTH_TOKEN"
            echo "TOKEN=${{ secrets.AUTH_TOKEN }}" >> $GITHUB_ENV
          else
            echo "‚ùå No token available for refill check"
            exit 1
          fi
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
      - name: Test two-day forecast endpoint
        id: refill
        run: |
          echo "üîÆ Testing two-day forecast capability..."

          # Get today and tomorrow dates
          TODAY=$(date -Iseconds | cut -d'T' -f1)
          TOMORROW=$(date -d "+1 day" -Iseconds | cut -d'T' -f1)

          echo "Testing forecast for: $TODAY and $TOMORROW"

          # Test today's forecast
          TODAY_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            --max-time 30 \
            "$TARGET_URL/api/admin/schedule/forecast?date=$TODAY")

          TODAY_HTTP_STATUS=$(echo $TODAY_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          TODAY_BODY=$(echo $TODAY_RESPONSE | sed -e 's/HTTPSTATUS:.*//g')

          # Test tomorrow's forecast
          TOMORROW_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            --max-time 30 \
            "$TARGET_URL/api/admin/schedule/forecast?date=$TOMORROW")

          TOMORROW_HTTP_STATUS=$(echo $TOMORROW_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          TOMORROW_BODY=$(echo $TOMORROW_RESPONSE | sed -e 's/HTTPSTATUS:.*//g')

          echo "Today forecast status: $TODAY_HTTP_STATUS"
          echo "Tomorrow forecast status: $TOMORROW_HTTP_STATUS"

          # Validate both days have 6 slots
          if [ "$TODAY_HTTP_STATUS" -eq 200 ] && [ "$TOMORROW_HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Forecast endpoints responding"
            
            # Count slots for today
            TODAY_SLOTS=$(echo "$TODAY_BODY" | jq '.slots | length // 0')
            TODAY_FILLED=$(echo "$TODAY_BODY" | jq '[.slots[] | select(.content_id != null)] | length // 0')
            
            # Count slots for tomorrow  
            TOMORROW_SLOTS=$(echo "$TOMORROW_BODY" | jq '.slots | length // 0')
            TOMORROW_FILLED=$(echo "$TOMORROW_BODY" | jq '[.slots[] | select(.content_id != null)] | length // 0')
            
            echo "üìÖ Today: $TODAY_FILLED/$TODAY_SLOTS slots filled"
            echo "üìÖ Tomorrow: $TOMORROW_FILLED/$TOMORROW_SLOTS slots filled"
            
            # Check if we have 6/6 for both days
            if [ "$TODAY_SLOTS" -eq 6 ] && [ "$TOMORROW_SLOTS" -eq 6 ]; then
              echo "‚úÖ Both days have 6 time slots configured"
              
              # Check fill status - warn if not fully filled but don't fail
              TOTAL_FILLED=$((TODAY_FILLED + TOMORROW_FILLED))
              if [ "$TOTAL_FILLED" -ge 10 ]; then
                echo "‚úÖ Good fill rate: $TOTAL_FILLED/12 slots filled"
                echo "status=good" >> $GITHUB_OUTPUT
              else
                echo "‚ö†Ô∏è Low fill rate: $TOTAL_FILLED/12 slots filled"
                echo "status=warning" >> $GITHUB_OUTPUT
              fi
              
              # Extract diversity information for analysis
              TODAY_DIVERSITY=$(echo "$TODAY_BODY" | jq '.summary.diversity_score // 0')
              TOMORROW_DIVERSITY=$(echo "$TOMORROW_BODY" | jq '.summary.diversity_score // 0')
              AVG_DIVERSITY=$(echo "($TODAY_DIVERSITY + $TOMORROW_DIVERSITY) / 2" | bc -l)
              
              echo "üéØ Diversity scores: Today=$TODAY_DIVERSITY, Tomorrow=$TOMORROW_DIVERSITY, Avg=$AVG_DIVERSITY"
              echo "diversity_score=$AVG_DIVERSITY" >> $GITHUB_OUTPUT
              
              # Save forecast data for artifact
              echo "$TODAY_BODY" > today_forecast.json
              echo "$TOMORROW_BODY" > tomorrow_forecast.json
              
            else
              echo "‚ùå Incorrect slot configuration (expected 6/6)"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
            
          else
            echo "‚ùå Forecast endpoints failed"
            echo "Today status: $TODAY_HTTP_STATUS"
            echo "Tomorrow status: $TOMORROW_HTTP_STATUS"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: Diversity policy evaluation (warn-only)
        run: |
          echo "üåà Evaluating diversity policy..."

          DIVERSITY_SCORE="${{ steps.refill.outputs.diversity_score }}"

          if [ -n "$DIVERSITY_SCORE" ]; then
            # Convert to integer percentage for comparison
            DIVERSITY_PCT=$(echo "$DIVERSITY_SCORE * 100" | bc -l | cut -d'.' -f1)
            
            echo "Diversity score: $DIVERSITY_SCORE ($DIVERSITY_PCT%)"
            
            if [ "$DIVERSITY_PCT" -ge 80 ]; then
              echo "‚úÖ Excellent diversity ($DIVERSITY_PCT% >= 80%)"
            elif [ "$DIVERSITY_PCT" -ge 60 ]; then
              echo "üü° Good diversity ($DIVERSITY_PCT% >= 60%)"
            elif [ "$DIVERSITY_PCT" -ge 40 ]; then
              echo "üü† Moderate diversity ($DIVERSITY_PCT% >= 40%)"
            else
              echo "üî¥ Low diversity ($DIVERSITY_PCT% < 40%)"
              echo "‚ö†Ô∏è Consider running content scans to improve platform diversity"
            fi
            
            # This is warn-only, so don't fail the deployment
            echo "üìã Diversity policy result: INFORMATIONAL (warn-only)"
          else
            echo "‚ö†Ô∏è Could not calculate diversity score"
          fi
  upload-artifacts:
    runs-on: ubuntu-latest
    name: Upload Metrics & Artifacts
    needs:
      - context
      - health-check
      - refill-check
    if: |\
      always() && needs.context.outputs.proceed == 'true' && (
        github.event_name != 'deployment_status' ||
        (github.event_name == 'deployment_status' && github.event.deployment_status.state == 'success')
      )
    steps:
      - name: Download artifacts from previous jobs
        run: >
          echo "üì¶ Collecting deployment artifacts..."

          mkdir -p deployment_artifacts


          # Create summary artifact

          cat > deployment_artifacts/deployment_summary.json << EOF

          {
            "timestamp": "$(date -Iseconds)",
            "deployment_sha": "${{ github.sha }}",
            "workflow_run": "${{ github.run_id }}",
            "health_status": "${{ needs.health-check.outputs.health-status }}",
            "refill_status": "${{ needs.refill-check.outputs.refill-status }}",
            "diversity_score": "${{ needs.refill-check.outputs.diversity_score }}",
            "environment": "production",
            "success": ${{ needs.health-check.outputs.health-status != 'failed' && needs.refill-check.outputs.refill-status != 'failed' }}
          }

          EOF
      - name: Set deployment URL
        run: |
          echo "üåê Using deployment URL from context analysis..."
          DEPLOY_URL="${{ needs.context.outputs.url }}"
          if [ -n "$DEPLOY_URL" ]; then
            echo "‚úÖ Using resolved deployment URL: $DEPLOY_URL"
            echo "TARGET_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "üìå No deployment URL, using fallback from inputs/env"
            echo "TARGET_URL=${{ env.PROD_URL }}" >> $GITHUB_ENV
          fi
      - name: Collect current metrics snapshot
        run: >
          echo "üìä Collecting final metrics snapshot..."


          FINAL_METRICS=$(curl -s --max-time 15 "$TARGET_URL/api/system/metrics" || echo '{"error": "collection_failed"}')

          echo "$FINAL_METRICS" > deployment_artifacts/final_metrics_snapshot.json


          # Extract summary for logs

          if echo "$FINAL_METRICS" | jq -e '.timestamp' > /dev/null 2>&1; then
            HEALTH_STATUS=$(echo "$FINAL_METRICS" | jq -r '.health_status // "unknown"')
            TOTAL_QUEUE=$(echo "$FINAL_METRICS" | jq '[.queue_depth_by_platform | to_entries[]] | map(.value) | add // 0')
            POSTS_TODAY=$(echo "$FINAL_METRICS" | jq '.posts_today // 0')
            
            echo "üìà Final Metrics Summary:"
            echo "  Health: $HEALTH_STATUS"
            echo "  Queue Depth: $TOTAL_QUEUE"
            echo "  Posts Today: $POSTS_TODAY"
          else
            echo "‚ö†Ô∏è Could not collect final metrics"
          fi
      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: post-deploy-check-${{ github.sha }}
          path: deployment_artifacts/
          retention-days: 30
      - name: Generate deployment report
        run: >
          echo "üìã Post-Deploy Check Report"

          echo "=========================="

          echo "Deployment: ${{ github.sha }}"

          echo "Timestamp: $(date -Iseconds)"

          echo "Workflow: ${{ github.run_id }}"

          echo ""

          echo "Results:"

          echo "  Health Check: ${{ needs.health-check.outputs.health-status }}"

          echo "  Refill Check: ${{ needs.refill-check.outputs.refill-status }}"

          echo "  Diversity Score: ${{ needs.refill-check.outputs.diversity_score }}"

          echo ""


          OVERALL_SUCCESS="${{ needs.health-check.outputs.health-status != 'failed' &&
          needs.refill-check.outputs.refill-status != 'failed' }}"


          if [ "$OVERALL_SUCCESS" = "true" ]; then
            echo "‚úÖ DEPLOYMENT VALIDATION PASSED"
            echo "All post-deploy checks completed successfully"
          else
            echo "‚ùå DEPLOYMENT VALIDATION FAILED"
            echo "One or more critical checks failed"
            exit 1
          fi
  notification:
    runs-on: ubuntu-latest
    name: Post-Deploy Notification
    needs:
      - context
      - health-check
      - refill-check
      - upload-artifacts
    if: |\
      always() && needs.context.outputs.proceed == 'true' && (
        github.event_name != 'deployment_status' ||
        (github.event_name == 'deployment_status' && github.event.deployment_status.state == 'success')
      )
    steps:
      - name: Set deployment URL
        run: |
          echo "üåê Using deployment URL from context analysis..."
          DEPLOY_URL="${{ needs.context.outputs.url }}"
          if [ -n "$DEPLOY_URL" ]; then
            echo "‚úÖ Using resolved deployment URL: $DEPLOY_URL"
            echo "TARGET_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "üìå No deployment URL, using fallback from inputs/env"
            echo "TARGET_URL=${{ env.PROD_URL }}" >> $GITHUB_ENV
          fi
      - name: ‚úÖ Success Summary
        if: needs.health-check.outputs.health-status != 'failed' && needs.refill-check.outputs.refill-status != 'failed'
        run: |+
          echo "üéâ POST-DEPLOY VALIDATION SUCCESS"
          echo "=================================="
          echo "‚úÖ Health Check: ${{ needs.health-check.outputs.health-status }}"
          echo "‚úÖ Refill Check: ${{ needs.refill-check.outputs.refill-status }}"
          echo "üìä Diversity Score: ${{ needs.refill-check.outputs.diversity_score }}"
          echo ""
          echo "üöÄ System Status: All validation checks passed"
          echo "üåê Production URL: $TARGET_URL"
          echo "üì¶ Artifacts: Metrics snapshot and deployment data uploaded"
          echo ""
          echo "## ‚úÖ Post-Deploy Validation Success" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: $(date -u -Iseconds)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Validation Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check**: ${{ needs.health-check.outputs.health-status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Refill Check**: ${{ needs.refill-check.outputs.refill-status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Diversity Score**: ${{ needs.refill-check.outputs.diversity_score }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üéâ All post-deployment validation checks passed successfully!" >> $GITHUB_STEP_SUMMARY
            
      - name: Create failure notification
        if: needs.health-check.outputs.health-status == 'failed' || needs.refill-check.outputs.refill-status == 'failed'
        uses: actions/github-script@v7
        with:
          script: >
            const title = `üö® Post-Deploy Check Failed - ${new Date().toISOString().split('T')[0]}`

            const body = `## Post-Deploy Validation Failure


            **Deployment**: \`${{ github.sha }}\`  

            **Timestamp**: ${new Date().toISOString()}  

            **Workflow**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{
            github.run_id }})


            ### ‚ùå Validation Results


            - **Health Check**: ${{ needs.health-check.outputs.health-status }}

            - **Refill Check**: ${{ needs.refill-check.outputs.refill-status }}


            ### üö® Immediate Actions Required


            1. **Check workflow logs** for specific failure details

            2. **Verify system health** manually via admin panel

            3. **Test critical endpoints** to isolate issues:
               - Health: ${process.env.TARGET_URL || '${{ env.PROD_URL }}'}/api/admin/health/deep
               - Metrics: ${process.env.TARGET_URL || '${{ env.PROD_URL }}'}/api/system/metrics
               - Forecast: ${process.env.TARGET_URL || '${{ env.PROD_URL }}'}/api/admin/schedule/forecast
            4. **Consider rollback** if critical functionality is impacted


            ### üîç Investigation


            Check the workflow artifacts for detailed metrics and diagnostic data.


            ### üìû Escalation


            If the issue persists or affects user-facing functionality, escalate immediately.


            /cc @devops-team @on-call


            ---

            *This alert was generated automatically by the post-deploy check workflow.*

            `


            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment', 'failure', 'urgent', 'automated', 'post-deploy']
            })

  neutralize:
    runs-on: ubuntu-latest
    name: Neutralize Post-Deploy Check
    needs: [context]
    if: needs.context.outputs.proceed != 'true'
    
    steps:
      - name: Checkout for neutralize action
        uses: actions/checkout@v4
        
      - name: Neutralize with summary
        uses: ./.github/actions/neutralize
        with:
          reason: "Upstream deployment not successful or preview URL unavailable"
          deploy_state: ${{ needs.context.outputs.state }}
          deploy_reason: ${{ needs.context.outputs.reason }}
          deploy_url: ${{ needs.context.outputs.url }}
