name: "Production Autonomy Watchdog"
on:
  schedule:
    - cron: "7 * * * *"      # hourly at :07 UTC
    - cron: "7 10 * * *"     # 06:07 ET
    - cron: "37 10 * * *"    # 06:37 ET
    - cron: "7 11 * * *"     # 07:07 ET
  workflow_dispatch:
    inputs:
      run_canary:
        description: "Run DRY_RUN posting canary"
        required: false
        type: boolean
        default: false
      date:
        description: "ISO date (ET) to analyze; default today"
        required: false
        type: string
jobs:
  watchdog:
    permissions:
      contents: read
      issues: write
      checks: write
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: prod-watchdog-${{ github.ref }}
      cancel-in-progress: true
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY_V2 != '' && secrets.SUPABASE_SERVICE_ROLE_KEY_V2 || secrets.SUPABASE_SERVICE_ROLE_KEY }}
      PROD_BASE_URL: ${{ vars.PROD_BASE_URL || 'https://hotdog-diaries.vercel.app' }}
      RUN_CANARY: ${{ inputs.run_canary || 'false' }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      - run: pnpm install --frozen-lockfile || pnpm install
      - name: Mint runtime JWT token for watchdog checks
        run: |
          echo "üîê Minting runtime JWT token for production watchdog..."
          
          # Try runtime token first, fall back to legacy AUTH_TOKEN if minting fails
          if TOKEN=$(pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 30m --sub prod-watchdog --aud watchdog --iss hotdog-diaries 2>/dev/null); then
            echo "‚úÖ Successfully minted runtime JWT token"
            echo "TOKEN=$TOKEN" >> $GITHUB_ENV
            echo "TOKEN_TYPE=runtime" >> $GITHUB_ENV
          elif [ -n "${{ secrets.AUTH_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Runtime token minting failed, falling back to legacy AUTH_TOKEN"
            echo "TOKEN=${{ secrets.AUTH_TOKEN }}" >> $GITHUB_ENV
            echo "TOKEN_TYPE=legacy" >> $GITHUB_ENV
          else
            echo "‚ùå No token available for watchdog checks"
            exit 1
          fi
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
      - name: Test auth self-test endpoint before watchdog checks
        run: |
          echo "üîç Testing auth self-test endpoint before running watchdog..."
          echo "Token type: $TOKEN_TYPE"
          
          SELFTEST_RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            --max-time 10 \
            "$PROD_BASE_URL/api/health/auth-selftest")
          
          SELFTEST_STATUS=$(echo $SELFTEST_RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          SELFTEST_BODY=$(echo $SELFTEST_RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "Auth Self-Test Status: $SELFTEST_STATUS"
          
          if [ "$SELFTEST_STATUS" -eq 200 ]; then
            echo "‚úÖ Auth self-test passed - token valid"
            
            # Parse auth details for logging
            if echo "$SELFTEST_BODY" | jq -e '.ok == true' > /dev/null; then
              ISS=$(echo "$SELFTEST_BODY" | jq -r '.iss // "unknown"')
              AUD=$(echo "$SELFTEST_BODY" | jq -r '.aud // "unknown"')
              SUB=$(echo "$SELFTEST_BODY" | jq -r '.sub // "unknown"')
              KEY_VERSION=$(echo "$SELFTEST_BODY" | jq -r '.keyVersion // "null"')
              
              echo "üìä Token Details:"
              echo "  - Type: $TOKEN_TYPE"
              echo "  - Issuer: $ISS"
              echo "  - Audience: $AUD"
              echo "  - Subject: $SUB"
              echo "  - Key Version: $KEY_VERSION"
            fi
          else
            echo "‚ùå Auth self-test failed with status $SELFTEST_STATUS"
            
            if [ "$SELFTEST_STATUS" -eq 401 ]; then
              CODE=$(echo "$SELFTEST_BODY" | jq -r '.code // "unknown"')
              echo "üö® Auth error: $CODE"
              if [ "$CODE" = "INVALID_SIGNATURE" ]; then
                echo "JWT_SECRET mismatch - production auth config issue"
              fi
            fi
            
            echo "‚ö†Ô∏è Watchdog will continue with degraded auth status"
          fi
      - name: Actions check
        run: pnpm tsx scripts/prod/check-actions-today.ts --date "${{ inputs.date }}"
        env:
          AUTH_TOKEN: ${{ env.TOKEN }}
      - name: DB check
        run: pnpm tsx scripts/prod/check-db-posting.ts --date "${{ inputs.date }}"
        env:
          AUTH_TOKEN: ${{ env.TOKEN }}
      - name: UI probe
        run: pnpm tsx scripts/prod/probe-ui.ts --date "${{ inputs.date }}"
        env:
          AUTH_TOKEN: ${{ env.TOKEN }}
      - name: Deep deployment health validation
        run: |
          echo "üè• Running comprehensive deployment health validation..."
          
          # Deep health check (moved from deploy-gate.yml)
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            "$PROD_BASE_URL/api/admin/health/deep")
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "Deep Health Status: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Deep health check passed"
            
            # Verify response structure
            OK_STATUS=$(echo "$BODY" | jq -r '.ok // false')
            if [ "$OK_STATUS" = "true" ]; then
              echo "‚úÖ Health status is OK"
              echo "üìä Component Health:"
              echo "$BODY" | jq '.components // {}' || echo "No component details available"
            else
              echo "‚ö†Ô∏è Health status indicates issues"
              echo "$BODY" | jq '.components // {}' || echo "No component details available"
            fi
          else
            echo "‚ùå Deep health check failed with status $HTTP_STATUS"
            echo "Response: $BODY"
          fi
      
      - name: Admin endpoint smoke test suite
        run: |
          echo "üí® Running comprehensive admin endpoint smoke test..."
          
          # Test critical admin endpoints (moved from deploy-gate.yml)
          ENDPOINTS=(
            "/api/admin/dashboard/stats"
            "/api/admin/queue/health"
            "/api/admin/platforms/status"
            "/api/admin/metrics"
            "/api/admin/content/scheduled"
            "/api/admin/content/recent"
          )
          
          FAILED_ENDPOINTS=()
          
          for ENDPOINT in "${ENDPOINTS[@]}"; do
            echo "Testing $ENDPOINT..."
            
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              -H "Authorization: Bearer $TOKEN" \
              "$PROD_BASE_URL$ENDPOINT")
            
            HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
            
            if [ "$HTTP_STATUS" -eq 200 ]; then
              echo "‚úÖ $ENDPOINT responding"
            else
              echo "‚ùå $ENDPOINT failed with status $HTTP_STATUS"
              FAILED_ENDPOINTS+=("$ENDPOINT")
            fi
          done
          
          if [ ${#FAILED_ENDPOINTS[@]} -eq 0 ]; then
            echo "‚úÖ All admin endpoints passed smoke test"
          else
            echo "‚ö†Ô∏è ${#FAILED_ENDPOINTS[@]} admin endpoints failed:"
            printf '  - %s\n' "${FAILED_ENDPOINTS[@]}"
          fi
      
      - name: Canary (optional)
        if: ${{ inputs.run_canary == true }}
        run: pnpm tsx scripts/prod/synthetic-post-canary.ts
        env:
          AUTH_TOKEN: ${{ env.TOKEN }}
      - name: Emit report
        id: report
        run: pnpm tsx scripts/prod/emit-watchdog-report.ts --date "${{ inputs.date }}"
        env:
          AUTH_TOKEN: ${{ env.TOKEN }}
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: PROD_WATCHDOG_REPORT
          path: ci_audit/watchdog/
          retention-days: 7
      - name: Create/Update issue on failure
        if: failure()
        run: |
          TITLE="‚ùå Production Watchdog Failure $(date -u +%F)"
          BODY="$(cat ci_audit/watchdog/PROD_WATCHDOG_REPORT.md)"
          # Try to find existing open issue
          NUM=$(gh issue list --search "Production Watchdog Failure" --state open --limit 1 --json number -q '.[0].number' || true)
          if [ -n "$NUM" ]; then
            gh issue comment "$NUM" --body "$BODY"
          else
            gh issue create --title "$TITLE" --body "$BODY" --label "production-watchdog"
          fi
      - name: Alert webhook (optional)
        if: failure()
        env:
          ALERT_WEBHOOK_URL: ${{ secrets.ALERT_WEBHOOK_URL }}
        run: |
          if [ -n "$ALERT_WEBHOOK_URL" ]; then
            printf '%s' "{\"text\":\"‚ùå Hotdog Diaries: Production watchdog detected failures. See artifact: PROD_WATCHDOG_REPORT.\"}" \
              | curl -s -X POST -H 'content-type: application/json' -d @- "$ALERT_WEBHOOK_URL" || true
          fi