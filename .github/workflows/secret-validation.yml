name: Secret Validation

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run weekly secret audit every Monday at 9 AM UTC
    - cron: '0 9 * * 1'

jobs:
  validate-secrets:
    runs-on: ubuntu-latest
    name: Validate Secret Strength & Environment Variables
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.18.3
          
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Test JWT runtime minting capability
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          echo "üîê Testing JWT runtime minting capability..."
          
          # Check if this is a PR context with no secrets access
          if [ "${{ github.event_name }}" = "pull_request" ] && [ -z "$JWT_SECRET" ]; then
            echo "‚ö†Ô∏è PR context detected with no JWT_SECRET access"
            echo "‚úÖ Skipping JWT tests for security (secrets not available to fork PRs)"
            echo "Note: JWT validation will run on merge to main branch"
            exit 0
          fi
          
          if [ -n "$JWT_SECRET" ]; then
            echo "‚úÖ JWT_SECRET is configured"
            
            # Test JWT minting with our utility
            if pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 5m --sub test --aud ci --iss hotdog-diaries > /dev/null 2>&1; then
              echo "‚úÖ JWT minting works correctly"
              
              # Test decode functionality with improved error handling
              TOKEN=$(pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 5m --sub test --aud ci --iss hotdog-diaries)
              if [ -n "$TOKEN" ]; then
                if pnpm -s tsx scripts/ci/lib/jwt.ts decode "$TOKEN" > /dev/null 2>&1; then
                  echo "‚úÖ JWT decode works correctly"
                else
                  echo "‚ùå JWT decode failed"
                  echo "üîç Debug: Testing decode with verbose output..."
                  pnpm tsx scripts/ci/lib/jwt.ts decode "$TOKEN" || echo "Decode debug completed"
                  exit 1
                fi
                
                # Test verify functionality
                if pnpm -s tsx scripts/ci/lib/jwt.ts verify "$TOKEN" > /dev/null 2>&1; then
                  echo "‚úÖ JWT verify works correctly"
                  echo "üéØ JWT auth system is fully operational"
                else
                  echo "‚ùå JWT verify failed"
                  echo "üîç Debug: Testing verify with verbose output..."
                  pnpm tsx scripts/ci/lib/jwt.ts verify "$TOKEN" || echo "Verify debug completed"
                  exit 1
                fi
              else
                echo "‚ùå JWT minting returned empty token"
                exit 1
              fi
              
            else
              echo "‚ùå JWT minting failed - check JWT_SECRET format (should be 64+ hex chars)"
              exit 1
            fi
          else
            echo "‚ùå JWT_SECRET not configured - required for runtime auth"
            echo "Note: If this is a PR from a fork, secrets are not available for security"
            exit 1
          fi
          
      - name: Validate secret strength
        env:
          # Provide actual secrets for validation in CI
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }} 
          CRON_TOKEN: ${{ secrets.CRON_TOKEN }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
        run: |
          echo "üîç Running secret validation..."
          echo "Preferred auth method: JWT_SECRET (runtime minting)"
          echo "Legacy fallback: AUTH_TOKEN"
          pnpm run validate-secrets -- --verbose
          
      - name: Validate in strict mode
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
          CRON_TOKEN: ${{ secrets.CRON_TOKEN }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
        run: |
          echo "üîí Running strict validation (warnings = errors)..."
          pnpm run validate-secrets -- --strict
          
      - name: Comment on PR (if failed)
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ‚ùå Secret Validation Failed
              
              The secret validation check failed. This could be due to:
              
              - **JWT_SECRET issues**: Primary auth secret not configured or format invalid (requires 64+ hex chars)
              - **JWT minting failures**: Runtime token generation not working correctly
              - **Weak tokens**: Legacy tokens that don't meet security requirements (length < 32, weak patterns)
              - **Missing environment variables**: Variables used in code but not documented in .env.example
              - **Format violations**: Invalid hex/base64/alphanumeric formats
              
              ### Next Steps
              
              1. Check the workflow logs for specific validation errors
              2. **Priority**: Ensure JWT_SECRET is configured and valid (64+ hex chars)
              3. Use \`pnpm run validate-secrets -- --verbose\` locally to debug
              4. For JWT issues, use JWT utility: \`pnpm tsx scripts/ci/lib/jwt.ts mint --ttl 5m\`
              5. For legacy token issues, use \`pnpm run rotate-tokens <TOKEN_NAME>\` to generate new tokens
              6. For missing env vars, add them to .env.example
              
              ### Auth Migration Note
              
              We prefer JWT_SECRET (runtime minting) over static AUTH_TOKEN. Ensure JWT_SECRET is properly configured.
              
              ### Security Note
              
              This validation ensures all secrets meet security standards. Do not bypass these checks without security team approval.
              `
            })

  environment-completeness:
    runs-on: ubuntu-latest
    name: Environment Variable Completeness Check
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.18.3
          
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Check environment completeness
        run: |
          echo "üìã Checking environment variable completeness..."
          
          # Extract all process.env references from codebase
          echo "Variables referenced in codebase:"
          grep -r "process\.env\." app/ lib/ components/ scripts/ middleware.* next.config.* 2>/dev/null \
            | grep -oE 'process\.env\.([A-Z_][A-Z0-9_]*)' \
            | sed 's/process\.env\.//' \
            | sort -u \
            | tee /tmp/codebase_vars.txt
          
          echo ""
          echo "Variables in .env.example:"
          if [ -f .env.example ]; then
            grep -E '^[A-Z_][A-Z0-9_]*=' .env.example | cut -d= -f1 | sort | tee /tmp/env_example_vars.txt
          else
            echo "‚ö†Ô∏è .env.example not found"
            touch /tmp/env_example_vars.txt
          fi
          
          echo ""
          echo "Missing from .env.example:"
          comm -23 /tmp/codebase_vars.txt /tmp/env_example_vars.txt | tee /tmp/missing_vars.txt
          
          # Filter out system variables that don't need to be in .env.example
          SYSTEM_VARS="NODE_ENV PORT PWD PATH HOME USER VERCEL VERCEL_ENV VERCEL_URL VERCEL_REGION GITHUB_ACTIONS GITHUB_SHA GITHUB_REF GITHUB_EVENT_NAME GITHUB_EVENT_PATH GITHUB_OUTPUT GITHUB_STEP_SUMMARY GITHUB_WORKSPACE GITHUB_REPOSITORY GITHUB_RUN_ID GITHUB_RUN_NUMBER GITHUB_ACTOR CI BUILD_ID NEXT_RUNTIME"
          
          for var in $SYSTEM_VARS; do
            sed -i "/^$var$/d" /tmp/missing_vars.txt 2>/dev/null || true
          done
          
          if [ -s /tmp/missing_vars.txt ]; then
            echo "‚ùå Missing variables found:"
            cat /tmp/missing_vars.txt
            echo ""
            echo "Please add these variables to .env.example with appropriate example values."
            exit 1
          else
            echo "‚úÖ All codebase variables are documented in .env.example"
          fi

  token-strength-check:
    runs-on: ubuntu-latest
    name: Token Strength Verification
    if: github.event_name == 'schedule' # Only run on scheduled builds
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.18.3
          
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Check token rotation schedule
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
          CRON_TOKEN: ${{ secrets.CRON_TOKEN }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
        run: |
          echo "üóìÔ∏è Checking token rotation schedule..."
          echo "Primary auth method: JWT_SECRET (runtime minting)"
          echo "Legacy fallback: AUTH_TOKEN"
          
          # Check if any tokens need rotation based on docs/secrets.md
          # This is a simplified check - in production you might want to store
          # rotation dates in a database or separate tracking system
          
          CURRENT_DATE=$(date +%Y-%m-%d)
          echo "Current date: $CURRENT_DATE"
          
          # Test JWT minting first
          if [ -n "$JWT_SECRET" ]; then
            echo "‚úÖ JWT_SECRET configured"
            if pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 1m > /dev/null 2>&1; then
              echo "‚úÖ JWT minting operational"
            else
              echo "‚ùå JWT minting failed - may need JWT_SECRET rotation"
            fi
          else
            echo "‚ö†Ô∏è JWT_SECRET not configured - consider migrating from AUTH_TOKEN"
          fi
          
          # Check docs/secrets.md for last rotation dates
          if [ -f docs/secrets.md ]; then
            echo "Last rotation dates from docs/secrets.md:"
            grep -E "JWT_SECRET|AUTH_TOKEN|CRON_TOKEN|ADMIN_PASSWORD" docs/secrets.md || true
          fi
          
          # Run token validation to ensure current tokens are still strong
          pnpm run validate-secrets -- --verbose
          
          echo "üìä Token strength verification completed"
          
      - name: Create rotation issue (if needed)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = `üîê Token Rotation Required - ${new Date().toISOString().split('T')[0]}`
            const body = `## Token Rotation Required
            
            The weekly secret audit has detected tokens that may need rotation.
            
            ### Action Required
            
            1. **Priority**: Ensure JWT_SECRET is configured and operational (primary auth method)
            2. Review token rotation schedule in \`docs/secrets.md\`
            3. Identify tokens due for rotation
            4. For JWT_SECRET: Use \`pnpm tsx scripts/ci/lib/jwt.ts\` to test minting
            5. For legacy tokens: Use rotation script: \`pnpm run rotate-tokens <TOKEN_NAME>\`
            6. Update all storage locations (GitHub Secrets, Vercel, etc.)
            7. Test functionality with new tokens
            8. Update rotation log
            
            ### Auth Migration
            
            - **Preferred**: JWT_SECRET (runtime minting with HMAC-SHA256)
            - **Legacy**: AUTH_TOKEN (static tokens, being phased out)
            
            Ensure JWT_SECRET is properly configured before deprecating AUTH_TOKEN.
            
            ### Automation
            
            This issue was created automatically by the secret validation workflow.
            
            /cc @security-team
            `
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['security', 'rotation', 'automated']
            })