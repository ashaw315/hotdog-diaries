name: Deploy Gate

on:
  deployment_status:
  push:
    branches: [ main ]
  workflow_run:
    workflows: ["Vercel Production Deployment"]
    types: 
      - completed

permissions:
  contents: read
  issues: write  # Only for failure notifications
  checks: write
  pull-requests: write

env:
  PROD_URL: https://hotdog-diaries.vercel.app

jobs:
  auth-token-validation:
    runs-on: ubuntu-latest
    name: Validate Runtime JWT Deploy Gate
    if: github.event_name == 'push' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Setup pnpm
        run: |
          corepack enable
          corepack prepare pnpm@9 --activate
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Wait for deployment
        if: github.event_name == 'push'
        run: |
          echo "‚è≥ Waiting for deployment to be available..."
          sleep 30
          
      - name: Mint runtime JWT token
        run: |
          echo "üîê Minting runtime JWT token for deploy gate..."
          
          # Try runtime token first, fall back to legacy AUTH_TOKEN if minting fails
          if TOKEN=$(pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 15m --sub ci-gate --aud ci --iss hotdog-diaries 2>/dev/null); then
            echo "‚úÖ Successfully minted runtime JWT token"
            echo "TOKEN=$TOKEN" >> $GITHUB_ENV
            echo "TOKEN_TYPE=runtime" >> $GITHUB_ENV
          elif [ -n "${{ secrets.AUTH_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Runtime token minting failed, falling back to legacy AUTH_TOKEN"
            echo "TOKEN=${{ secrets.AUTH_TOKEN }}" >> $GITHUB_ENV
            echo "TOKEN_TYPE=legacy" >> $GITHUB_ENV
          else
            echo "‚ùå No token available - neither runtime minting nor legacy AUTH_TOKEN works"
            exit 1
          fi
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          
      - name: Test auth self-test endpoint with runtime token
        run: |
          echo "üîç Testing auth self-test endpoint..."
          echo "Token type: $TOKEN_TYPE"
          
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            "${{ env.PROD_URL }}/api/health/auth-selftest")
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response Body: $BODY"
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Auth self-test validation passed"
            
            # Parse and display auth details
            if echo "$BODY" | jq -e '.ok == true' > /dev/null; then
              echo "‚úÖ Auth self-test successful"
              
              # Extract key details
              ISS=$(echo "$BODY" | jq -r '.iss // "unknown"')
              AUD=$(echo "$BODY" | jq -r '.aud // "unknown"') 
              SUB=$(echo "$BODY" | jq -r '.sub // "unknown"')
              KEY_VERSION=$(echo "$BODY" | jq -r '.keyVersion // "null"')
              EXP=$(echo "$BODY" | jq -r '.exp // "unknown"')
              
              echo "üìä Token Details:"
              echo "  - Issuer: $ISS"
              echo "  - Audience: $AUD"
              echo "  - Subject: $SUB"
              echo "  - Key Version: $KEY_VERSION"
              echo "  - Expires: $EXP"
              echo "  - Token Type: $TOKEN_TYPE"
              
            else
              echo "‚ùå Auth self-test response missing success indicator"
              exit 1
            fi
          else
            echo "‚ùå Auth self-test failed with status $HTTP_STATUS"
            
            # Parse error details
            if [ "$HTTP_STATUS" -eq 401 ]; then
              CODE=$(echo "$BODY" | jq -r '.code // "unknown"')
              DETAIL=$(echo "$BODY" | jq -r '.detail // "no details"')
              
              case "$CODE" in
                "INVALID_SIGNATURE")
                  echo "üö® JWT_SECRET mismatch between CI and Prod (key drift). Rotate or sync."
                  ;;
                "EXPIRED")
                  echo "üö® Token TTL too short or clock skew."
                  ;;
                "MISSING")
                  echo "üö® No authentication token provided."
                  ;;
                *)
                  echo "üö® Auth error: $CODE - $DETAIL"
                  ;;
              esac
            fi
            
            exit 1
          fi
          
      - name: Test health probe with invalid token
        run: |
          echo "üß™ Testing auth token health probe with invalid token..."
          
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer invalid-token-12345" \
            "${{ env.PROD_URL }}/api/admin/health/auth-token")
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response Body: $BODY"
          
          if [ "$HTTP_STATUS" -eq 401 ]; then
            echo "‚úÖ Invalid token correctly rejected"
            
            # Verify response contains mismatch code
            CODE=$(echo "$BODY" | jq -r '.code // "unknown"')
            if [ "$CODE" = "AUTH_TOKEN_MISMATCH" ]; then
              echo "‚úÖ Response contains correct error code: AUTH_TOKEN_MISMATCH"
            else
              echo "‚ö†Ô∏è Response contains unexpected error code: $CODE"
            fi
          else
            echo "‚ùå Invalid token should have been rejected with 401"
            exit 1
          fi
          
      - name: Test health probe without token
        run: |
          echo "üß™ Testing auth token health probe without token..."
          
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            "${{ env.PROD_URL }}/api/admin/health/auth-token")
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response Body: $BODY"
          
          if [ "$HTTP_STATUS" -eq 401 ]; then
            echo "‚úÖ Missing token correctly rejected"
            
            # Verify response contains missing token code
            CODE=$(echo "$BODY" | jq -r '.code // "unknown"')
            if [ "$CODE" = "AUTH_TOKEN_MISSING" ]; then
              echo "‚úÖ Response contains correct error code: AUTH_TOKEN_MISSING"
            else
              echo "‚ö†Ô∏è Response contains unexpected error code: $CODE"
            fi
          else
            echo "‚ùå Missing token should have been rejected with 401"
            exit 1
          fi

  comprehensive-health-check:
    runs-on: ubuntu-latest
    name: Comprehensive Health Validation
    needs: auth-token-validation
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Setup pnpm
        run: |
          corepack enable
          corepack prepare pnpm@9 --activate
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Mint runtime JWT token for health check
        run: |
          echo "üîê Minting runtime JWT token for health validation..."
          
          # Try runtime token first, fall back to legacy AUTH_TOKEN if minting fails
          if TOKEN=$(pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 10m --sub ci-health --aud ci --iss hotdog-diaries 2>/dev/null); then
            echo "‚úÖ Successfully minted runtime JWT token for health check"
            echo "TOKEN=$TOKEN" >> $GITHUB_ENV
          elif [ -n "${{ secrets.AUTH_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Runtime token minting failed, falling back to legacy AUTH_TOKEN"
            echo "TOKEN=${{ secrets.AUTH_TOKEN }}" >> $GITHUB_ENV
          else
            echo "‚ùå No token available for health check"
            exit 1
          fi
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
      
      - name: Deep health check
        run: |
          echo "üè• Running comprehensive health validation..."
          
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            "${{ env.PROD_URL }}/api/admin/health/deep")
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "HTTP Status: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Deep health check passed"
            
            # Verify response structure
            OK_STATUS=$(echo "$BODY" | jq -r '.ok // false')
            if [ "$OK_STATUS" = "true" ]; then
              echo "‚úÖ Health status is OK"
              
              # Show component health
              echo "üìä Component Health:"
              echo "$BODY" | jq '.components // {}' || echo "No component details available"
              
            else
              echo "‚ùå Health status indicates issues"
              echo "$BODY" | jq '.components // {}' || echo "No component details available"
              exit 1
            fi
          else
            echo "‚ùå Deep health check failed with status $HTTP_STATUS"
            echo "Response: $BODY"
            exit 1
          fi
          
      - name: Admin endpoint smoke test
        run: |
          echo "üí® Running admin endpoint smoke test..."
          
          # Test a few critical admin endpoints
          ENDPOINTS=(
            "/api/admin/dashboard/stats"
            "/api/admin/queue/health"
            "/api/admin/platforms/status"
          )
          
          for ENDPOINT in "${ENDPOINTS[@]}"; do
            echo "Testing $ENDPOINT..."
            
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              -H "Authorization: Bearer $TOKEN" \
              "${{ env.PROD_URL }}$ENDPOINT")
            
            HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
            
            if [ "$HTTP_STATUS" -eq 200 ]; then
              echo "‚úÖ $ENDPOINT responding"
            else
              echo "‚ùå $ENDPOINT failed with status $HTTP_STATUS"
              # Don't fail the entire gate for individual endpoint issues
              # Just log them for monitoring
            fi
          done

  deployment-gate-result:
    runs-on: ubuntu-latest
    name: Deployment Gate Result
    needs: [auth-token-validation, comprehensive-health-check]
    if: always()
    
    steps:
      - name: Check gate results
        run: |
          echo "üö™ Deployment Gate Results"
          echo "=========================="
          
          AUTH_RESULT="${{ needs.auth-token-validation.result }}"
          HEALTH_RESULT="${{ needs.comprehensive-health-check.result }}"
          
          echo "Auth Token Validation: $AUTH_RESULT"
          echo "Health Check: $HEALTH_RESULT"
          
          if [ "$AUTH_RESULT" = "success" ] && [ "$HEALTH_RESULT" = "success" ]; then
            echo ""
            echo "‚úÖ DEPLOYMENT GATE PASSED"
            echo "All security and health validations successful."
            echo "Deployment is approved for production traffic."
          else
            echo ""
            echo "‚ùå DEPLOYMENT GATE FAILED"
            echo "Security or health validations failed."
            echo "Deployment should be rolled back or investigated."
            exit 1
          fi
          
      - name: ‚úÖ Deployment Success
        if: needs.auth-token-validation.result == 'success' && needs.comprehensive-health-check.result == 'success'
        run: |
          echo "üéâ DEPLOYMENT GATE PASSED"
          echo "========================="
          echo "‚úÖ Auth Token Validation: Success"
          echo "‚úÖ Comprehensive Health Check: Success"
          echo "‚úÖ Admin Endpoint Smoke Test: Success"
          echo ""
          echo "üöÄ Deployment approved for production traffic"
          echo "üåê Production URL: ${{ env.PROD_URL }}"
          echo "üè• Health Probe: ${{ env.PROD_URL }}/api/admin/health/auth-token"
          echo ""
          echo "## üéâ Deployment Gate Success" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: $(date -u -Iseconds)" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Validation Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Auth Token Validation**: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Comprehensive Health Check**: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Admin Endpoint Smoke Test**: Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üöÄ All security and health validations passed - deployment approved!" >> $GITHUB_STEP_SUMMARY
      - name: Create deployment failure issue
        if: needs.auth-token-validation.result != 'success' || needs.comprehensive-health-check.result != 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `üö® Deployment Gate Failed - ${new Date().toISOString().split('T')[0]}`
            const body = `## Deployment Gate Failure
            
            **Deployment**: ${{ github.sha }}  
            **Timestamp**: ${new Date().toISOString()}  
            **Environment**: Production  
            
            ### Validation Results
            
            - ${{ needs.auth-token-validation.result == 'success' && '‚úÖ' || '‚ùå' }} **Auth Token Validation**: ${{ needs.auth-token-validation.result }}
            - ${{ needs.comprehensive-health-check.result == 'success' && '‚úÖ' || '‚ùå' }} **Comprehensive Health Check**: ${{ needs.comprehensive-health-check.result }}
            
            ### Immediate Actions Required
            
            1. **Check workflow logs** for specific failure details
            2. **Verify AUTH_TOKEN secret** is correct and not expired
            3. **Test health endpoints** manually to isolate issues
            4. **Consider rollback** if critical functionality is impacted
            
            ### Investigation
            
            - **Health Probe**: ${{ env.PROD_URL }}/api/admin/health/auth-token
            - **Deep Health**: ${{ env.PROD_URL }}/api/admin/health/deep
            - **Workflow**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
            ### Security Note
            
            If the failure is due to AUTH_TOKEN_MISMATCH, this indicates a security configuration issue that must be resolved before deployment approval.
            
            /cc @security-team @devops-team
            
            This alert was generated automatically by the deployment gate workflow.
            `
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment', 'failure', 'security', 'urgent', 'automated']
            })