name: Deploy Gate

on:
  deployment_status:
  push:
    branches: [ main ]
  workflow_run:
    workflows: ["Vercel Production Deployment"]
    types: 
      - completed

permissions:
  contents: read
  actions: read
  checks: write

env:
  PROD_URL: https://hotdog-diaries.vercel.app

jobs:
  context:
    runs-on: ubuntu-latest
    name: Deployment Context Analysis
    outputs:
      state: ${{ steps.ctx.outputs.state }}
      url: ${{ steps.ctx.outputs.url }}
      commit: ${{ steps.ctx.outputs.commit }}
      reason: ${{ steps.ctx.outputs.reason }}
      proceed: ${{ steps.ctx.outputs.proceed }}
      environment: ${{ steps.ctx.outputs.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - uses: pnpm/action-setup@v4
          
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Analyze deployment context
        id: ctx
        run: |
          echo "üîç Analyzing deployment context for gate decisions..."
          echo "Event: ${{ github.event_name }}"
          
          # For deployment_status events, check the deployment state first
          if [ "${{ github.event_name }}" = "deployment_status" ]; then
            DEPLOY_STATE="${{ github.event.deployment_status.state }}"
            echo "üìå Deployment status event with state: $DEPLOY_STATE"
            
            # Only proceed if deployment was successful
            if [ "$DEPLOY_STATE" != "success" ]; then
              echo "‚è∏Ô∏è Deployment state is not success ($DEPLOY_STATE) - neutralizing"
              echo "proceed=false" >> $GITHUB_OUTPUT
              echo "state=$DEPLOY_STATE" >> $GITHUB_OUTPUT
              echo "url=${{ github.event.deployment_status.target_url }}" >> $GITHUB_OUTPUT
              echo "commit=${{ github.event.deployment.sha }}" >> $GITHUB_OUTPUT
              echo "reason=Deployment state is $DEPLOY_STATE" >> $GITHUB_OUTPUT
              echo "neutralized=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # For successful deployments, extract context
            echo "proceed=true" >> $GITHUB_OUTPUT
            echo "state=success" >> $GITHUB_OUTPUT
            echo "url=${{ github.event.deployment_status.target_url }}" >> $GITHUB_OUTPUT
            echo "commit=${{ github.event.deployment.sha }}" >> $GITHUB_OUTPUT
            echo "reason=Deployment successful" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.deployment.environment }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For push events, wait longer for deployment to materialize
          MAX_WAIT=4
          if [ "${{ github.event_name }}" = "push" ]; then
            MAX_WAIT=6
            echo "üìå Push event: will wait up to ${MAX_WAIT} minutes for Vercel deployment"
          fi
          
          # Run deployment context analysis for non-deployment_status events
          if ! pnpm tsx scripts/ci/lib/deploy-context.ts analyze --max-wait=$MAX_WAIT; then
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 78 ]; then
              echo "‚è∏Ô∏è Deployment not ready - will conclude neutrally"
              echo "proceed=false" >> $GITHUB_OUTPUT
              echo "neutralized=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ùå Hard error analyzing deployment context"
              exit 1
            fi
          fi
          
          echo "‚úÖ Deployment ready for gate validation"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_TEAM_ID: ${{ secrets.VERCEL_TEAM_ID }}
          
      - name: Neutralize on deployment failure
        if: steps.ctx.outputs.proceed != 'true'
        run: |
          echo "‚è∏Ô∏è Neutralizing deploy gate due to upstream deployment issue"
          echo "State: ${{ steps.ctx.outputs.state }}"
          echo "Reason: ${{ steps.ctx.outputs.reason }}"
          
          # Write neutral summary
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ‚è∏Ô∏è Deploy Gate Neutralized
          
          The deployment gate has been neutralized because the upstream deployment is not ready for validation.
          
          | Field | Value |
          |-------|-------|
          | **Deployment State** | `${{ steps.ctx.outputs.state }}` |
          | **Reason** | ${{ steps.ctx.outputs.reason }} |
          | **URL Available** | ${{ steps.ctx.outputs.url && 'Yes' || 'No' }} |
          | **Commit** | `${{ steps.ctx.outputs.commit }}` |
          
          ### üîÑ Next Steps
          
          This is normal and expected for:
          - Failed deployments (fix deployment issues first)
          - Deployments still in progress (wait for completion)
          - Missing preview URLs (check Vercel configuration)
          
          **No action required** - the gate will automatically re-run when the deployment succeeds.
          EOF
          
          exit 0

  neutralize:
    runs-on: ubuntu-latest
    name: Neutralize Deployment Gate
    needs: [context]
    if: needs.context.outputs.proceed != 'true'
    
    steps:
      - name: Checkout for neutralize action
        uses: actions/checkout@v4
        
      - name: Neutralize with summary
        uses: ./.github/actions/neutralize
        with:
          reason: "Upstream deployment not successful or preview URL unavailable"
          deploy_state: ${{ needs.context.outputs.state }}
          deploy_reason: ${{ needs.context.outputs.reason }}
          deploy_url: ${{ needs.context.outputs.url }}

  auth-token-validation:
    runs-on: ubuntu-latest
    name: Validate Runtime JWT Deploy Gate
    needs: context
    if: |
      always() && 
      needs.context.result == 'success' &&
      needs.context.outputs.proceed == 'true'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - uses: pnpm/action-setup@v4
          
      - name: Setup Node.js with pnpm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Set deployment URL
        run: |
          echo "üåê Using deployment URL from context analysis..."
          DEPLOY_URL="${{ needs.context.outputs.url }}"
          if [ -n "$DEPLOY_URL" ]; then
            echo "‚úÖ Using resolved deployment URL: $DEPLOY_URL"
            echo "TARGET_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "üìå No deployment URL, falling back to production URL"
            echo "TARGET_URL=${{ env.PROD_URL }}" >> $GITHUB_ENV
          fi
          
      - name: Mint runtime JWT token
        run: |
          echo "üîê Minting runtime JWT token for deploy gate..."
          
          # Try runtime token first, fall back to legacy AUTH_TOKEN if minting fails
          if TOKEN=$(pnpm -s tsx scripts/ci/lib/jwt.ts mint --ttl 15m --sub ci-gate --aud admin --iss hotdog-diaries 2>/dev/null); then
            echo "‚úÖ Successfully minted runtime JWT token"
            echo "TOKEN=$TOKEN" >> $GITHUB_ENV
            echo "TOKEN_TYPE=runtime" >> $GITHUB_ENV
          elif [ -n "${{ secrets.AUTH_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Runtime token minting failed, falling back to legacy AUTH_TOKEN"
            echo "TOKEN=${{ secrets.AUTH_TOKEN }}" >> $GITHUB_ENV
            echo "TOKEN_TYPE=legacy" >> $GITHUB_ENV
          else
            echo "‚ùå No token available - neither runtime minting nor legacy AUTH_TOKEN works"
            exit 1
          fi
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          
      - name: Test runtime JWT validation
        run: |
          echo "üîç Testing runtime JWT validation..."
          echo "Token type: $TOKEN_TYPE"
          echo "Target URL: $TARGET_URL"
          
          # Test JWT token locally first (quick validation)
          if ! pnpm -s tsx scripts/ci/lib/jwt.ts verify --token "$TOKEN" 2>/dev/null; then
            echo "‚ùå Token failed local verification"
            exit 1
          fi
          echo "‚úÖ Token passed local verification"
          
          # Check if this is a preview deployment and test basic connectivity
          if [[ "$TARGET_URL" == *"vercel.app"* ]] && [[ "$TARGET_URL" != *"hotdog-diaries.vercel.app"* ]]; then
            echo "‚ö†Ô∏è Preview deployment detected - checking basic connectivity"
            
            # Try preview health endpoint first
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              "$TARGET_URL/api/health" || echo "HTTPSTATUS:000")
            
            HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
            
            # If preview fails with auth wall, fall back to production
            if [ "$HTTP_STATUS" -eq 401 ] && echo "$RESPONSE" | grep -q "Authentication Required"; then
              echo "üîÑ Preview has Vercel auth protection - testing production instead"
              TARGET_URL="${{ env.PROD_URL }}"
              echo "Fallback URL: $TARGET_URL"
              
              RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
                "$TARGET_URL/api/health")
            fi
          else
            echo "üåê Testing production or main deployment"
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              "$TARGET_URL/api/health")
          fi
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response Body (first 200 chars): ${BODY:0:200}"
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Basic health endpoint responding"
            
            # Parse health response
            if echo "$BODY" | jq -e '.success == true' > /dev/null; then
              echo "‚úÖ Health endpoint structure valid"
              
              # Check for service info
              SERVICE=$(echo "$BODY" | jq -r '.data.service // "unknown"')
              ENV=$(echo "$BODY" | jq -r '.data.environment // "unknown"')
              
              echo "üìä Deployment Details:"
              echo "  - Service: $SERVICE"
              echo "  - Environment: $ENV"
              echo "  - Token Type: $TOKEN_TYPE"
              echo "  - Target URL: $TARGET_URL"
              
              # For runtime tokens, this validates both the minting process and basic connectivity
              if [ "$TOKEN_TYPE" = "runtime" ]; then
                echo "‚úÖ Runtime JWT token and deployment connectivity validated"
              else
                echo "‚úÖ Legacy token and deployment connectivity validated"
              fi
              
            else
              echo "‚ùå Health endpoint returned unexpected structure"
              exit 1
            fi
          else
            echo "‚ùå Health endpoint failed with status $HTTP_STATUS"
            echo "This indicates deployment or connectivity issues"
            exit 1
          fi
          
      - name: Test health probe with invalid token
        run: |
          echo "üß™ Testing auth token health probe with invalid token..."
          
          # Check if this is a preview deployment and handle Vercel auth protection
          if [[ "$TARGET_URL" == *"vercel.app"* ]] && [[ "$TARGET_URL" != *"hotdog-diaries.vercel.app"* ]]; then
            echo "‚ö†Ô∏è Preview deployment - testing for Vercel auth protection..."
            
            # Try preview first
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              -H "Authorization: Bearer invalid-token-12345" \
              "$TARGET_URL/api/admin/health/auth-token" || echo "HTTPSTATUS:000")
            
            HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
            
            # If preview fails with auth wall, fall back to production
            if [ "$HTTP_STATUS" -eq 401 ] && echo "$RESPONSE" | grep -q "Authentication Required"; then
              echo "üîÑ Preview has Vercel auth protection - testing production instead"
              TARGET_URL="${{ env.PROD_URL }}"
              echo "Fallback URL: $TARGET_URL"
              
              RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
                -H "Authorization: Bearer invalid-token-12345" \
                "$TARGET_URL/api/admin/health/auth-token")
            fi
          else
            echo "üåê Testing production or main deployment"
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              -H "Authorization: Bearer invalid-token-12345" \
              "$TARGET_URL/api/admin/health/auth-token")
          fi
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response Body (first 200 chars): ${BODY:0:200}"
          
          if [ "$HTTP_STATUS" -eq 401 ]; then
            echo "‚úÖ Invalid token correctly rejected"
            
            # Verify response contains mismatch code
            CODE=$(echo "$BODY" | jq -r '.code // "unknown"')
            if [ "$CODE" = "AUTH_TOKEN_MISMATCH" ]; then
              echo "‚úÖ Response contains correct error code: AUTH_TOKEN_MISMATCH"
            else
              echo "‚ö†Ô∏è Response contains unexpected error code: $CODE"
            fi
          else
            echo "‚ùå Invalid token should have been rejected with 401"
            exit 1
          fi
          
      - name: Test health probe without token
        run: |
          echo "üß™ Testing auth token health probe without token..."
          
          # Check if this is a preview deployment and handle Vercel auth protection
          if [[ "$TARGET_URL" == *"vercel.app"* ]] && [[ "$TARGET_URL" != *"hotdog-diaries.vercel.app"* ]]; then
            echo "‚ö†Ô∏è Preview deployment - testing for Vercel auth protection..."
            
            # Try preview first
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              "$TARGET_URL/api/admin/health/auth-token" || echo "HTTPSTATUS:000")
            
            HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
            
            # If preview fails with auth wall, fall back to production
            if [ "$HTTP_STATUS" -eq 401 ] && echo "$RESPONSE" | grep -q "Authentication Required"; then
              echo "üîÑ Preview has Vercel auth protection - testing production instead"
              TARGET_URL="${{ env.PROD_URL }}"
              echo "Fallback URL: $TARGET_URL"
              
              RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
                "$TARGET_URL/api/admin/health/auth-token")
            fi
          else
            echo "üåê Testing production or main deployment"
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code}" \
              "$TARGET_URL/api/admin/health/auth-token")
          fi
          
          HTTP_STATUS=$(echo $RESPONSE | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          BODY=$(echo $RESPONSE | sed -e 's/HTTPSTATUS:.*//g')
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response Body: $BODY"
          
          if [ "$HTTP_STATUS" -eq 401 ]; then
            echo "‚úÖ Missing token correctly rejected"
            
            # Verify response contains missing token code
            CODE=$(echo "$BODY" | jq -r '.code // "unknown"')
            if [ "$CODE" = "AUTH_TOKEN_MISSING" ]; then
              echo "‚úÖ Response contains correct error code: AUTH_TOKEN_MISSING"
            else
              echo "‚ö†Ô∏è Response contains unexpected error code: $CODE"
            fi
          else
            echo "‚ùå Missing token should have been rejected with 401"
            exit 1
          fi

  # comprehensive-health-check job removed - moved to prod-watchdog.yml
  # This reduces deployment gate complexity while maintaining deep validation in scheduled monitoring

  deployment-gate-result:
    runs-on: ubuntu-latest
    name: Deployment Gate Result
    needs: [context, neutralize, auth-token-validation]
    if: always()
    
    steps:
      - name: Check gate results (Advisory Mode)
        run: |
          echo "üö™ Deployment Gate Results (Advisory Mode)"
          echo "==========================================="
          
          CONTEXT_PROCEED="${{ needs.context.outputs.proceed }}"
          CONTEXT_STATE="${{ needs.context.outputs.state }}"
          AUTH_RESULT="${{ needs.auth-token-validation.result }}"
          
          echo "Context Analysis: proceed=$CONTEXT_PROCEED, state=$CONTEXT_STATE"
          echo "Auth Token Validation: $AUTH_RESULT"
          echo "Note: Deep health checks moved to prod-watchdog.yml for scheduled monitoring"
          
          # Always conclude neutrally/successfully in streamlined CI mode
          # Convert all results to advisory/informational status
          
          if [ "$CONTEXT_PROCEED" != "true" ]; then
            echo ""
            echo "‚ÑπÔ∏è DEPLOYMENT GATE: ADVISORY STATUS"
            echo "Deployment not ready for validation (state: $CONTEXT_STATE)"
            echo "Reason: ${{ needs.context.outputs.reason }}"
            echo "Status: Informational - this does not block deployment"
            exit 0
          fi
          
          # Report validation results as advisory information (streamlined)
          if [ "$AUTH_RESULT" = "skipped" ]; then
            echo ""
            echo "‚ÑπÔ∏è DEPLOYMENT GATE: ADVISORY STATUS" 
            echo "Auth validation skipped due to upstream deployment context."
            echo "Status: Informational - this is expected for some deployment states"
          elif [ "$AUTH_RESULT" = "success" ]; then
            echo ""
            echo "‚úÖ DEPLOYMENT GATE: ADVISORY PASSED"
            echo "Auth token validation successful."
            echo "Status: Informational - basic deployment validation looks good"
            echo "Note: Deep health checks run separately in prod-watchdog.yml"
          else
            echo ""
            echo "‚ö†Ô∏è DEPLOYMENT GATE: ADVISORY WARNINGS"
            echo "Auth token validation had issues."
            echo "Auth result: $AUTH_RESULT"
            echo "Status: Informational - consider investigating auth configuration"
            echo "Note: This does not block deployment in streamlined CI mode"
          fi
          
          # Always exit 0 for advisory mode - never fail the gate
          echo ""
          echo "üîÑ Advisory mode: All deployment gate results are informational only"
          exit 0
          
      - name: ‚ÑπÔ∏è Advisory Success Summary
        if: needs.context.outputs.proceed == 'true' && needs.auth-token-validation.result == 'success'
        run: |
          echo "‚ÑπÔ∏è DEPLOYMENT GATE: ADVISORY SUCCESS"
          echo "===================================="
          echo "‚úÖ Auth Token Validation: Success"
          echo "‚ÑπÔ∏è Deep Health Check: Moved to prod-watchdog.yml"
          echo "‚ÑπÔ∏è Admin Endpoint Smoke Test: Moved to prod-watchdog.yml"
          echo ""
          echo "üìã Advisory Status: All validations passed"
          echo "üåê Production URL: ${{ env.PROD_URL }}"
          echo "üè• Health Probe: ${{ env.PROD_URL }}/api/admin/health/auth-token"
          echo ""
          echo "## ‚ÑπÔ∏è Deployment Gate Advisory Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: $(date -u -Iseconds)" >> $GITHUB_STEP_SUMMARY
          echo "**Mode**: Advisory (Streamlined CI)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Validation Results (Advisory)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Auth Token Validation**: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚ÑπÔ∏è **Deep Health Check**: Moved to prod-watchdog.yml (scheduled)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚ÑπÔ∏è **Admin Endpoint Smoke Test**: Moved to prod-watchdog.yml (scheduled)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìã **Status**: All deployment validations passed in advisory mode" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> üîÑ **Note**: This gate runs in advisory mode and provides informational status only" >> $GITHUB_STEP_SUMMARY
      - name: Log advisory warnings (No Issue Creation)
        if: needs.context.outputs.proceed == 'true' && needs.auth-token-validation.result != 'success'
        run: |
          echo "‚ö†Ô∏è ADVISORY MODE: Deployment gate warnings detected"
          echo "================================================="
          echo ""
          echo "**Deployment**: ${{ github.sha }}"
          echo "**Timestamp**: $(date -u -Iseconds)"
          echo "**Mode**: Advisory (Streamlined CI)"
          echo ""
          echo "### Validation Results"
          echo "- Auth Token Validation: ${{ needs.auth-token-validation.result }}"
          echo "- Deep Health Check: Moved to prod-watchdog.yml (scheduled monitoring)"
          echo ""
          echo "### Advisory Notice"
          echo "In streamlined CI mode, deployment gate warnings are logged"
          echo "but do not block deployment or create issues automatically."
          echo ""
          echo "üìã Consider reviewing these warnings in workflow logs:"
          echo "üîó ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo ""
          echo "üè• Health endpoints for manual verification:"
          echo "- Basic: ${{ env.PROD_URL }}/api/health"
          echo "- Auth: ${{ env.PROD_URL }}/api/admin/health/auth-token"
          echo "- Deep: ${{ env.PROD_URL }}/api/admin/health/deep"