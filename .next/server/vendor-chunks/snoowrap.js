/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snoowrap";
exports.ids = ["vendor-chunks/snoowrap"];
exports.modules = {

/***/ "(rsc)/./node_modules/snoowrap/dist/Promise.js":
/*!***********************************************!*\
  !*** ./node_modules/snoowrap/dist/Promise.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _bluebird = _interopRequireDefault(__webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PromiseCopy = _bluebird.default.getNewLibraryCopy();\n\nPromiseCopy.config({\n  cancellation: true,\n  warnings: false\n});\nvar _default = PromiseCopy;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9Qcm9taXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmLHVDQUF1QyxtQkFBTyxDQUFDLHNFQUFVOztBQUV6RCx1Q0FBdUMsdUNBQXVDOztBQUU5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L1Byb21pc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfYmx1ZWJpcmQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBQcm9taXNlQ29weSA9IF9ibHVlYmlyZC5kZWZhdWx0LmdldE5ld0xpYnJhcnlDb3B5KCk7XG5cblByb21pc2VDb3B5LmNvbmZpZyh7XG4gIGNhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgd2FybmluZ3M6IGZhbHNlXG59KTtcbnZhciBfZGVmYXVsdCA9IFByb21pc2VDb3B5O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/Promise.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/snoowrap/dist/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MAX_LISTING_ITEMS = exports.MAX_API_MORECHILDREN_AMOUNT = exports.MAX_API_INFO_AMOUNT = exports.MAX_TOKEN_LATENCY = exports.IDEMPOTENT_HTTP_VERBS = exports.HTTP_VERBS = exports.LIVETHREAD_PERMISSIONS = exports.MODERATOR_PERMISSIONS = exports.USERNAME_REGEX = exports.KINDS = exports.SUBREDDIT_KEYS = exports.USER_KEYS = exports.API_RULES_LINK = exports.DOCS_LINK = exports.VERSION = exports.MODULE_NAME = void 0;\nvar MODULE_NAME = 'snoowrap';\nexports.MODULE_NAME = MODULE_NAME;\nvar VERSION = '1.23.0';\nexports.VERSION = VERSION;\nvar DOCS_LINK = 'https://not-an-aardvark.github.io/snoowrap/';\nexports.DOCS_LINK = DOCS_LINK;\nvar API_RULES_LINK = 'https://github.com/reddit/reddit/wiki/API';\n/* USER_KEYS and SUBREDDIT_KEYS are keys that are replaced by RedditUser and Subreddit objects when encountered in\n`snoowrap#_populate`. `author`, `approved_by`, `banned_by`, and `subreddit` all appear in fetched Submissions, among other\nplaces. `user` appears in responses from the api/flairlist endpoint, and `sr` appears in responses from the `api/v1/me/karma`\nendpoint. */\n\nexports.API_RULES_LINK = API_RULES_LINK;\nvar USER_KEYS = new Set(['author', 'approved_by', 'banned_by', 'user']);\nexports.USER_KEYS = USER_KEYS;\nvar SUBREDDIT_KEYS = new Set(['subreddit', 'sr']);\nexports.SUBREDDIT_KEYS = SUBREDDIT_KEYS;\nvar KINDS = {\n  t1: 'Comment',\n  t2: 'RedditUser',\n  t3: 'Submission',\n  t4: 'PrivateMessage',\n  t5: 'Subreddit',\n  t6: 'Trophy',\n  t8: 'PromoCampaign',\n  Listing: 'Listing',\n  more: 'More',\n  UserList: 'UserList',\n  KarmaList: 'KarmaList',\n  TrophyList: 'TrophyList',\n  subreddit_settings: 'SubredditSettings',\n  modaction: 'ModAction',\n  wikipage: 'WikiPage',\n  wikipagesettings: 'WikiPageSettings',\n  wikipagelisting: 'WikiPageListing',\n  LiveUpdateEvent: 'LiveThread',\n  LiveUpdate: 'LiveUpdate',\n  LabeledMulti: 'MultiReddit',\n  ModmailConversation: 'ModmailConversation',\n  ModmailConversationAuthor: 'ModmailConversationAuthor'\n};\nexports.KINDS = KINDS;\nvar USERNAME_REGEX = /^[\\w-]{1,20}$/;\nexports.USERNAME_REGEX = USERNAME_REGEX;\nvar MODERATOR_PERMISSIONS = ['wiki', 'posts', 'access', 'mail', 'config', 'flair'];\nexports.MODERATOR_PERMISSIONS = MODERATOR_PERMISSIONS;\nvar LIVETHREAD_PERMISSIONS = ['update', 'edit', 'manage'];\nexports.LIVETHREAD_PERMISSIONS = LIVETHREAD_PERMISSIONS;\nvar HTTP_VERBS = ['delete', 'get', 'head', 'patch', 'post', 'put'];\nexports.HTTP_VERBS = HTTP_VERBS;\nvar IDEMPOTENT_HTTP_VERBS = ['delete', 'get', 'head', 'put'];\nexports.IDEMPOTENT_HTTP_VERBS = IDEMPOTENT_HTTP_VERBS;\nvar MAX_TOKEN_LATENCY = 10000;\nexports.MAX_TOKEN_LATENCY = MAX_TOKEN_LATENCY;\nvar MAX_API_INFO_AMOUNT = 100;\nexports.MAX_API_INFO_AMOUNT = MAX_API_INFO_AMOUNT;\nvar MAX_API_MORECHILDREN_AMOUNT = 20;\nexports.MAX_API_MORECHILDREN_AMOUNT = MAX_API_MORECHILDREN_AMOUNT;\nvar MAX_LISTING_ITEMS = 100;\nexports.MAX_LISTING_ITEMS = MAX_LISTING_ITEMS;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCLEdBQUcsbUNBQW1DLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCLEdBQUcsNkJBQTZCLEdBQUcsa0JBQWtCLEdBQUcsOEJBQThCLEdBQUcsNkJBQTZCLEdBQUcsc0JBQXNCLEdBQUcsYUFBYSxHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxtQkFBbUI7QUFDMVo7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZCQUE2QixLQUFLO0FBQ2xDLHNCQUFzQjtBQUN0QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTUFYX0xJU1RJTkdfSVRFTVMgPSBleHBvcnRzLk1BWF9BUElfTU9SRUNISUxEUkVOX0FNT1VOVCA9IGV4cG9ydHMuTUFYX0FQSV9JTkZPX0FNT1VOVCA9IGV4cG9ydHMuTUFYX1RPS0VOX0xBVEVOQ1kgPSBleHBvcnRzLklERU1QT1RFTlRfSFRUUF9WRVJCUyA9IGV4cG9ydHMuSFRUUF9WRVJCUyA9IGV4cG9ydHMuTElWRVRIUkVBRF9QRVJNSVNTSU9OUyA9IGV4cG9ydHMuTU9ERVJBVE9SX1BFUk1JU1NJT05TID0gZXhwb3J0cy5VU0VSTkFNRV9SRUdFWCA9IGV4cG9ydHMuS0lORFMgPSBleHBvcnRzLlNVQlJFRERJVF9LRVlTID0gZXhwb3J0cy5VU0VSX0tFWVMgPSBleHBvcnRzLkFQSV9SVUxFU19MSU5LID0gZXhwb3J0cy5ET0NTX0xJTksgPSBleHBvcnRzLlZFUlNJT04gPSBleHBvcnRzLk1PRFVMRV9OQU1FID0gdm9pZCAwO1xudmFyIE1PRFVMRV9OQU1FID0gJ3Nub293cmFwJztcbmV4cG9ydHMuTU9EVUxFX05BTUUgPSBNT0RVTEVfTkFNRTtcbnZhciBWRVJTSU9OID0gJzEuMjMuMCc7XG5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xudmFyIERPQ1NfTElOSyA9ICdodHRwczovL25vdC1hbi1hYXJkdmFyay5naXRodWIuaW8vc25vb3dyYXAvJztcbmV4cG9ydHMuRE9DU19MSU5LID0gRE9DU19MSU5LO1xudmFyIEFQSV9SVUxFU19MSU5LID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9yZWRkaXQvcmVkZGl0L3dpa2kvQVBJJztcbi8qIFVTRVJfS0VZUyBhbmQgU1VCUkVERElUX0tFWVMgYXJlIGtleXMgdGhhdCBhcmUgcmVwbGFjZWQgYnkgUmVkZGl0VXNlciBhbmQgU3VicmVkZGl0IG9iamVjdHMgd2hlbiBlbmNvdW50ZXJlZCBpblxuYHNub293cmFwI19wb3B1bGF0ZWAuIGBhdXRob3JgLCBgYXBwcm92ZWRfYnlgLCBgYmFubmVkX2J5YCwgYW5kIGBzdWJyZWRkaXRgIGFsbCBhcHBlYXIgaW4gZmV0Y2hlZCBTdWJtaXNzaW9ucywgYW1vbmcgb3RoZXJcbnBsYWNlcy4gYHVzZXJgIGFwcGVhcnMgaW4gcmVzcG9uc2VzIGZyb20gdGhlIGFwaS9mbGFpcmxpc3QgZW5kcG9pbnQsIGFuZCBgc3JgIGFwcGVhcnMgaW4gcmVzcG9uc2VzIGZyb20gdGhlIGBhcGkvdjEvbWUva2FybWFgXG5lbmRwb2ludC4gKi9cblxuZXhwb3J0cy5BUElfUlVMRVNfTElOSyA9IEFQSV9SVUxFU19MSU5LO1xudmFyIFVTRVJfS0VZUyA9IG5ldyBTZXQoWydhdXRob3InLCAnYXBwcm92ZWRfYnknLCAnYmFubmVkX2J5JywgJ3VzZXInXSk7XG5leHBvcnRzLlVTRVJfS0VZUyA9IFVTRVJfS0VZUztcbnZhciBTVUJSRURESVRfS0VZUyA9IG5ldyBTZXQoWydzdWJyZWRkaXQnLCAnc3InXSk7XG5leHBvcnRzLlNVQlJFRERJVF9LRVlTID0gU1VCUkVERElUX0tFWVM7XG52YXIgS0lORFMgPSB7XG4gIHQxOiAnQ29tbWVudCcsXG4gIHQyOiAnUmVkZGl0VXNlcicsXG4gIHQzOiAnU3VibWlzc2lvbicsXG4gIHQ0OiAnUHJpdmF0ZU1lc3NhZ2UnLFxuICB0NTogJ1N1YnJlZGRpdCcsXG4gIHQ2OiAnVHJvcGh5JyxcbiAgdDg6ICdQcm9tb0NhbXBhaWduJyxcbiAgTGlzdGluZzogJ0xpc3RpbmcnLFxuICBtb3JlOiAnTW9yZScsXG4gIFVzZXJMaXN0OiAnVXNlckxpc3QnLFxuICBLYXJtYUxpc3Q6ICdLYXJtYUxpc3QnLFxuICBUcm9waHlMaXN0OiAnVHJvcGh5TGlzdCcsXG4gIHN1YnJlZGRpdF9zZXR0aW5nczogJ1N1YnJlZGRpdFNldHRpbmdzJyxcbiAgbW9kYWN0aW9uOiAnTW9kQWN0aW9uJyxcbiAgd2lraXBhZ2U6ICdXaWtpUGFnZScsXG4gIHdpa2lwYWdlc2V0dGluZ3M6ICdXaWtpUGFnZVNldHRpbmdzJyxcbiAgd2lraXBhZ2VsaXN0aW5nOiAnV2lraVBhZ2VMaXN0aW5nJyxcbiAgTGl2ZVVwZGF0ZUV2ZW50OiAnTGl2ZVRocmVhZCcsXG4gIExpdmVVcGRhdGU6ICdMaXZlVXBkYXRlJyxcbiAgTGFiZWxlZE11bHRpOiAnTXVsdGlSZWRkaXQnLFxuICBNb2RtYWlsQ29udmVyc2F0aW9uOiAnTW9kbWFpbENvbnZlcnNhdGlvbicsXG4gIE1vZG1haWxDb252ZXJzYXRpb25BdXRob3I6ICdNb2RtYWlsQ29udmVyc2F0aW9uQXV0aG9yJ1xufTtcbmV4cG9ydHMuS0lORFMgPSBLSU5EUztcbnZhciBVU0VSTkFNRV9SRUdFWCA9IC9eW1xcdy1dezEsMjB9JC87XG5leHBvcnRzLlVTRVJOQU1FX1JFR0VYID0gVVNFUk5BTUVfUkVHRVg7XG52YXIgTU9ERVJBVE9SX1BFUk1JU1NJT05TID0gWyd3aWtpJywgJ3Bvc3RzJywgJ2FjY2VzcycsICdtYWlsJywgJ2NvbmZpZycsICdmbGFpciddO1xuZXhwb3J0cy5NT0RFUkFUT1JfUEVSTUlTU0lPTlMgPSBNT0RFUkFUT1JfUEVSTUlTU0lPTlM7XG52YXIgTElWRVRIUkVBRF9QRVJNSVNTSU9OUyA9IFsndXBkYXRlJywgJ2VkaXQnLCAnbWFuYWdlJ107XG5leHBvcnRzLkxJVkVUSFJFQURfUEVSTUlTU0lPTlMgPSBMSVZFVEhSRUFEX1BFUk1JU1NJT05TO1xudmFyIEhUVFBfVkVSQlMgPSBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwYXRjaCcsICdwb3N0JywgJ3B1dCddO1xuZXhwb3J0cy5IVFRQX1ZFUkJTID0gSFRUUF9WRVJCUztcbnZhciBJREVNUE9URU5UX0hUVFBfVkVSQlMgPSBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwdXQnXTtcbmV4cG9ydHMuSURFTVBPVEVOVF9IVFRQX1ZFUkJTID0gSURFTVBPVEVOVF9IVFRQX1ZFUkJTO1xudmFyIE1BWF9UT0tFTl9MQVRFTkNZID0gMTAwMDA7XG5leHBvcnRzLk1BWF9UT0tFTl9MQVRFTkNZID0gTUFYX1RPS0VOX0xBVEVOQ1k7XG52YXIgTUFYX0FQSV9JTkZPX0FNT1VOVCA9IDEwMDtcbmV4cG9ydHMuTUFYX0FQSV9JTkZPX0FNT1VOVCA9IE1BWF9BUElfSU5GT19BTU9VTlQ7XG52YXIgTUFYX0FQSV9NT1JFQ0hJTERSRU5fQU1PVU5UID0gMjA7XG5leHBvcnRzLk1BWF9BUElfTU9SRUNISUxEUkVOX0FNT1VOVCA9IE1BWF9BUElfTU9SRUNISUxEUkVOX0FNT1VOVDtcbnZhciBNQVhfTElTVElOR19JVEVNUyA9IDEwMDtcbmV4cG9ydHMuTUFYX0xJU1RJTkdfSVRFTVMgPSBNQVhfTElTVElOR19JVEVNUzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/create_config.js":
/*!*****************************************************!*\
  !*** ./node_modules/snoowrap/dist/create_config.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = _default;\nexports.consoleLogger = void 0;\n\nvar _helpers = __webpack_require__(/*! ./helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar consoleLogger = Object.freeze({\n  warn() {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // eslint-disable-next-line no-console\n    (_console = console).warn.apply(_console, ['[warning]'].concat(args));\n  },\n\n  info() {\n    var _console2;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    // eslint-disable-next-line no-console\n    (_console2 = console).info.apply(_console2, ['[info]'].concat(args));\n  },\n\n  debug() {\n    var _console3;\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    // eslint-disable-next-line no-console\n    (_console3 = console).debug.apply(_console3, ['[debug]'].concat(args));\n  },\n\n  trace() {\n    var _console4;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    // eslint-disable-next-line no-console\n    (_console4 = console).trace.apply(_console4, ['[trace]'].concat(args));\n  }\n\n});\nexports.consoleLogger = consoleLogger;\n\nfunction _default() {\n  var config = Object.create(null);\n  config.endpointDomain = 'reddit.com';\n  config.requestDelay = 0;\n  config.requestTimeout = 30000;\n  config.continueAfterRatelimitError = false;\n  config.retryErrorCodes = [502, 503, 504, 522];\n  config.maxRetryAttempts = 3;\n  config.warnings = true;\n  config.debug = false;\n  config.logger = consoleLogger;\n  config.proxies = true;\n  return (0, _helpers.addSnakeCaseShadowProps)(config);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9jcmVhdGVfY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YscUJBQXFCOztBQUVyQixlQUFlLG1CQUFPLENBQUMsbUVBQWM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL2Rpc3QvY3JlYXRlX2NvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuZXhwb3J0cy5jb25zb2xlTG9nZ2VyID0gdm9pZCAwO1xuXG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpO1xuXG52YXIgY29uc29sZUxvZ2dlciA9IE9iamVjdC5mcmVlemUoe1xuICB3YXJuKCkge1xuICAgIHZhciBfY29uc29sZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIChfY29uc29sZSA9IGNvbnNvbGUpLndhcm4uYXBwbHkoX2NvbnNvbGUsIFsnW3dhcm5pbmddJ10uY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICBpbmZvKCkge1xuICAgIHZhciBfY29uc29sZTI7XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIChfY29uc29sZTIgPSBjb25zb2xlKS5pbmZvLmFwcGx5KF9jb25zb2xlMiwgWydbaW5mb10nXS5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIGRlYnVnKCkge1xuICAgIHZhciBfY29uc29sZTM7XG5cbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIChfY29uc29sZTMgPSBjb25zb2xlKS5kZWJ1Zy5hcHBseShfY29uc29sZTMsIFsnW2RlYnVnXSddLmNvbmNhdChhcmdzKSk7XG4gIH0sXG5cbiAgdHJhY2UoKSB7XG4gICAgdmFyIF9jb25zb2xlNDtcblxuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgKF9jb25zb2xlNCA9IGNvbnNvbGUpLnRyYWNlLmFwcGx5KF9jb25zb2xlNCwgWydbdHJhY2VdJ10uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG59KTtcbmV4cG9ydHMuY29uc29sZUxvZ2dlciA9IGNvbnNvbGVMb2dnZXI7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICB2YXIgY29uZmlnID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uZmlnLmVuZHBvaW50RG9tYWluID0gJ3JlZGRpdC5jb20nO1xuICBjb25maWcucmVxdWVzdERlbGF5ID0gMDtcbiAgY29uZmlnLnJlcXVlc3RUaW1lb3V0ID0gMzAwMDA7XG4gIGNvbmZpZy5jb250aW51ZUFmdGVyUmF0ZWxpbWl0RXJyb3IgPSBmYWxzZTtcbiAgY29uZmlnLnJldHJ5RXJyb3JDb2RlcyA9IFs1MDIsIDUwMywgNTA0LCA1MjJdO1xuICBjb25maWcubWF4UmV0cnlBdHRlbXB0cyA9IDM7XG4gIGNvbmZpZy53YXJuaW5ncyA9IHRydWU7XG4gIGNvbmZpZy5kZWJ1ZyA9IGZhbHNlO1xuICBjb25maWcubG9nZ2VyID0gY29uc29sZUxvZ2dlcjtcbiAgY29uZmlnLnByb3hpZXMgPSB0cnVlO1xuICByZXR1cm4gKDAsIF9oZWxwZXJzLmFkZFNuYWtlQ2FzZVNoYWRvd1Byb3BzKShjb25maWcpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/create_config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/errors.js":
/*!**********************************************!*\
  !*** ./node_modules/snoowrap/dist/errors.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.rateLimitWarning = rateLimitWarning;\nexports.StatusCodeError = exports.RequestError = exports.InvalidMethodCallError = exports.NoCredentialsError = exports.InvalidUserError = exports.RateLimitError = void 0;\n\nvar _constants = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/snoowrap/dist/constants.js\");\n\n/* eslint-disable max-len */\nclass RateLimitError extends Error {\n  constructor() {\n    super(\"\".concat(_constants.MODULE_NAME, \" refused to continue because reddit's ratelimit was exceeded. For more information about reddit's ratelimit, please consult reddit's API rules at \").concat(_constants.API_RULES_LINK, \".\"));\n  }\n\n}\n\nexports.RateLimitError = RateLimitError;\n\nclass InvalidUserError extends Error {\n  constructor() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cannot fetch information on the given user. Please be sure you have the right username.';\n    super(message);\n  }\n\n}\n\nexports.InvalidUserError = InvalidUserError;\n\nclass NoCredentialsError extends Error {\n  constructor() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Missing credentials passed to \".concat(_constants.MODULE_NAME, \" constructor. You must pass an object containing either (a) userAgent, clientId, clientSecret, and refreshToken properties, (b) userAgent and accessToken properties, or (c) userAgent, clientId, clientSecret, username, and password properties. For information, please read the docs at \").concat(_constants.DOCS_LINK, \".\");\n    super(message);\n  }\n\n}\n\nexports.NoCredentialsError = NoCredentialsError;\n\nclass InvalidMethodCallError extends Error {}\n\nexports.InvalidMethodCallError = InvalidMethodCallError;\n\nclass RequestError extends Error {}\n\nexports.RequestError = RequestError;\n\nclass StatusCodeError extends Error {}\n\nexports.StatusCodeError = StatusCodeError;\n\nfunction rateLimitWarning(millisecondsUntilReset) {\n  return \"Warning: \".concat(_constants.MODULE_NAME, \" temporarily stopped sending requests because reddit's ratelimit was exceeded. The request you attempted to send was queued, and will be sent to reddit when the current ratelimit period expires in \").concat(millisecondsUntilReset / 1000, \" seconds.\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLDhCQUE4QixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLHNCQUFzQjs7QUFFaEssaUJBQWlCLG1CQUFPLENBQUMsdUVBQWdCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQSw4QkFBOEI7O0FBRTlCOztBQUVBLG9CQUFvQjs7QUFFcEI7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJhdGVMaW1pdFdhcm5pbmcgPSByYXRlTGltaXRXYXJuaW5nO1xuZXhwb3J0cy5TdGF0dXNDb2RlRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RFcnJvciA9IGV4cG9ydHMuSW52YWxpZE1ldGhvZENhbGxFcnJvciA9IGV4cG9ydHMuTm9DcmVkZW50aWFsc0Vycm9yID0gZXhwb3J0cy5JbnZhbGlkVXNlckVycm9yID0gZXhwb3J0cy5SYXRlTGltaXRFcnJvciA9IHZvaWQgMDtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbmNsYXNzIFJhdGVMaW1pdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlwiLmNvbmNhdChfY29uc3RhbnRzLk1PRFVMRV9OQU1FLCBcIiByZWZ1c2VkIHRvIGNvbnRpbnVlIGJlY2F1c2UgcmVkZGl0J3MgcmF0ZWxpbWl0IHdhcyBleGNlZWRlZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgcmVkZGl0J3MgcmF0ZWxpbWl0LCBwbGVhc2UgY29uc3VsdCByZWRkaXQncyBBUEkgcnVsZXMgYXQgXCIpLmNvbmNhdChfY29uc3RhbnRzLkFQSV9SVUxFU19MSU5LLCBcIi5cIikpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5SYXRlTGltaXRFcnJvciA9IFJhdGVMaW1pdEVycm9yO1xuXG5jbGFzcyBJbnZhbGlkVXNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ0Nhbm5vdCBmZXRjaCBpbmZvcm1hdGlvbiBvbiB0aGUgZ2l2ZW4gdXNlci4gUGxlYXNlIGJlIHN1cmUgeW91IGhhdmUgdGhlIHJpZ2h0IHVzZXJuYW1lLic7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cblxufVxuXG5leHBvcnRzLkludmFsaWRVc2VyRXJyb3IgPSBJbnZhbGlkVXNlckVycm9yO1xuXG5jbGFzcyBOb0NyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciBtZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIk1pc3NpbmcgY3JlZGVudGlhbHMgcGFzc2VkIHRvIFwiLmNvbmNhdChfY29uc3RhbnRzLk1PRFVMRV9OQU1FLCBcIiBjb25zdHJ1Y3Rvci4gWW91IG11c3QgcGFzcyBhbiBvYmplY3QgY29udGFpbmluZyBlaXRoZXIgKGEpIHVzZXJBZ2VudCwgY2xpZW50SWQsIGNsaWVudFNlY3JldCwgYW5kIHJlZnJlc2hUb2tlbiBwcm9wZXJ0aWVzLCAoYikgdXNlckFnZW50IGFuZCBhY2Nlc3NUb2tlbiBwcm9wZXJ0aWVzLCBvciAoYykgdXNlckFnZW50LCBjbGllbnRJZCwgY2xpZW50U2VjcmV0LCB1c2VybmFtZSwgYW5kIHBhc3N3b3JkIHByb3BlcnRpZXMuIEZvciBpbmZvcm1hdGlvbiwgcGxlYXNlIHJlYWQgdGhlIGRvY3MgYXQgXCIpLmNvbmNhdChfY29uc3RhbnRzLkRPQ1NfTElOSywgXCIuXCIpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5Ob0NyZWRlbnRpYWxzRXJyb3IgPSBOb0NyZWRlbnRpYWxzRXJyb3I7XG5cbmNsYXNzIEludmFsaWRNZXRob2RDYWxsRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnRzLkludmFsaWRNZXRob2RDYWxsRXJyb3IgPSBJbnZhbGlkTWV0aG9kQ2FsbEVycm9yO1xuXG5jbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnRzLlJlcXVlc3RFcnJvciA9IFJlcXVlc3RFcnJvcjtcblxuY2xhc3MgU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0cy5TdGF0dXNDb2RlRXJyb3IgPSBTdGF0dXNDb2RlRXJyb3I7XG5cbmZ1bmN0aW9uIHJhdGVMaW1pdFdhcm5pbmcobWlsbGlzZWNvbmRzVW50aWxSZXNldCkge1xuICByZXR1cm4gXCJXYXJuaW5nOiBcIi5jb25jYXQoX2NvbnN0YW50cy5NT0RVTEVfTkFNRSwgXCIgdGVtcG9yYXJpbHkgc3RvcHBlZCBzZW5kaW5nIHJlcXVlc3RzIGJlY2F1c2UgcmVkZGl0J3MgcmF0ZWxpbWl0IHdhcyBleGNlZWRlZC4gVGhlIHJlcXVlc3QgeW91IGF0dGVtcHRlZCB0byBzZW5kIHdhcyBxdWV1ZWQsIGFuZCB3aWxsIGJlIHNlbnQgdG8gcmVkZGl0IHdoZW4gdGhlIGN1cnJlbnQgcmF0ZWxpbWl0IHBlcmlvZCBleHBpcmVzIGluIFwiKS5jb25jYXQobWlsbGlzZWNvbmRzVW50aWxSZXNldCAvIDEwMDAsIFwiIHNlY29uZHMuXCIpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/helpers.js":
/*!***********************************************!*\
  !*** ./node_modules/snoowrap/dist/helpers.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getEmptyRepliesListing = getEmptyRepliesListing;\nexports.addEmptyRepliesListing = addEmptyRepliesListing;\nexports.handleJsonErrors = handleJsonErrors;\nexports.findMessageInTree = findMessageInTree;\nexports.formatPermissions = formatPermissions;\nexports.renameKey = renameKey;\nexports.buildRepliesTree = buildRepliesTree;\nexports.addFullnamePrefix = addFullnamePrefix;\nexports.hasFullnamePrefix = hasFullnamePrefix;\nexports.addSnakeCaseShadowProps = addSnakeCaseShadowProps;\nexports.defineInspectFunc = defineInspectFunc;\nexports.requiredArg = requiredArg;\nexports.isBrowser = exports.formatLivethreadPermissions = exports.formatModPermissions = void 0;\n\nvar _util = _interopRequireDefault(__webpack_require__(/*! util */ \"util\"));\n\nvar _lodash = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nvar _constants = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/snoowrap/dist/constants.js\");\n\nvar _More = __webpack_require__(/*! ./objects/More.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/More.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n* @summary Returns an unfetched empty replies Listing for an item.\n* @param {Comment|Submission|PrivateMessage} item An item without a replies Listing\n* @returns {Listing} The empty replies Listing\n* @api private\n*/\nfunction getEmptyRepliesListing(item) {\n  if (item.constructor._name === 'Comment') {\n    return item._r._newObject('Listing', {\n      _uri: \"comments/\".concat((item.link_id || item.parent_id).slice(3)),\n      _query: {\n        comment: item.name.slice(3)\n      },\n      _transform: (0, _lodash.property)('comments[0].replies'),\n      _link_id: item.link_id,\n      _isCommentList: true\n    });\n  }\n\n  if (item.constructor._name === 'Submission') {\n    return item._r._newObject('Listing', {\n      _uri: \"comments/\".concat(item.id),\n      _transform: (0, _lodash.property)('comments'),\n      _isCommentList: true\n    });\n  }\n\n  return item._r._newObject('Listing');\n}\n/**\n* @summary Adds an empty replies Listing to an item.\n* @param {Comment|PrivateMessage} item\n* @returns {Comment|PrivateMessage} The item with the new replies Listing\n* @api private\n*/\n\n\nfunction addEmptyRepliesListing(item) {\n  item.replies = getEmptyRepliesListing(item);\n  return item;\n}\n\nfunction handleJsonErrors(returnValue) {\n  return function (response) {\n    if ((0, _lodash.isEmpty)(response) || (0, _lodash.isEmpty)(response.json.errors)) {\n      return returnValue;\n    }\n\n    throw new Error(response.json.errors[0]);\n  };\n}\n/**\n* @summary Performs a depth-first search of a tree of private messages, in order to find a message with a given name.\n* @param {String} desiredName The fullname of the desired message\n* @param {PrivateMessage} rootNode The root message of the tree\n* @returns {PrivateMessage} The PrivateMessage with the given fullname, or undefined if it was not found in the tree.\n* @api private\n*/\n\n\nfunction findMessageInTree(desiredName, rootNode) {\n  return rootNode.name === desiredName ? rootNode : (0, _lodash.find)(rootNode.replies.map((0, _lodash.partial)(findMessageInTree, desiredName)));\n}\n/**\n* @summary Formats permissions into a '+'/'-' string\n* @param {String[]} allPermissionNames All possible permissions in this category\n* @param {String[]} permsArray The permissions that should be enabled\n* @returns {String} The permissions formatted into a '+'/'-' string\n* @api private\n*/\n\n\nfunction formatPermissions(allPermissionNames, permsArray) {\n  return permsArray ? allPermissionNames.map(function (type) {\n    return ((0, _lodash.includes)(permsArray, type) ? '+' : '-') + type;\n  }).join(',') : '+all';\n}\n\nvar formatModPermissions = (0, _lodash.partial)(formatPermissions, _constants.MODERATOR_PERMISSIONS);\nexports.formatModPermissions = formatModPermissions;\nvar formatLivethreadPermissions = (0, _lodash.partial)(formatPermissions, _constants.LIVETHREAD_PERMISSIONS);\n/**\n* @summary Renames a key on an object, omitting the old key\n* @param {Object} obj\n* @param oldKey {String}\n* @param newKey {String}\n* @returns {Object} A version of the object with the key renamed\n* @api private\n*/\n\nexports.formatLivethreadPermissions = formatLivethreadPermissions;\n\nfunction renameKey(obj, oldKey, newKey) {\n  return obj && (0, _lodash.omit)(_objectSpread({}, obj, {\n    [newKey]: obj[oldKey]\n  }), oldKey);\n}\n/**\n* @summary Builds a replies tree from a list of child comments or messages\n* @desc When reddit returns private messages (or comments from the /api/morechildren endpoint), it arranges their in a very\nnonintuitive way (see https://github.com/not-an-aardvark/snoowrap/issues/15 for details). This function rearranges the message\ntree so that replies are threaded properly.\n* @param {Array} childList The list of child comments\n* @returns {Array} The resulting list of child comments, arranged into a tree.\n* @api private\n*/\n\n\nfunction buildRepliesTree(childList) {\n  var childMap = (0, _lodash.keyBy)(childList, 'name');\n  childList.forEach(addEmptyRepliesListing);\n  childList.filter(function (child) {\n    return child.constructor._name === 'Comment';\n  }).forEach(function (child) {\n    return child.replies._more = _More.emptyChildren;\n  });\n  (0, _lodash.remove)(childList, function (child) {\n    return childMap[child.parent_id];\n  }).forEach(function (child) {\n    if (child.constructor._name === 'More') {\n      childMap[child.parent_id].replies._setMore(child);\n\n      child.link_id = childMap[child.parent_id].link_id;\n    } else {\n      childMap[child.parent_id].replies.push(child);\n    }\n  });\n  return childList;\n}\n/**\n* @summary Adds a fullname prefix to an item, if it doesn't have a prefix already. If the item is a RedditContent object, gets\nthe item's fullname.\n* @param {String|RedditContent} item\n* @returns {String}\n* @api private\n*/\n\n\nfunction addFullnamePrefix(item, prefix) {\n  if (typeof item === 'string') {\n    return hasFullnamePrefix(item) ? item : prefix + item;\n  }\n\n  return item.name;\n}\n/**\n* @summary Determines whether a string is a \"fullname\". A \"fullname\" starts with \"t1_\", \"t2_\", ... \"t8_\", or \"LiveUpdateEvent_\".\n* @param {String} item\n* @returns {boolean}\n* @api private\n*/\n\n\nfunction hasFullnamePrefix(item) {\n  return /^(t\\d|LiveUpdateEvent)_/.test(item);\n}\n/**\n* @summary Adds snake_case getters and setters to an object\n* @desc All of snoowrap's functions and object options used to be defined in snake_case. For backwards compatibility,\nsnake_case property names (e.g. for the snoowrap constructor) are still supported. This function adds snake_case getters and\nsetters to a camelCase object, such that accessing and setting the snake_case property also correctly set the camelCase version\nof the property.\n* @param {object} obj The object that should have getters/setters attached\n* @returns The updated version of `obj`\n* @api private\n*/\n\n\nfunction addSnakeCaseShadowProps(obj) {\n  Object.keys(obj).filter(function (key) {\n    return !key.startsWith('_') && key !== (0, _lodash.snakeCase)(key);\n  }).forEach(function (key) {\n    Object.defineProperty(obj, (0, _lodash.snakeCase)(key), {\n      get: function () {\n        return obj[key];\n      },\n      set: function (value) {\n        return obj[key] = value;\n      }\n    });\n  });\n  return obj;\n}\n\nvar isBrowser = typeof self === 'object';\nexports.isBrowser = isBrowser;\n\nfunction defineInspectFunc(obj, inspectFunc) {\n  if (isBrowser) {\n    return;\n  } // Use the util.inspect.custom symbol if available (Node 6.6.0+)\n\n\n  var inspectKey = _util.default.inspect && typeof _util.default.inspect.custom === 'symbol' ? _util.default.inspect.custom : 'inspect';\n  Object.defineProperty(obj, inspectKey, {\n    writable: true,\n    enumerable: false,\n    value: inspectFunc\n  });\n}\n\nfunction requiredArg(argName) {\n  throw new TypeError(\"Missing required argument \".concat(argName));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CLGlCQUFpQixHQUFHLG1DQUFtQyxHQUFHLDRCQUE0Qjs7QUFFdEYsbUNBQW1DLG1CQUFPLENBQUMsa0JBQU07O0FBRWpELGNBQWMsbUJBQU8sQ0FBQyxxREFBUTs7QUFFOUIsaUJBQWlCLG1CQUFPLENBQUMsdUVBQWdCOztBQUV6QyxZQUFZLG1CQUFPLENBQUMsNkVBQW1COztBQUV2Qyx1Q0FBdUMsdUNBQXVDOztBQUU5RSwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsOERBQThELGlFQUFpRSxHQUFHLGtDQUFrQzs7QUFFdlUsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSwrQ0FBK0MsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLHlDQUF5QyxtRkFBbUYsT0FBTzs7QUFFdGYsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNO0FBQ0E7QUFDQSxVQUFVLG1DQUFtQztBQUM3QyxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLGdCQUFnQjtBQUMxQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCLFVBQVUsVUFBVTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFlBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQyxZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEVtcHR5UmVwbGllc0xpc3RpbmcgPSBnZXRFbXB0eVJlcGxpZXNMaXN0aW5nO1xuZXhwb3J0cy5hZGRFbXB0eVJlcGxpZXNMaXN0aW5nID0gYWRkRW1wdHlSZXBsaWVzTGlzdGluZztcbmV4cG9ydHMuaGFuZGxlSnNvbkVycm9ycyA9IGhhbmRsZUpzb25FcnJvcnM7XG5leHBvcnRzLmZpbmRNZXNzYWdlSW5UcmVlID0gZmluZE1lc3NhZ2VJblRyZWU7XG5leHBvcnRzLmZvcm1hdFBlcm1pc3Npb25zID0gZm9ybWF0UGVybWlzc2lvbnM7XG5leHBvcnRzLnJlbmFtZUtleSA9IHJlbmFtZUtleTtcbmV4cG9ydHMuYnVpbGRSZXBsaWVzVHJlZSA9IGJ1aWxkUmVwbGllc1RyZWU7XG5leHBvcnRzLmFkZEZ1bGxuYW1lUHJlZml4ID0gYWRkRnVsbG5hbWVQcmVmaXg7XG5leHBvcnRzLmhhc0Z1bGxuYW1lUHJlZml4ID0gaGFzRnVsbG5hbWVQcmVmaXg7XG5leHBvcnRzLmFkZFNuYWtlQ2FzZVNoYWRvd1Byb3BzID0gYWRkU25ha2VDYXNlU2hhZG93UHJvcHM7XG5leHBvcnRzLmRlZmluZUluc3BlY3RGdW5jID0gZGVmaW5lSW5zcGVjdEZ1bmM7XG5leHBvcnRzLnJlcXVpcmVkQXJnID0gcmVxdWlyZWRBcmc7XG5leHBvcnRzLmlzQnJvd3NlciA9IGV4cG9ydHMuZm9ybWF0TGl2ZXRocmVhZFBlcm1pc3Npb25zID0gZXhwb3J0cy5mb3JtYXRNb2RQZXJtaXNzaW9ucyA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidXRpbFwiKSk7XG5cbnZhciBfbG9kYXNoID0gcmVxdWlyZShcImxvZGFzaFwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbnZhciBfTW9yZSA9IHJlcXVpcmUoXCIuL29iamVjdHMvTW9yZS5qc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4qIEBzdW1tYXJ5IFJldHVybnMgYW4gdW5mZXRjaGVkIGVtcHR5IHJlcGxpZXMgTGlzdGluZyBmb3IgYW4gaXRlbS5cbiogQHBhcmFtIHtDb21tZW50fFN1Ym1pc3Npb258UHJpdmF0ZU1lc3NhZ2V9IGl0ZW0gQW4gaXRlbSB3aXRob3V0IGEgcmVwbGllcyBMaXN0aW5nXG4qIEByZXR1cm5zIHtMaXN0aW5nfSBUaGUgZW1wdHkgcmVwbGllcyBMaXN0aW5nXG4qIEBhcGkgcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIGdldEVtcHR5UmVwbGllc0xpc3RpbmcoaXRlbSkge1xuICBpZiAoaXRlbS5jb25zdHJ1Y3Rvci5fbmFtZSA9PT0gJ0NvbW1lbnQnKSB7XG4gICAgcmV0dXJuIGl0ZW0uX3IuX25ld09iamVjdCgnTGlzdGluZycsIHtcbiAgICAgIF91cmk6IFwiY29tbWVudHMvXCIuY29uY2F0KChpdGVtLmxpbmtfaWQgfHwgaXRlbS5wYXJlbnRfaWQpLnNsaWNlKDMpKSxcbiAgICAgIF9xdWVyeToge1xuICAgICAgICBjb21tZW50OiBpdGVtLm5hbWUuc2xpY2UoMylcbiAgICAgIH0sXG4gICAgICBfdHJhbnNmb3JtOiAoMCwgX2xvZGFzaC5wcm9wZXJ0eSkoJ2NvbW1lbnRzWzBdLnJlcGxpZXMnKSxcbiAgICAgIF9saW5rX2lkOiBpdGVtLmxpbmtfaWQsXG4gICAgICBfaXNDb21tZW50TGlzdDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGl0ZW0uY29uc3RydWN0b3IuX25hbWUgPT09ICdTdWJtaXNzaW9uJykge1xuICAgIHJldHVybiBpdGVtLl9yLl9uZXdPYmplY3QoJ0xpc3RpbmcnLCB7XG4gICAgICBfdXJpOiBcImNvbW1lbnRzL1wiLmNvbmNhdChpdGVtLmlkKSxcbiAgICAgIF90cmFuc2Zvcm06ICgwLCBfbG9kYXNoLnByb3BlcnR5KSgnY29tbWVudHMnKSxcbiAgICAgIF9pc0NvbW1lbnRMaXN0OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaXRlbS5fci5fbmV3T2JqZWN0KCdMaXN0aW5nJyk7XG59XG4vKipcbiogQHN1bW1hcnkgQWRkcyBhbiBlbXB0eSByZXBsaWVzIExpc3RpbmcgdG8gYW4gaXRlbS5cbiogQHBhcmFtIHtDb21tZW50fFByaXZhdGVNZXNzYWdlfSBpdGVtXG4qIEByZXR1cm5zIHtDb21tZW50fFByaXZhdGVNZXNzYWdlfSBUaGUgaXRlbSB3aXRoIHRoZSBuZXcgcmVwbGllcyBMaXN0aW5nXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuXG5mdW5jdGlvbiBhZGRFbXB0eVJlcGxpZXNMaXN0aW5nKGl0ZW0pIHtcbiAgaXRlbS5yZXBsaWVzID0gZ2V0RW1wdHlSZXBsaWVzTGlzdGluZyhpdGVtKTtcbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUpzb25FcnJvcnMocmV0dXJuVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIGlmICgoMCwgX2xvZGFzaC5pc0VtcHR5KShyZXNwb25zZSkgfHwgKDAsIF9sb2Rhc2guaXNFbXB0eSkocmVzcG9uc2UuanNvbi5lcnJvcnMpKSB7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmpzb24uZXJyb3JzWzBdKTtcbiAgfTtcbn1cbi8qKlxuKiBAc3VtbWFyeSBQZXJmb3JtcyBhIGRlcHRoLWZpcnN0IHNlYXJjaCBvZiBhIHRyZWUgb2YgcHJpdmF0ZSBtZXNzYWdlcywgaW4gb3JkZXIgdG8gZmluZCBhIG1lc3NhZ2Ugd2l0aCBhIGdpdmVuIG5hbWUuXG4qIEBwYXJhbSB7U3RyaW5nfSBkZXNpcmVkTmFtZSBUaGUgZnVsbG5hbWUgb2YgdGhlIGRlc2lyZWQgbWVzc2FnZVxuKiBAcGFyYW0ge1ByaXZhdGVNZXNzYWdlfSByb290Tm9kZSBUaGUgcm9vdCBtZXNzYWdlIG9mIHRoZSB0cmVlXG4qIEByZXR1cm5zIHtQcml2YXRlTWVzc2FnZX0gVGhlIFByaXZhdGVNZXNzYWdlIHdpdGggdGhlIGdpdmVuIGZ1bGxuYW1lLCBvciB1bmRlZmluZWQgaWYgaXQgd2FzIG5vdCBmb3VuZCBpbiB0aGUgdHJlZS5cbiogQGFwaSBwcml2YXRlXG4qL1xuXG5cbmZ1bmN0aW9uIGZpbmRNZXNzYWdlSW5UcmVlKGRlc2lyZWROYW1lLCByb290Tm9kZSkge1xuICByZXR1cm4gcm9vdE5vZGUubmFtZSA9PT0gZGVzaXJlZE5hbWUgPyByb290Tm9kZSA6ICgwLCBfbG9kYXNoLmZpbmQpKHJvb3ROb2RlLnJlcGxpZXMubWFwKCgwLCBfbG9kYXNoLnBhcnRpYWwpKGZpbmRNZXNzYWdlSW5UcmVlLCBkZXNpcmVkTmFtZSkpKTtcbn1cbi8qKlxuKiBAc3VtbWFyeSBGb3JtYXRzIHBlcm1pc3Npb25zIGludG8gYSAnKycvJy0nIHN0cmluZ1xuKiBAcGFyYW0ge1N0cmluZ1tdfSBhbGxQZXJtaXNzaW9uTmFtZXMgQWxsIHBvc3NpYmxlIHBlcm1pc3Npb25zIGluIHRoaXMgY2F0ZWdvcnlcbiogQHBhcmFtIHtTdHJpbmdbXX0gcGVybXNBcnJheSBUaGUgcGVybWlzc2lvbnMgdGhhdCBzaG91bGQgYmUgZW5hYmxlZFxuKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcGVybWlzc2lvbnMgZm9ybWF0dGVkIGludG8gYSAnKycvJy0nIHN0cmluZ1xuKiBAYXBpIHByaXZhdGVcbiovXG5cblxuZnVuY3Rpb24gZm9ybWF0UGVybWlzc2lvbnMoYWxsUGVybWlzc2lvbk5hbWVzLCBwZXJtc0FycmF5KSB7XG4gIHJldHVybiBwZXJtc0FycmF5ID8gYWxsUGVybWlzc2lvbk5hbWVzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiAoKDAsIF9sb2Rhc2guaW5jbHVkZXMpKHBlcm1zQXJyYXksIHR5cGUpID8gJysnIDogJy0nKSArIHR5cGU7XG4gIH0pLmpvaW4oJywnKSA6ICcrYWxsJztcbn1cblxudmFyIGZvcm1hdE1vZFBlcm1pc3Npb25zID0gKDAsIF9sb2Rhc2gucGFydGlhbCkoZm9ybWF0UGVybWlzc2lvbnMsIF9jb25zdGFudHMuTU9ERVJBVE9SX1BFUk1JU1NJT05TKTtcbmV4cG9ydHMuZm9ybWF0TW9kUGVybWlzc2lvbnMgPSBmb3JtYXRNb2RQZXJtaXNzaW9ucztcbnZhciBmb3JtYXRMaXZldGhyZWFkUGVybWlzc2lvbnMgPSAoMCwgX2xvZGFzaC5wYXJ0aWFsKShmb3JtYXRQZXJtaXNzaW9ucywgX2NvbnN0YW50cy5MSVZFVEhSRUFEX1BFUk1JU1NJT05TKTtcbi8qKlxuKiBAc3VtbWFyeSBSZW5hbWVzIGEga2V5IG9uIGFuIG9iamVjdCwgb21pdHRpbmcgdGhlIG9sZCBrZXlcbiogQHBhcmFtIHtPYmplY3R9IG9ialxuKiBAcGFyYW0gb2xkS2V5IHtTdHJpbmd9XG4qIEBwYXJhbSBuZXdLZXkge1N0cmluZ31cbiogQHJldHVybnMge09iamVjdH0gQSB2ZXJzaW9uIG9mIHRoZSBvYmplY3Qgd2l0aCB0aGUga2V5IHJlbmFtZWRcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5leHBvcnRzLmZvcm1hdExpdmV0aHJlYWRQZXJtaXNzaW9ucyA9IGZvcm1hdExpdmV0aHJlYWRQZXJtaXNzaW9ucztcblxuZnVuY3Rpb24gcmVuYW1lS2V5KG9iaiwgb2xkS2V5LCBuZXdLZXkpIHtcbiAgcmV0dXJuIG9iaiAmJiAoMCwgX2xvZGFzaC5vbWl0KShfb2JqZWN0U3ByZWFkKHt9LCBvYmosIHtcbiAgICBbbmV3S2V5XTogb2JqW29sZEtleV1cbiAgfSksIG9sZEtleSk7XG59XG4vKipcbiogQHN1bW1hcnkgQnVpbGRzIGEgcmVwbGllcyB0cmVlIGZyb20gYSBsaXN0IG9mIGNoaWxkIGNvbW1lbnRzIG9yIG1lc3NhZ2VzXG4qIEBkZXNjIFdoZW4gcmVkZGl0IHJldHVybnMgcHJpdmF0ZSBtZXNzYWdlcyAob3IgY29tbWVudHMgZnJvbSB0aGUgL2FwaS9tb3JlY2hpbGRyZW4gZW5kcG9pbnQpLCBpdCBhcnJhbmdlcyB0aGVpciBpbiBhIHZlcnlcbm5vbmludHVpdGl2ZSB3YXkgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm90LWFuLWFhcmR2YXJrL3Nub293cmFwL2lzc3Vlcy8xNSBmb3IgZGV0YWlscykuIFRoaXMgZnVuY3Rpb24gcmVhcnJhbmdlcyB0aGUgbWVzc2FnZVxudHJlZSBzbyB0aGF0IHJlcGxpZXMgYXJlIHRocmVhZGVkIHByb3Blcmx5LlxuKiBAcGFyYW0ge0FycmF5fSBjaGlsZExpc3QgVGhlIGxpc3Qgb2YgY2hpbGQgY29tbWVudHNcbiogQHJldHVybnMge0FycmF5fSBUaGUgcmVzdWx0aW5nIGxpc3Qgb2YgY2hpbGQgY29tbWVudHMsIGFycmFuZ2VkIGludG8gYSB0cmVlLlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblxuZnVuY3Rpb24gYnVpbGRSZXBsaWVzVHJlZShjaGlsZExpc3QpIHtcbiAgdmFyIGNoaWxkTWFwID0gKDAsIF9sb2Rhc2gua2V5QnkpKGNoaWxkTGlzdCwgJ25hbWUnKTtcbiAgY2hpbGRMaXN0LmZvckVhY2goYWRkRW1wdHlSZXBsaWVzTGlzdGluZyk7XG4gIGNoaWxkTGlzdC5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLmNvbnN0cnVjdG9yLl9uYW1lID09PSAnQ29tbWVudCc7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLnJlcGxpZXMuX21vcmUgPSBfTW9yZS5lbXB0eUNoaWxkcmVuO1xuICB9KTtcbiAgKDAsIF9sb2Rhc2gucmVtb3ZlKShjaGlsZExpc3QsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZE1hcFtjaGlsZC5wYXJlbnRfaWRdO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5jb25zdHJ1Y3Rvci5fbmFtZSA9PT0gJ01vcmUnKSB7XG4gICAgICBjaGlsZE1hcFtjaGlsZC5wYXJlbnRfaWRdLnJlcGxpZXMuX3NldE1vcmUoY2hpbGQpO1xuXG4gICAgICBjaGlsZC5saW5rX2lkID0gY2hpbGRNYXBbY2hpbGQucGFyZW50X2lkXS5saW5rX2lkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZE1hcFtjaGlsZC5wYXJlbnRfaWRdLnJlcGxpZXMucHVzaChjaGlsZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNoaWxkTGlzdDtcbn1cbi8qKlxuKiBAc3VtbWFyeSBBZGRzIGEgZnVsbG5hbWUgcHJlZml4IHRvIGFuIGl0ZW0sIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIHByZWZpeCBhbHJlYWR5LiBJZiB0aGUgaXRlbSBpcyBhIFJlZGRpdENvbnRlbnQgb2JqZWN0LCBnZXRzXG50aGUgaXRlbSdzIGZ1bGxuYW1lLlxuKiBAcGFyYW0ge1N0cmluZ3xSZWRkaXRDb250ZW50fSBpdGVtXG4qIEByZXR1cm5zIHtTdHJpbmd9XG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuXG5mdW5jdGlvbiBhZGRGdWxsbmFtZVByZWZpeChpdGVtLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBoYXNGdWxsbmFtZVByZWZpeChpdGVtKSA/IGl0ZW0gOiBwcmVmaXggKyBpdGVtO1xuICB9XG5cbiAgcmV0dXJuIGl0ZW0ubmFtZTtcbn1cbi8qKlxuKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgaXMgYSBcImZ1bGxuYW1lXCIuIEEgXCJmdWxsbmFtZVwiIHN0YXJ0cyB3aXRoIFwidDFfXCIsIFwidDJfXCIsIC4uLiBcInQ4X1wiLCBvciBcIkxpdmVVcGRhdGVFdmVudF9cIi5cbiogQHBhcmFtIHtTdHJpbmd9IGl0ZW1cbiogQHJldHVybnMge2Jvb2xlYW59XG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuXG5mdW5jdGlvbiBoYXNGdWxsbmFtZVByZWZpeChpdGVtKSB7XG4gIHJldHVybiAvXih0XFxkfExpdmVVcGRhdGVFdmVudClfLy50ZXN0KGl0ZW0pO1xufVxuLyoqXG4qIEBzdW1tYXJ5IEFkZHMgc25ha2VfY2FzZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRvIGFuIG9iamVjdFxuKiBAZGVzYyBBbGwgb2Ygc25vb3dyYXAncyBmdW5jdGlvbnMgYW5kIG9iamVjdCBvcHRpb25zIHVzZWQgdG8gYmUgZGVmaW5lZCBpbiBzbmFrZV9jYXNlLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksXG5zbmFrZV9jYXNlIHByb3BlcnR5IG5hbWVzIChlLmcuIGZvciB0aGUgc25vb3dyYXAgY29uc3RydWN0b3IpIGFyZSBzdGlsbCBzdXBwb3J0ZWQuIFRoaXMgZnVuY3Rpb24gYWRkcyBzbmFrZV9jYXNlIGdldHRlcnMgYW5kXG5zZXR0ZXJzIHRvIGEgY2FtZWxDYXNlIG9iamVjdCwgc3VjaCB0aGF0IGFjY2Vzc2luZyBhbmQgc2V0dGluZyB0aGUgc25ha2VfY2FzZSBwcm9wZXJ0eSBhbHNvIGNvcnJlY3RseSBzZXQgdGhlIGNhbWVsQ2FzZSB2ZXJzaW9uXG5vZiB0aGUgcHJvcGVydHkuXG4qIEBwYXJhbSB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHNob3VsZCBoYXZlIGdldHRlcnMvc2V0dGVycyBhdHRhY2hlZFxuKiBAcmV0dXJucyBUaGUgdXBkYXRlZCB2ZXJzaW9uIG9mIGBvYmpgXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuXG5mdW5jdGlvbiBhZGRTbmFrZUNhc2VTaGFkb3dQcm9wcyhvYmopIHtcbiAgT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAha2V5LnN0YXJ0c1dpdGgoJ18nKSAmJiBrZXkgIT09ICgwLCBfbG9kYXNoLnNuYWtlQ2FzZSkoa2V5KTtcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgKDAsIF9sb2Rhc2guc25ha2VDYXNlKShrZXkpLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyO1xuXG5mdW5jdGlvbiBkZWZpbmVJbnNwZWN0RnVuYyhvYmosIGluc3BlY3RGdW5jKSB7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVXNlIHRoZSB1dGlsLmluc3BlY3QuY3VzdG9tIHN5bWJvbCBpZiBhdmFpbGFibGUgKE5vZGUgNi42LjArKVxuXG5cbiAgdmFyIGluc3BlY3RLZXkgPSBfdXRpbC5kZWZhdWx0Lmluc3BlY3QgJiYgdHlwZW9mIF91dGlsLmRlZmF1bHQuaW5zcGVjdC5jdXN0b20gPT09ICdzeW1ib2wnID8gX3V0aWwuZGVmYXVsdC5pbnNwZWN0LmN1c3RvbSA6ICdpbnNwZWN0JztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgaW5zcGVjdEtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBpbnNwZWN0RnVuY1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZWRBcmcoYXJnTmFtZSkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBcIi5jb25jYXQoYXJnTmFtZSkpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/Comment.js":
/*!*******************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/Comment.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _Listing = _interopRequireDefault(__webpack_require__(/*! ./Listing.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/Listing.js\"));\n\nvar _More = __webpack_require__(/*! ./More.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/More.js\");\n\nvar _VoteableContent = _interopRequireDefault(__webpack_require__(/*! ./VoteableContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/VoteableContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* A class representing a reddit comment\n* <style> #Comment {display: none} </style>\n* @example\n*\n* // Get a comment with the given ID\n* r.getComment('c0hkuyq')\n*\n* @extends VoteableContent\n*/\nvar Comment = class Comment extends _VoteableContent.default {\n  constructor(options, _r, _hasFetched) {\n    super(options, _r, _hasFetched);\n\n    if (_hasFetched) {\n      /* If a comment is in a deep comment chain, reddit will send a single `more` object with name `t1__` in place of the\n      comment's replies. This is the equivalent of seeing a 'Continue this thread' link on the HTML site, and it indicates that\n      replies should be fetched by sending another request to view the deep comment alone, and parsing the replies from that. */\n      if (this.replies instanceof _Listing.default && !this.replies.length && this.replies._more && this.replies._more.name === 't1__') {\n        this.replies = (0, _helpers.getEmptyRepliesListing)(this);\n      } else if (this.replies === '') {\n        /* If a comment has no replies, reddit returns an empty string as its `replies` property rather than an empty Listing.\n        This behavior is unexpected, so replace the empty string with an empty Listing. */\n        this.replies = this._r._newObject('Listing', {\n          children: [],\n          _more: _More.emptyChildren,\n          _isCommentList: true\n        });\n      } else if (this.replies._more && !this.replies._more.link_id) {\n        this.replies._more.link_id = this.link_id;\n      }\n    }\n  }\n\n  _transformApiResponse(response) {\n    return (0, _helpers.addEmptyRepliesListing)(response[0]);\n  }\n\n  get _uri() {\n    return \"api/info?id=\".concat(this.name);\n  }\n  /**\n  * @summary Locks this Comment, preventing new comments from being posted on it.\n  * @returns {Promise} The updated version of this Comment\n  * @example r.getComment('d1xclfo').lock()\n  */\n\n\n  lock() {\n    return this._post({\n      uri: 'api/lock',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unlocks this Comment, allowing comments to be posted on it again.\n  * @returns {Promise} The updated version of this Comment\n  * @example r.getComment('d1xclfo').unlock()\n  */\n\n\n  unlock() {\n    return this._post({\n      uri: 'api/unlock',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n\n};\nvar _default = Comment;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL0NvbW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsZUFBZSxtQkFBTyxDQUFDLG9FQUFlOztBQUV0QyxzQ0FBc0MsbUJBQU8sQ0FBQywyRUFBYzs7QUFFNUQsWUFBWSxtQkFBTyxDQUFDLHFFQUFXOztBQUUvQiw4Q0FBOEMsbUJBQU8sQ0FBQywyRkFBc0I7O0FBRTVFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL0NvbW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaGVscGVycyA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzLmpzXCIpO1xuXG52YXIgX0xpc3RpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0xpc3RpbmcuanNcIikpO1xuXG52YXIgX01vcmUgPSByZXF1aXJlKFwiLi9Nb3JlLmpzXCIpO1xuXG52YXIgX1ZvdGVhYmxlQ29udGVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vVm90ZWFibGVDb250ZW50LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4qIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgcmVkZGl0IGNvbW1lbnRcbiogPHN0eWxlPiAjQ29tbWVudCB7ZGlzcGxheTogbm9uZX0gPC9zdHlsZT5cbiogQGV4YW1wbGVcbipcbiogLy8gR2V0IGEgY29tbWVudCB3aXRoIHRoZSBnaXZlbiBJRFxuKiByLmdldENvbW1lbnQoJ2MwaGt1eXEnKVxuKlxuKiBAZXh0ZW5kcyBWb3RlYWJsZUNvbnRlbnRcbiovXG52YXIgQ29tbWVudCA9IGNsYXNzIENvbW1lbnQgZXh0ZW5kcyBfVm90ZWFibGVDb250ZW50LmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBfciwgX2hhc0ZldGNoZWQpIHtcbiAgICBzdXBlcihvcHRpb25zLCBfciwgX2hhc0ZldGNoZWQpO1xuXG4gICAgaWYgKF9oYXNGZXRjaGVkKSB7XG4gICAgICAvKiBJZiBhIGNvbW1lbnQgaXMgaW4gYSBkZWVwIGNvbW1lbnQgY2hhaW4sIHJlZGRpdCB3aWxsIHNlbmQgYSBzaW5nbGUgYG1vcmVgIG9iamVjdCB3aXRoIG5hbWUgYHQxX19gIGluIHBsYWNlIG9mIHRoZVxuICAgICAgY29tbWVudCdzIHJlcGxpZXMuIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2Ygc2VlaW5nIGEgJ0NvbnRpbnVlIHRoaXMgdGhyZWFkJyBsaW5rIG9uIHRoZSBIVE1MIHNpdGUsIGFuZCBpdCBpbmRpY2F0ZXMgdGhhdFxuICAgICAgcmVwbGllcyBzaG91bGQgYmUgZmV0Y2hlZCBieSBzZW5kaW5nIGFub3RoZXIgcmVxdWVzdCB0byB2aWV3IHRoZSBkZWVwIGNvbW1lbnQgYWxvbmUsIGFuZCBwYXJzaW5nIHRoZSByZXBsaWVzIGZyb20gdGhhdC4gKi9cbiAgICAgIGlmICh0aGlzLnJlcGxpZXMgaW5zdGFuY2VvZiBfTGlzdGluZy5kZWZhdWx0ICYmICF0aGlzLnJlcGxpZXMubGVuZ3RoICYmIHRoaXMucmVwbGllcy5fbW9yZSAmJiB0aGlzLnJlcGxpZXMuX21vcmUubmFtZSA9PT0gJ3QxX18nKSB7XG4gICAgICAgIHRoaXMucmVwbGllcyA9ICgwLCBfaGVscGVycy5nZXRFbXB0eVJlcGxpZXNMaXN0aW5nKSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXBsaWVzID09PSAnJykge1xuICAgICAgICAvKiBJZiBhIGNvbW1lbnQgaGFzIG5vIHJlcGxpZXMsIHJlZGRpdCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBhcyBpdHMgYHJlcGxpZXNgIHByb3BlcnR5IHJhdGhlciB0aGFuIGFuIGVtcHR5IExpc3RpbmcuXG4gICAgICAgIFRoaXMgYmVoYXZpb3IgaXMgdW5leHBlY3RlZCwgc28gcmVwbGFjZSB0aGUgZW1wdHkgc3RyaW5nIHdpdGggYW4gZW1wdHkgTGlzdGluZy4gKi9cbiAgICAgICAgdGhpcy5yZXBsaWVzID0gdGhpcy5fci5fbmV3T2JqZWN0KCdMaXN0aW5nJywge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICBfbW9yZTogX01vcmUuZW1wdHlDaGlsZHJlbixcbiAgICAgICAgICBfaXNDb21tZW50TGlzdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXBsaWVzLl9tb3JlICYmICF0aGlzLnJlcGxpZXMuX21vcmUubGlua19pZCkge1xuICAgICAgICB0aGlzLnJlcGxpZXMuX21vcmUubGlua19pZCA9IHRoaXMubGlua19pZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdHJhbnNmb3JtQXBpUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gKDAsIF9oZWxwZXJzLmFkZEVtcHR5UmVwbGllc0xpc3RpbmcpKHJlc3BvbnNlWzBdKTtcbiAgfVxuXG4gIGdldCBfdXJpKCkge1xuICAgIHJldHVybiBcImFwaS9pbmZvP2lkPVwiLmNvbmNhdCh0aGlzLm5hbWUpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IExvY2tzIHRoaXMgQ29tbWVudCwgcHJldmVudGluZyBuZXcgY29tbWVudHMgZnJvbSBiZWluZyBwb3N0ZWQgb24gaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBDb21tZW50XG4gICogQGV4YW1wbGUgci5nZXRDb21tZW50KCdkMXhjbGZvJykubG9jaygpXG4gICovXG5cblxuICBsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9sb2NrJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgaWQ6IHRoaXMubmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBVbmxvY2tzIHRoaXMgQ29tbWVudCwgYWxsb3dpbmcgY29tbWVudHMgdG8gYmUgcG9zdGVkIG9uIGl0IGFnYWluLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgdXBkYXRlZCB2ZXJzaW9uIG9mIHRoaXMgQ29tbWVudFxuICAqIEBleGFtcGxlIHIuZ2V0Q29tbWVudCgnZDF4Y2xmbycpLnVubG9jaygpXG4gICovXG5cblxuICB1bmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3VubG9jaycsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cblxufTtcbnZhciBfZGVmYXVsdCA9IENvbW1lbnQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/Comment.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/Listing.js":
/*!*******************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/Listing.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _lodash = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ../Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _util = _interopRequireDefault(__webpack_require__(/*! util */ \"util\"));\n\nvar _url = __webpack_require__(/*! url */ \"url\");\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _errors = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/snoowrap/dist/errors.js\");\n\nvar _More = _interopRequireWildcard(__webpack_require__(/*! ./More.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/More.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nvar INTERNAL_DEFAULTS = {\n  _query: {},\n  _transform: function (value) {\n    return value;\n  },\n  _method: 'get',\n  _isCommentList: false,\n  _link_id: null,\n  _uri: null,\n  _more: null,\n  _cachedLookahead: null\n};\n/**\n* A class representing a list of content. This is a subclass of the native Array object, so it has all the properties of\nan Array (length, forEach, etc.) in addition to some added methods. The Listing can be extended by using the\n[#fetchMore()]{@link Listing#fetchMore} and\n[#fetchAll()]{@link Listing#fetchAll} functions. Note that these methods return new Listings, rather than mutating the\noriginal Listing.\n*\n* Most methods that return Listings will also accept `limit`, `after`, `before`, `show`, and `count` properties.\n*\n* If you've used the reddit API before (or used other API wrappers like [PRAW](https://praw.readthedocs.org/en/stable/)), you\nmight know that reddit uses a `MoreComments` object in its raw JSON responses, representing comments that have been stubbed\nout of Listings. In snoowrap, there are no exposed `MoreComments` objects; the objects returned by the reddit API are\nstripped from Listings and are used internally as sources for the `fetchMore` functions. This means that in snoowrap, Listings\nthat contain Comments can be used/expanded in the same manner as Listings that don't contain Comments, and for the most part\nyou don't have to worry about the distinction.\n\n(Incidentally, if you encounter a Listing that *does* contain a `MoreComments` object then it's a bug, so please report it.)\n\n* <style> #Listing {display: none} </style>\n* @extends Array\n*/\n\nvar Listing = class Listing extends Array {\n  constructor() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _r = arguments.length > 1 ? arguments[1] : undefined;\n\n    super();\n\n    if (!(this instanceof Listing)) {\n      // Safari 9 has an incorrect implementation of classes that extend Arrays. As a workaround,\n      // manually set the constructor and prototype.\n      this.constructor = Listing;\n      Object.setPrototypeOf(this, Listing.prototype);\n    }\n\n    this.push.apply(this, _toConsumableArray(options.children || []));\n    this._r = _r;\n    this._cachedLookahead = options._cachedLookahead;\n    (0, _lodash.defaultsDeep)(this, (0, _lodash.pick)(options, Object.keys(INTERNAL_DEFAULTS)), INTERNAL_DEFAULTS);\n    Object.assign(this._query, (0, _lodash.pick)(options, ['before', 'after']));\n\n    if (options.children && options.children[options.children.length - 1] instanceof _More.default) {\n      this._setMore(this.pop());\n    }\n  }\n\n  _setUri(value) {\n    var parsedUri = (0, _url.parse)(value, true);\n    this._uri = parsedUri.pathname;\n    (0, _lodash.defaultsDeep)(this._query, parsedUri.query);\n\n    if (parsedUri.query.before) {\n      this._query.after = null;\n    } else {\n      this._query.before = null;\n    }\n  }\n  /**\n  * @summary A getter that indicates whether this Listing has any more items to fetch.\n  * @type {boolean}\n  */\n\n\n  get isFinished() {\n    // The process of checking whether a Listing is 'finished' varies depending on what kind of Listing it is.\n    return this._isCommentList\n    /* For comment Listings (i.e. Listings containing comments and comment replies, sourced by `more` objects): A Listing is\n    *never* finished if it has a cached lookahead (i.e. extra items that were fetched from a previous request). If there is\n    no cached lookahead, a Listing is finished iff it has an empty `more` object. */\n    ? (0, _lodash.isEmpty)(this._cachedLookahead) && !!this._more && (0, _lodash.isEmpty)(this._more.children)\n    /* For non-comment Listings: A Listing is always finished if it has no URI (since there would be nowhere to fetch items\n    from). If it has a URI, a Listing is finished iff its `before` and `after` query are both `null`. This is because reddit\n    returns a value of `null` as the `after` and `before` parameters to signify that a Listing is complete.\n     It is important to check for `null` here rather than any falsey value, because when an empty Listing is initialized, its\n    `after` and `before` properties are both `undefined`, but calling these empty Listings `finished` would be incorrect. */\n    : !this._uri || this._query.after === null && this._query.before === null;\n  }\n\n  get is_finished() {\n    // camel-case alias for backwards-compatibility.\n    // As a getter, the `isFinished` property doesn't have an alias like everything else.\n    return this.isFinished;\n  }\n  /**\n  * @summary Fetches some more items\n  * @param {object} options\n  * @param {number} options.amount The number of items to fetch.\n  * @param {boolean} [options.skipReplies=false] For a Listing that contains comment objects on a Submission, this option can\n  be used to save a few API calls, provided that only top-level comments are being examined. If this is set to `true`, snoowrap\n  is able to fetch 100 Comments per API call rather than 20, but all returned Comments will have no fetched replies by default.\n  *\n  * Internal details: When `skipReplies` is set to `true`, snoowrap uses reddit's `api/info` endpoint to fetch Comments. When\n  `skipReplies` is set to `false`, snoowrap uses reddit's `api/morechildren` endpoint. It's worth noting that reddit does\n  not allow concurrent requests to the `api/morechildren` endpoint by the same account.\n  * @param {boolean} [options.append=true] If `true`, the resulting Listing will contain the existing elements in addition to\n  the newly-fetched elements. If `false`, the resulting Listing will only contain the newly-fetched elements.\n  * @returns {Promise} A new Listing containing the newly-fetched elements. If `options.append` is `true`, the new Listing will\n  also contain all elements that were in the original Listing. Under most circumstances, the newly-fetched elements will appear\n  at the end of the new Listing. However, if reverse pagination is enabled (i.e. if this Listing was created with a `before`\n  query parameter), then the newly-fetched elements will appear at the beginning. In any case, continuity is maintained, i.e.\n  the order of items in the Listing will be the same as the order in which they appear on reddit.\n  * @example\n  * r.getHot({limit: 25}).then(myListing => {\n  *   console.log(myListing.length); // => 25\n  *   myListing.fetchMore({amount: 10}).then(extendedListing => {\n  *     console.log(extendedListing.length); // => 35\n  *   })\n  * });\n  */\n\n\n  fetchMore(options) {\n    var parsedOptions = (0, _lodash.defaults)(typeof options === 'number' ? {\n      amount: options\n    } : (0, _lodash.clone)(options), // Accept either `skip_replies` or `skipReplies` for backwards compatibility.\n    {\n      append: true,\n      skipReplies: options.skip_replies\n    });\n\n    if (typeof parsedOptions.amount !== 'number' || Number.isNaN(parsedOptions.amount)) {\n      throw new _errors.InvalidMethodCallError('Failed to fetch Listing. (`amount` parameter was missing or invalid)');\n    }\n\n    if (parsedOptions.amount <= 0 || this.isFinished) {\n      return this._r._promiseWrap(_Promise.default.resolve(parsedOptions.append ? this._clone() : this._clone()._empty()));\n    }\n\n    if (this._cachedLookahead) {\n      var cloned = this._clone();\n\n      cloned.push.apply(cloned, _toConsumableArray(cloned._cachedLookahead.splice(0, parsedOptions.amount)));\n      return cloned.fetchMore(parsedOptions.amount - cloned.length + this.length);\n    }\n\n    return this._r._promiseWrap(this._more ? this._fetchMoreComments(parsedOptions) : this._fetchMoreRegular(parsedOptions));\n  }\n\n  _fetchMoreRegular(options) {\n    var _this = this;\n\n    var query = (0, _lodash.omitBy)((0, _lodash.clone)(this._query), function (value) {\n      return value === null || value === undefined;\n    });\n\n    if (!this._isCommentList) {\n      /* Reddit returns a different number of items per request depending on the `limit` querystring property specified in the\n      request. If no `limit` property is specified, reddit returns some number of items depending on the user's preferences\n      (currently 25 items with default preferences). If a `limit` property is specified, then reddit returns `limit` items per\n      batch. However, this is capped at 100, so if a `limit` larger than 100 items is specified, reddit will only return 100\n      items in the batch. (The cap of 100 could plausibly change to a different amount in the future.)\n       However, one caveat is that reddit's parser doesn't understand the javascript `Infinity` global. If `limit=Infinity` is\n      provided in the querystring, reddit won't understand the parameter so it'll just act as if no parameter was provided, and\n      will return 25 items in the batch. This is suboptimal behavior as far as snoowrap is concerned, because it means that 4\n      times as many requests are needed to fetch the entire listing.\n       To get around the issue, snoowrap caps the `limit` property at Number.MAX_SAFE_INTEGER when sending requests. This ensures\n      that `Infinity` will never be sent as part of the querystring, so reddit will always return the maximal 100 items per\n      request if the desired amount of items is large. */\n      query.limit = Math.min(options.amount, Number.MAX_SAFE_INTEGER);\n    }\n\n    return this._r.oauthRequest({\n      uri: this._uri,\n      qs: query,\n      method: this._method\n    }).then(this._transform).then(function (response) {\n      var cloned = _this._clone();\n\n      if (!options.append) {\n        cloned._empty();\n      }\n\n      if (cloned._query.before) {\n        cloned.unshift.apply(cloned, _toConsumableArray(response));\n        cloned._query.before = response._query.before;\n        cloned._query.after = null;\n      } else {\n        cloned.push.apply(cloned, _toConsumableArray(response));\n        cloned._query.before = null;\n        cloned._query.after = response._query.after;\n      }\n\n      if (_this._isCommentList) {\n        cloned._more = cloned._more || response._more || _More.emptyChildren;\n\n        if (response.length > options.amount) {\n          cloned._cachedLookahead = Array.from(cloned.splice(options.amount));\n        }\n      }\n\n      return cloned.fetchMore(_objectSpread({}, options, {\n        append: true,\n        amount: options.amount - response.length\n      }));\n    });\n  }\n  /* Pagination for comments works differently than it does for most other things; rather than sending a link to the next page\n  within a Listing, reddit sends the last comment in the list as as a `more` object, with links to all the remaining comments\n  in the thread. */\n\n\n  _fetchMoreComments(options) {\n    var _this2 = this;\n\n    return this._more.fetchMore(options).then(function (moreComments) {\n      var cloned = _this2._clone();\n\n      if (!options.append) {\n        cloned._empty();\n      }\n\n      cloned.push.apply(cloned, _toConsumableArray(moreComments));\n      cloned._more.children = cloned._more.children.slice(options.amount);\n      return cloned;\n    });\n  }\n  /**\n  * @summary Fetches all of the items in this Listing, only stopping when there are none left.\n  * @param {object} [options] Fetching options -- see {@link Listing#fetchMore}\n  * @returns {Promise} A new fully-fetched Listing. Keep in mind that this method has the potential to exhaust your\n  ratelimit quickly if the Listing doesn't have a clear end (e.g. with posts on the front page), so use it with discretion.\n  * @example\n  *\n  * r.getMe().getUpvotedContent().fetchAll().then(console.log)\n  * // => Listing [ Submission { ... }, Submission { ... }, ... ]\n  */\n\n\n  fetchAll(options) {\n    return this.fetchMore(_objectSpread({}, options, {\n      amount: Infinity\n    }));\n  }\n\n  fetchUntil(options) {\n    this._r._warn('Listing#fetchUntil is deprecated -- use Listing#fetchMore instead.');\n\n    return this.fetchMore(_objectSpread({}, options, {\n      append: true,\n      amount: options.length - this.length\n    }));\n  }\n\n  _clone() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$deep = _ref.deep,\n        deep = _ref$deep === void 0 ? false : _ref$deep;\n\n    var properties = (0, _lodash.pick)(this, Object.keys(INTERNAL_DEFAULTS));\n    properties._query = (0, _lodash.clone)(properties._query);\n    properties._cachedLookahead = (0, _lodash.clone)(properties._cachedLookahead);\n    properties._more = this._more && this._more._clone();\n    var shallowChildren = Array.from(this);\n    properties.children = deep ? shallowChildren.map(function (item) {\n      return '_clone' in item && typeof item._clone === 'function' ? item._clone({\n        deep\n      }) : item;\n    }) : shallowChildren;\n    return new Listing(properties, this._r);\n  }\n\n  _setMore(moreObj) {\n    this._more = moreObj;\n    this._isCommentList = true;\n  }\n\n  _empty() {\n    this.splice(0, this.length);\n    return this;\n  }\n\n  toJSON() {\n    return Array.from(this).map(function (item) {\n      return item && item.toJSON ? item.toJSON() : item;\n    });\n  }\n\n};\n(0, _helpers.defineInspectFunc)(Listing.prototype, function () {\n  return \"Listing \".concat(_util.default.inspect(Array.from(this)));\n});\nvar _default = Listing;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL0xpc3RpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsY0FBYyxtQkFBTyxDQUFDLHFEQUFROztBQUU5QixzQ0FBc0MsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFN0QsbUNBQW1DLG1CQUFPLENBQUMsa0JBQU07O0FBRWpELFdBQVcsbUJBQU8sQ0FBQyxnQkFBSzs7QUFFeEIsZUFBZSxtQkFBTyxDQUFDLG9FQUFlOztBQUV0QyxjQUFjLG1CQUFPLENBQUMsa0VBQWM7O0FBRXBDLG9DQUFvQyxtQkFBTyxDQUFDLHFFQUFXOztBQUV2RCx3Q0FBd0MsNkJBQTZCLGNBQWMsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1QixzREFBc0Qsc0hBQXNILDRCQUE0Qiw0Q0FBNEMsT0FBTyxnQ0FBZ0Msc0JBQXNCOztBQUV0Yyx1Q0FBdUMsdUNBQXVDOztBQUU5RSwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsOERBQThELGlFQUFpRSxHQUFHLGtDQUFrQzs7QUFFdlUsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSwrQ0FBK0MsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLHlDQUF5QyxtRkFBbUYsT0FBTzs7QUFFdGYsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNLG1DQUFtQzs7QUFFbkMsZ0NBQWdDOztBQUVoQyxrQ0FBa0M7O0FBRWxDLG1DQUFtQywwQkFBMEIsOENBQThDLGdCQUFnQixPQUFPLG9CQUFvQjs7QUFFdEo7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIscUNBQXFDO0FBQ3JDLDJCQUEyQixXQUFXO0FBQ3RDLDZDQUE2QztBQUM3QyxPQUFPO0FBQ1AsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxtQ0FBbUM7QUFDdkQsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUssZUFBZSxLQUFLO0FBQzFEOzs7QUFHQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL0xpc3RpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfbG9kYXNoID0gcmVxdWlyZShcImxvZGFzaFwiKTtcblxudmFyIF9Qcm9taXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vUHJvbWlzZS5qc1wiKSk7XG5cbnZhciBfdXRpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInV0aWxcIikpO1xuXG52YXIgX3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5cbnZhciBfaGVscGVycyA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzLmpzXCIpO1xuXG52YXIgX2Vycm9ycyA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIik7XG5cbnZhciBfTW9yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL01vcmUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSB9XG5cbnZhciBJTlRFUk5BTF9ERUZBVUxUUyA9IHtcbiAgX3F1ZXJ5OiB7fSxcbiAgX3RyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBfbWV0aG9kOiAnZ2V0JyxcbiAgX2lzQ29tbWVudExpc3Q6IGZhbHNlLFxuICBfbGlua19pZDogbnVsbCxcbiAgX3VyaTogbnVsbCxcbiAgX21vcmU6IG51bGwsXG4gIF9jYWNoZWRMb29rYWhlYWQ6IG51bGxcbn07XG4vKipcbiogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBsaXN0IG9mIGNvbnRlbnQuIFRoaXMgaXMgYSBzdWJjbGFzcyBvZiB0aGUgbmF0aXZlIEFycmF5IG9iamVjdCwgc28gaXQgaGFzIGFsbCB0aGUgcHJvcGVydGllcyBvZlxuYW4gQXJyYXkgKGxlbmd0aCwgZm9yRWFjaCwgZXRjLikgaW4gYWRkaXRpb24gdG8gc29tZSBhZGRlZCBtZXRob2RzLiBUaGUgTGlzdGluZyBjYW4gYmUgZXh0ZW5kZWQgYnkgdXNpbmcgdGhlXG5bI2ZldGNoTW9yZSgpXXtAbGluayBMaXN0aW5nI2ZldGNoTW9yZX0gYW5kXG5bI2ZldGNoQWxsKClde0BsaW5rIExpc3RpbmcjZmV0Y2hBbGx9IGZ1bmN0aW9ucy4gTm90ZSB0aGF0IHRoZXNlIG1ldGhvZHMgcmV0dXJuIG5ldyBMaXN0aW5ncywgcmF0aGVyIHRoYW4gbXV0YXRpbmcgdGhlXG5vcmlnaW5hbCBMaXN0aW5nLlxuKlxuKiBNb3N0IG1ldGhvZHMgdGhhdCByZXR1cm4gTGlzdGluZ3Mgd2lsbCBhbHNvIGFjY2VwdCBgbGltaXRgLCBgYWZ0ZXJgLCBgYmVmb3JlYCwgYHNob3dgLCBhbmQgYGNvdW50YCBwcm9wZXJ0aWVzLlxuKlxuKiBJZiB5b3UndmUgdXNlZCB0aGUgcmVkZGl0IEFQSSBiZWZvcmUgKG9yIHVzZWQgb3RoZXIgQVBJIHdyYXBwZXJzIGxpa2UgW1BSQVddKGh0dHBzOi8vcHJhdy5yZWFkdGhlZG9jcy5vcmcvZW4vc3RhYmxlLykpLCB5b3Vcbm1pZ2h0IGtub3cgdGhhdCByZWRkaXQgdXNlcyBhIGBNb3JlQ29tbWVudHNgIG9iamVjdCBpbiBpdHMgcmF3IEpTT04gcmVzcG9uc2VzLCByZXByZXNlbnRpbmcgY29tbWVudHMgdGhhdCBoYXZlIGJlZW4gc3R1YmJlZFxub3V0IG9mIExpc3RpbmdzLiBJbiBzbm9vd3JhcCwgdGhlcmUgYXJlIG5vIGV4cG9zZWQgYE1vcmVDb21tZW50c2Agb2JqZWN0czsgdGhlIG9iamVjdHMgcmV0dXJuZWQgYnkgdGhlIHJlZGRpdCBBUEkgYXJlXG5zdHJpcHBlZCBmcm9tIExpc3RpbmdzIGFuZCBhcmUgdXNlZCBpbnRlcm5hbGx5IGFzIHNvdXJjZXMgZm9yIHRoZSBgZmV0Y2hNb3JlYCBmdW5jdGlvbnMuIFRoaXMgbWVhbnMgdGhhdCBpbiBzbm9vd3JhcCwgTGlzdGluZ3NcbnRoYXQgY29udGFpbiBDb21tZW50cyBjYW4gYmUgdXNlZC9leHBhbmRlZCBpbiB0aGUgc2FtZSBtYW5uZXIgYXMgTGlzdGluZ3MgdGhhdCBkb24ndCBjb250YWluIENvbW1lbnRzLCBhbmQgZm9yIHRoZSBtb3N0IHBhcnRcbnlvdSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRoZSBkaXN0aW5jdGlvbi5cblxuKEluY2lkZW50YWxseSwgaWYgeW91IGVuY291bnRlciBhIExpc3RpbmcgdGhhdCAqZG9lcyogY29udGFpbiBhIGBNb3JlQ29tbWVudHNgIG9iamVjdCB0aGVuIGl0J3MgYSBidWcsIHNvIHBsZWFzZSByZXBvcnQgaXQuKVxuXG4qIDxzdHlsZT4gI0xpc3Rpbmcge2Rpc3BsYXk6IG5vbmV9IDwvc3R5bGU+XG4qIEBleHRlbmRzIEFycmF5XG4qL1xuXG52YXIgTGlzdGluZyA9IGNsYXNzIExpc3RpbmcgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIHZhciBfciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaXN0aW5nKSkge1xuICAgICAgLy8gU2FmYXJpIDkgaGFzIGFuIGluY29ycmVjdCBpbXBsZW1lbnRhdGlvbiBvZiBjbGFzc2VzIHRoYXQgZXh0ZW5kIEFycmF5cy4gQXMgYSB3b3JrYXJvdW5kLFxuICAgICAgLy8gbWFudWFsbHkgc2V0IHRoZSBjb25zdHJ1Y3RvciBhbmQgcHJvdG90eXBlLlxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IExpc3Rpbmc7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTGlzdGluZy5wcm90b3R5cGUpO1xuICAgIH1cblxuICAgIHRoaXMucHVzaC5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkob3B0aW9ucy5jaGlsZHJlbiB8fCBbXSkpO1xuICAgIHRoaXMuX3IgPSBfcjtcbiAgICB0aGlzLl9jYWNoZWRMb29rYWhlYWQgPSBvcHRpb25zLl9jYWNoZWRMb29rYWhlYWQ7XG4gICAgKDAsIF9sb2Rhc2guZGVmYXVsdHNEZWVwKSh0aGlzLCAoMCwgX2xvZGFzaC5waWNrKShvcHRpb25zLCBPYmplY3Qua2V5cyhJTlRFUk5BTF9ERUZBVUxUUykpLCBJTlRFUk5BTF9ERUZBVUxUUyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9xdWVyeSwgKDAsIF9sb2Rhc2gucGljaykob3B0aW9ucywgWydiZWZvcmUnLCAnYWZ0ZXInXSkpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gJiYgb3B0aW9ucy5jaGlsZHJlbltvcHRpb25zLmNoaWxkcmVuLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgX01vcmUuZGVmYXVsdCkge1xuICAgICAgdGhpcy5fc2V0TW9yZSh0aGlzLnBvcCgpKTtcbiAgICB9XG4gIH1cblxuICBfc2V0VXJpKHZhbHVlKSB7XG4gICAgdmFyIHBhcnNlZFVyaSA9ICgwLCBfdXJsLnBhcnNlKSh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5fdXJpID0gcGFyc2VkVXJpLnBhdGhuYW1lO1xuICAgICgwLCBfbG9kYXNoLmRlZmF1bHRzRGVlcCkodGhpcy5fcXVlcnksIHBhcnNlZFVyaS5xdWVyeSk7XG5cbiAgICBpZiAocGFyc2VkVXJpLnF1ZXJ5LmJlZm9yZSkge1xuICAgICAgdGhpcy5fcXVlcnkuYWZ0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWVyeS5iZWZvcmUgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBBIGdldHRlciB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoaXMgTGlzdGluZyBoYXMgYW55IG1vcmUgaXRlbXMgdG8gZmV0Y2guXG4gICogQHR5cGUge2Jvb2xlYW59XG4gICovXG5cblxuICBnZXQgaXNGaW5pc2hlZCgpIHtcbiAgICAvLyBUaGUgcHJvY2VzcyBvZiBjaGVja2luZyB3aGV0aGVyIGEgTGlzdGluZyBpcyAnZmluaXNoZWQnIHZhcmllcyBkZXBlbmRpbmcgb24gd2hhdCBraW5kIG9mIExpc3RpbmcgaXQgaXMuXG4gICAgcmV0dXJuIHRoaXMuX2lzQ29tbWVudExpc3RcbiAgICAvKiBGb3IgY29tbWVudCBMaXN0aW5ncyAoaS5lLiBMaXN0aW5ncyBjb250YWluaW5nIGNvbW1lbnRzIGFuZCBjb21tZW50IHJlcGxpZXMsIHNvdXJjZWQgYnkgYG1vcmVgIG9iamVjdHMpOiBBIExpc3RpbmcgaXNcbiAgICAqbmV2ZXIqIGZpbmlzaGVkIGlmIGl0IGhhcyBhIGNhY2hlZCBsb29rYWhlYWQgKGkuZS4gZXh0cmEgaXRlbXMgdGhhdCB3ZXJlIGZldGNoZWQgZnJvbSBhIHByZXZpb3VzIHJlcXVlc3QpLiBJZiB0aGVyZSBpc1xuICAgIG5vIGNhY2hlZCBsb29rYWhlYWQsIGEgTGlzdGluZyBpcyBmaW5pc2hlZCBpZmYgaXQgaGFzIGFuIGVtcHR5IGBtb3JlYCBvYmplY3QuICovXG4gICAgPyAoMCwgX2xvZGFzaC5pc0VtcHR5KSh0aGlzLl9jYWNoZWRMb29rYWhlYWQpICYmICEhdGhpcy5fbW9yZSAmJiAoMCwgX2xvZGFzaC5pc0VtcHR5KSh0aGlzLl9tb3JlLmNoaWxkcmVuKVxuICAgIC8qIEZvciBub24tY29tbWVudCBMaXN0aW5nczogQSBMaXN0aW5nIGlzIGFsd2F5cyBmaW5pc2hlZCBpZiBpdCBoYXMgbm8gVVJJIChzaW5jZSB0aGVyZSB3b3VsZCBiZSBub3doZXJlIHRvIGZldGNoIGl0ZW1zXG4gICAgZnJvbSkuIElmIGl0IGhhcyBhIFVSSSwgYSBMaXN0aW5nIGlzIGZpbmlzaGVkIGlmZiBpdHMgYGJlZm9yZWAgYW5kIGBhZnRlcmAgcXVlcnkgYXJlIGJvdGggYG51bGxgLiBUaGlzIGlzIGJlY2F1c2UgcmVkZGl0XG4gICAgcmV0dXJucyBhIHZhbHVlIG9mIGBudWxsYCBhcyB0aGUgYGFmdGVyYCBhbmQgYGJlZm9yZWAgcGFyYW1ldGVycyB0byBzaWduaWZ5IHRoYXQgYSBMaXN0aW5nIGlzIGNvbXBsZXRlLlxuICAgICBJdCBpcyBpbXBvcnRhbnQgdG8gY2hlY2sgZm9yIGBudWxsYCBoZXJlIHJhdGhlciB0aGFuIGFueSBmYWxzZXkgdmFsdWUsIGJlY2F1c2Ugd2hlbiBhbiBlbXB0eSBMaXN0aW5nIGlzIGluaXRpYWxpemVkLCBpdHNcbiAgICBgYWZ0ZXJgIGFuZCBgYmVmb3JlYCBwcm9wZXJ0aWVzIGFyZSBib3RoIGB1bmRlZmluZWRgLCBidXQgY2FsbGluZyB0aGVzZSBlbXB0eSBMaXN0aW5ncyBgZmluaXNoZWRgIHdvdWxkIGJlIGluY29ycmVjdC4gKi9cbiAgICA6ICF0aGlzLl91cmkgfHwgdGhpcy5fcXVlcnkuYWZ0ZXIgPT09IG51bGwgJiYgdGhpcy5fcXVlcnkuYmVmb3JlID09PSBudWxsO1xuICB9XG5cbiAgZ2V0IGlzX2ZpbmlzaGVkKCkge1xuICAgIC8vIGNhbWVsLWNhc2UgYWxpYXMgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICAgIC8vIEFzIGEgZ2V0dGVyLCB0aGUgYGlzRmluaXNoZWRgIHByb3BlcnR5IGRvZXNuJ3QgaGF2ZSBhbiBhbGlhcyBsaWtlIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICByZXR1cm4gdGhpcy5pc0ZpbmlzaGVkO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEZldGNoZXMgc29tZSBtb3JlIGl0ZW1zXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5hbW91bnQgVGhlIG51bWJlciBvZiBpdGVtcyB0byBmZXRjaC5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBSZXBsaWVzPWZhbHNlXSBGb3IgYSBMaXN0aW5nIHRoYXQgY29udGFpbnMgY29tbWVudCBvYmplY3RzIG9uIGEgU3VibWlzc2lvbiwgdGhpcyBvcHRpb24gY2FuXG4gIGJlIHVzZWQgdG8gc2F2ZSBhIGZldyBBUEkgY2FsbHMsIHByb3ZpZGVkIHRoYXQgb25seSB0b3AtbGV2ZWwgY29tbWVudHMgYXJlIGJlaW5nIGV4YW1pbmVkLiBJZiB0aGlzIGlzIHNldCB0byBgdHJ1ZWAsIHNub293cmFwXG4gIGlzIGFibGUgdG8gZmV0Y2ggMTAwIENvbW1lbnRzIHBlciBBUEkgY2FsbCByYXRoZXIgdGhhbiAyMCwgYnV0IGFsbCByZXR1cm5lZCBDb21tZW50cyB3aWxsIGhhdmUgbm8gZmV0Y2hlZCByZXBsaWVzIGJ5IGRlZmF1bHQuXG4gICpcbiAgKiBJbnRlcm5hbCBkZXRhaWxzOiBXaGVuIGBza2lwUmVwbGllc2AgaXMgc2V0IHRvIGB0cnVlYCwgc25vb3dyYXAgdXNlcyByZWRkaXQncyBgYXBpL2luZm9gIGVuZHBvaW50IHRvIGZldGNoIENvbW1lbnRzLiBXaGVuXG4gIGBza2lwUmVwbGllc2AgaXMgc2V0IHRvIGBmYWxzZWAsIHNub293cmFwIHVzZXMgcmVkZGl0J3MgYGFwaS9tb3JlY2hpbGRyZW5gIGVuZHBvaW50LiBJdCdzIHdvcnRoIG5vdGluZyB0aGF0IHJlZGRpdCBkb2VzXG4gIG5vdCBhbGxvdyBjb25jdXJyZW50IHJlcXVlc3RzIHRvIHRoZSBgYXBpL21vcmVjaGlsZHJlbmAgZW5kcG9pbnQgYnkgdGhlIHNhbWUgYWNjb3VudC5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGVuZD10cnVlXSBJZiBgdHJ1ZWAsIHRoZSByZXN1bHRpbmcgTGlzdGluZyB3aWxsIGNvbnRhaW4gdGhlIGV4aXN0aW5nIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvXG4gIHRoZSBuZXdseS1mZXRjaGVkIGVsZW1lbnRzLiBJZiBgZmFsc2VgLCB0aGUgcmVzdWx0aW5nIExpc3Rpbmcgd2lsbCBvbmx5IGNvbnRhaW4gdGhlIG5ld2x5LWZldGNoZWQgZWxlbWVudHMuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgbmV3IExpc3RpbmcgY29udGFpbmluZyB0aGUgbmV3bHktZmV0Y2hlZCBlbGVtZW50cy4gSWYgYG9wdGlvbnMuYXBwZW5kYCBpcyBgdHJ1ZWAsIHRoZSBuZXcgTGlzdGluZyB3aWxsXG4gIGFsc28gY29udGFpbiBhbGwgZWxlbWVudHMgdGhhdCB3ZXJlIGluIHRoZSBvcmlnaW5hbCBMaXN0aW5nLiBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMsIHRoZSBuZXdseS1mZXRjaGVkIGVsZW1lbnRzIHdpbGwgYXBwZWFyXG4gIGF0IHRoZSBlbmQgb2YgdGhlIG5ldyBMaXN0aW5nLiBIb3dldmVyLCBpZiByZXZlcnNlIHBhZ2luYXRpb24gaXMgZW5hYmxlZCAoaS5lLiBpZiB0aGlzIExpc3Rpbmcgd2FzIGNyZWF0ZWQgd2l0aCBhIGBiZWZvcmVgXG4gIHF1ZXJ5IHBhcmFtZXRlciksIHRoZW4gdGhlIG5ld2x5LWZldGNoZWQgZWxlbWVudHMgd2lsbCBhcHBlYXIgYXQgdGhlIGJlZ2lubmluZy4gSW4gYW55IGNhc2UsIGNvbnRpbnVpdHkgaXMgbWFpbnRhaW5lZCwgaS5lLlxuICB0aGUgb3JkZXIgb2YgaXRlbXMgaW4gdGhlIExpc3Rpbmcgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcHBlYXIgb24gcmVkZGl0LlxuICAqIEBleGFtcGxlXG4gICogci5nZXRIb3Qoe2xpbWl0OiAyNX0pLnRoZW4obXlMaXN0aW5nID0+IHtcbiAgKiAgIGNvbnNvbGUubG9nKG15TGlzdGluZy5sZW5ndGgpOyAvLyA9PiAyNVxuICAqICAgbXlMaXN0aW5nLmZldGNoTW9yZSh7YW1vdW50OiAxMH0pLnRoZW4oZXh0ZW5kZWRMaXN0aW5nID0+IHtcbiAgKiAgICAgY29uc29sZS5sb2coZXh0ZW5kZWRMaXN0aW5nLmxlbmd0aCk7IC8vID0+IDM1XG4gICogICB9KVxuICAqIH0pO1xuICAqL1xuXG5cbiAgZmV0Y2hNb3JlKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkT3B0aW9ucyA9ICgwLCBfbG9kYXNoLmRlZmF1bHRzKSh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgPyB7XG4gICAgICBhbW91bnQ6IG9wdGlvbnNcbiAgICB9IDogKDAsIF9sb2Rhc2guY2xvbmUpKG9wdGlvbnMpLCAvLyBBY2NlcHQgZWl0aGVyIGBza2lwX3JlcGxpZXNgIG9yIGBza2lwUmVwbGllc2AgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIHtcbiAgICAgIGFwcGVuZDogdHJ1ZSxcbiAgICAgIHNraXBSZXBsaWVzOiBvcHRpb25zLnNraXBfcmVwbGllc1xuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBwYXJzZWRPcHRpb25zLmFtb3VudCAhPT0gJ251bWJlcicgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE9wdGlvbnMuYW1vdW50KSkge1xuICAgICAgdGhyb3cgbmV3IF9lcnJvcnMuSW52YWxpZE1ldGhvZENhbGxFcnJvcignRmFpbGVkIHRvIGZldGNoIExpc3RpbmcuIChgYW1vdW50YCBwYXJhbWV0ZXIgd2FzIG1pc3Npbmcgb3IgaW52YWxpZCknKTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkT3B0aW9ucy5hbW91bnQgPD0gMCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yLl9wcm9taXNlV3JhcChfUHJvbWlzZS5kZWZhdWx0LnJlc29sdmUocGFyc2VkT3B0aW9ucy5hcHBlbmQgPyB0aGlzLl9jbG9uZSgpIDogdGhpcy5fY2xvbmUoKS5fZW1wdHkoKSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWNoZWRMb29rYWhlYWQpIHtcbiAgICAgIHZhciBjbG9uZWQgPSB0aGlzLl9jbG9uZSgpO1xuXG4gICAgICBjbG9uZWQucHVzaC5hcHBseShjbG9uZWQsIF90b0NvbnN1bWFibGVBcnJheShjbG9uZWQuX2NhY2hlZExvb2thaGVhZC5zcGxpY2UoMCwgcGFyc2VkT3B0aW9ucy5hbW91bnQpKSk7XG4gICAgICByZXR1cm4gY2xvbmVkLmZldGNoTW9yZShwYXJzZWRPcHRpb25zLmFtb3VudCAtIGNsb25lZC5sZW5ndGggKyB0aGlzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3IuX3Byb21pc2VXcmFwKHRoaXMuX21vcmUgPyB0aGlzLl9mZXRjaE1vcmVDb21tZW50cyhwYXJzZWRPcHRpb25zKSA6IHRoaXMuX2ZldGNoTW9yZVJlZ3VsYXIocGFyc2VkT3B0aW9ucykpO1xuICB9XG5cbiAgX2ZldGNoTW9yZVJlZ3VsYXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcXVlcnkgPSAoMCwgX2xvZGFzaC5vbWl0QnkpKCgwLCBfbG9kYXNoLmNsb25lKSh0aGlzLl9xdWVyeSksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuX2lzQ29tbWVudExpc3QpIHtcbiAgICAgIC8qIFJlZGRpdCByZXR1cm5zIGEgZGlmZmVyZW50IG51bWJlciBvZiBpdGVtcyBwZXIgcmVxdWVzdCBkZXBlbmRpbmcgb24gdGhlIGBsaW1pdGAgcXVlcnlzdHJpbmcgcHJvcGVydHkgc3BlY2lmaWVkIGluIHRoZVxuICAgICAgcmVxdWVzdC4gSWYgbm8gYGxpbWl0YCBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsIHJlZGRpdCByZXR1cm5zIHNvbWUgbnVtYmVyIG9mIGl0ZW1zIGRlcGVuZGluZyBvbiB0aGUgdXNlcidzIHByZWZlcmVuY2VzXG4gICAgICAoY3VycmVudGx5IDI1IGl0ZW1zIHdpdGggZGVmYXVsdCBwcmVmZXJlbmNlcykuIElmIGEgYGxpbWl0YCBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsIHRoZW4gcmVkZGl0IHJldHVybnMgYGxpbWl0YCBpdGVtcyBwZXJcbiAgICAgIGJhdGNoLiBIb3dldmVyLCB0aGlzIGlzIGNhcHBlZCBhdCAxMDAsIHNvIGlmIGEgYGxpbWl0YCBsYXJnZXIgdGhhbiAxMDAgaXRlbXMgaXMgc3BlY2lmaWVkLCByZWRkaXQgd2lsbCBvbmx5IHJldHVybiAxMDBcbiAgICAgIGl0ZW1zIGluIHRoZSBiYXRjaC4gKFRoZSBjYXAgb2YgMTAwIGNvdWxkIHBsYXVzaWJseSBjaGFuZ2UgdG8gYSBkaWZmZXJlbnQgYW1vdW50IGluIHRoZSBmdXR1cmUuKVxuICAgICAgIEhvd2V2ZXIsIG9uZSBjYXZlYXQgaXMgdGhhdCByZWRkaXQncyBwYXJzZXIgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSBqYXZhc2NyaXB0IGBJbmZpbml0eWAgZ2xvYmFsLiBJZiBgbGltaXQ9SW5maW5pdHlgIGlzXG4gICAgICBwcm92aWRlZCBpbiB0aGUgcXVlcnlzdHJpbmcsIHJlZGRpdCB3b24ndCB1bmRlcnN0YW5kIHRoZSBwYXJhbWV0ZXIgc28gaXQnbGwganVzdCBhY3QgYXMgaWYgbm8gcGFyYW1ldGVyIHdhcyBwcm92aWRlZCwgYW5kXG4gICAgICB3aWxsIHJldHVybiAyNSBpdGVtcyBpbiB0aGUgYmF0Y2guIFRoaXMgaXMgc3Vib3B0aW1hbCBiZWhhdmlvciBhcyBmYXIgYXMgc25vb3dyYXAgaXMgY29uY2VybmVkLCBiZWNhdXNlIGl0IG1lYW5zIHRoYXQgNFxuICAgICAgdGltZXMgYXMgbWFueSByZXF1ZXN0cyBhcmUgbmVlZGVkIHRvIGZldGNoIHRoZSBlbnRpcmUgbGlzdGluZy5cbiAgICAgICBUbyBnZXQgYXJvdW5kIHRoZSBpc3N1ZSwgc25vb3dyYXAgY2FwcyB0aGUgYGxpbWl0YCBwcm9wZXJ0eSBhdCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB3aGVuIHNlbmRpbmcgcmVxdWVzdHMuIFRoaXMgZW5zdXJlc1xuICAgICAgdGhhdCBgSW5maW5pdHlgIHdpbGwgbmV2ZXIgYmUgc2VudCBhcyBwYXJ0IG9mIHRoZSBxdWVyeXN0cmluZywgc28gcmVkZGl0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgbWF4aW1hbCAxMDAgaXRlbXMgcGVyXG4gICAgICByZXF1ZXN0IGlmIHRoZSBkZXNpcmVkIGFtb3VudCBvZiBpdGVtcyBpcyBsYXJnZS4gKi9cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gTWF0aC5taW4ob3B0aW9ucy5hbW91bnQsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fci5vYXV0aFJlcXVlc3Qoe1xuICAgICAgdXJpOiB0aGlzLl91cmksXG4gICAgICBxczogcXVlcnksXG4gICAgICBtZXRob2Q6IHRoaXMuX21ldGhvZFxuICAgIH0pLnRoZW4odGhpcy5fdHJhbnNmb3JtKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgdmFyIGNsb25lZCA9IF90aGlzLl9jbG9uZSgpO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuYXBwZW5kKSB7XG4gICAgICAgIGNsb25lZC5fZW1wdHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsb25lZC5fcXVlcnkuYmVmb3JlKSB7XG4gICAgICAgIGNsb25lZC51bnNoaWZ0LmFwcGx5KGNsb25lZCwgX3RvQ29uc3VtYWJsZUFycmF5KHJlc3BvbnNlKSk7XG4gICAgICAgIGNsb25lZC5fcXVlcnkuYmVmb3JlID0gcmVzcG9uc2UuX3F1ZXJ5LmJlZm9yZTtcbiAgICAgICAgY2xvbmVkLl9xdWVyeS5hZnRlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZWQucHVzaC5hcHBseShjbG9uZWQsIF90b0NvbnN1bWFibGVBcnJheShyZXNwb25zZSkpO1xuICAgICAgICBjbG9uZWQuX3F1ZXJ5LmJlZm9yZSA9IG51bGw7XG4gICAgICAgIGNsb25lZC5fcXVlcnkuYWZ0ZXIgPSByZXNwb25zZS5fcXVlcnkuYWZ0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5faXNDb21tZW50TGlzdCkge1xuICAgICAgICBjbG9uZWQuX21vcmUgPSBjbG9uZWQuX21vcmUgfHwgcmVzcG9uc2UuX21vcmUgfHwgX01vcmUuZW1wdHlDaGlsZHJlbjtcblxuICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID4gb3B0aW9ucy5hbW91bnQpIHtcbiAgICAgICAgICBjbG9uZWQuX2NhY2hlZExvb2thaGVhZCA9IEFycmF5LmZyb20oY2xvbmVkLnNwbGljZShvcHRpb25zLmFtb3VudCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZWQuZmV0Y2hNb3JlKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgYXBwZW5kOiB0cnVlLFxuICAgICAgICBhbW91bnQ6IG9wdGlvbnMuYW1vdW50IC0gcmVzcG9uc2UubGVuZ3RoXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgLyogUGFnaW5hdGlvbiBmb3IgY29tbWVudHMgd29ya3MgZGlmZmVyZW50bHkgdGhhbiBpdCBkb2VzIGZvciBtb3N0IG90aGVyIHRoaW5nczsgcmF0aGVyIHRoYW4gc2VuZGluZyBhIGxpbmsgdG8gdGhlIG5leHQgcGFnZVxuICB3aXRoaW4gYSBMaXN0aW5nLCByZWRkaXQgc2VuZHMgdGhlIGxhc3QgY29tbWVudCBpbiB0aGUgbGlzdCBhcyBhcyBhIGBtb3JlYCBvYmplY3QsIHdpdGggbGlua3MgdG8gYWxsIHRoZSByZW1haW5pbmcgY29tbWVudHNcbiAgaW4gdGhlIHRocmVhZC4gKi9cblxuXG4gIF9mZXRjaE1vcmVDb21tZW50cyhvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fbW9yZS5mZXRjaE1vcmUob3B0aW9ucykudGhlbihmdW5jdGlvbiAobW9yZUNvbW1lbnRzKSB7XG4gICAgICB2YXIgY2xvbmVkID0gX3RoaXMyLl9jbG9uZSgpO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuYXBwZW5kKSB7XG4gICAgICAgIGNsb25lZC5fZW1wdHkoKTtcbiAgICAgIH1cblxuICAgICAgY2xvbmVkLnB1c2guYXBwbHkoY2xvbmVkLCBfdG9Db25zdW1hYmxlQXJyYXkobW9yZUNvbW1lbnRzKSk7XG4gICAgICBjbG9uZWQuX21vcmUuY2hpbGRyZW4gPSBjbG9uZWQuX21vcmUuY2hpbGRyZW4uc2xpY2Uob3B0aW9ucy5hbW91bnQpO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBGZXRjaGVzIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhpcyBMaXN0aW5nLCBvbmx5IHN0b3BwaW5nIHdoZW4gdGhlcmUgYXJlIG5vbmUgbGVmdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIEZldGNoaW5nIG9wdGlvbnMgLS0gc2VlIHtAbGluayBMaXN0aW5nI2ZldGNoTW9yZX1cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBuZXcgZnVsbHktZmV0Y2hlZCBMaXN0aW5nLiBLZWVwIGluIG1pbmQgdGhhdCB0aGlzIG1ldGhvZCBoYXMgdGhlIHBvdGVudGlhbCB0byBleGhhdXN0IHlvdXJcbiAgcmF0ZWxpbWl0IHF1aWNrbHkgaWYgdGhlIExpc3RpbmcgZG9lc24ndCBoYXZlIGEgY2xlYXIgZW5kIChlLmcuIHdpdGggcG9zdHMgb24gdGhlIGZyb250IHBhZ2UpLCBzbyB1c2UgaXQgd2l0aCBkaXNjcmV0aW9uLlxuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldE1lKCkuZ2V0VXB2b3RlZENvbnRlbnQoKS5mZXRjaEFsbCgpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbIFN1Ym1pc3Npb24geyAuLi4gfSwgU3VibWlzc2lvbiB7IC4uLiB9LCAuLi4gXVxuICAqL1xuXG5cbiAgZmV0Y2hBbGwob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoTW9yZShfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICBhbW91bnQ6IEluZmluaXR5XG4gICAgfSkpO1xuICB9XG5cbiAgZmV0Y2hVbnRpbChvcHRpb25zKSB7XG4gICAgdGhpcy5fci5fd2FybignTGlzdGluZyNmZXRjaFVudGlsIGlzIGRlcHJlY2F0ZWQgLS0gdXNlIExpc3RpbmcjZmV0Y2hNb3JlIGluc3RlYWQuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5mZXRjaE1vcmUoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgYXBwZW5kOiB0cnVlLFxuICAgICAgYW1vdW50OiBvcHRpb25zLmxlbmd0aCAtIHRoaXMubGVuZ3RoXG4gICAgfSkpO1xuICB9XG5cbiAgX2Nsb25lKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRkZWVwID0gX3JlZi5kZWVwLFxuICAgICAgICBkZWVwID0gX3JlZiRkZWVwID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGVlcDtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gKDAsIF9sb2Rhc2gucGljaykodGhpcywgT2JqZWN0LmtleXMoSU5URVJOQUxfREVGQVVMVFMpKTtcbiAgICBwcm9wZXJ0aWVzLl9xdWVyeSA9ICgwLCBfbG9kYXNoLmNsb25lKShwcm9wZXJ0aWVzLl9xdWVyeSk7XG4gICAgcHJvcGVydGllcy5fY2FjaGVkTG9va2FoZWFkID0gKDAsIF9sb2Rhc2guY2xvbmUpKHByb3BlcnRpZXMuX2NhY2hlZExvb2thaGVhZCk7XG4gICAgcHJvcGVydGllcy5fbW9yZSA9IHRoaXMuX21vcmUgJiYgdGhpcy5fbW9yZS5fY2xvbmUoKTtcbiAgICB2YXIgc2hhbGxvd0NoaWxkcmVuID0gQXJyYXkuZnJvbSh0aGlzKTtcbiAgICBwcm9wZXJ0aWVzLmNoaWxkcmVuID0gZGVlcCA/IHNoYWxsb3dDaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnX2Nsb25lJyBpbiBpdGVtICYmIHR5cGVvZiBpdGVtLl9jbG9uZSA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZW0uX2Nsb25lKHtcbiAgICAgICAgZGVlcFxuICAgICAgfSkgOiBpdGVtO1xuICAgIH0pIDogc2hhbGxvd0NoaWxkcmVuO1xuICAgIHJldHVybiBuZXcgTGlzdGluZyhwcm9wZXJ0aWVzLCB0aGlzLl9yKTtcbiAgfVxuXG4gIF9zZXRNb3JlKG1vcmVPYmopIHtcbiAgICB0aGlzLl9tb3JlID0gbW9yZU9iajtcbiAgICB0aGlzLl9pc0NvbW1lbnRMaXN0ID0gdHJ1ZTtcbiAgfVxuXG4gIF9lbXB0eSgpIHtcbiAgICB0aGlzLnNwbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSAmJiBpdGVtLnRvSlNPTiA/IGl0ZW0udG9KU09OKCkgOiBpdGVtO1xuICAgIH0pO1xuICB9XG5cbn07XG4oMCwgX2hlbHBlcnMuZGVmaW5lSW5zcGVjdEZ1bmMpKExpc3RpbmcucHJvdG90eXBlLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBcIkxpc3RpbmcgXCIuY29uY2F0KF91dGlsLmRlZmF1bHQuaW5zcGVjdChBcnJheS5mcm9tKHRoaXMpKSk7XG59KTtcbnZhciBfZGVmYXVsdCA9IExpc3Rpbmc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/Listing.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/LiveThread.js":
/*!**********************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/LiveThread.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _events = __webpack_require__(/*! events */ \"events\");\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar WebSocket = _helpers.isBrowser ? global.WebSocket : __webpack_require__(/*! ws */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/index.js\");\nvar api_type = 'json';\n/**\n* A class representing a live reddit thread\n* <style> #LiveThread {display: none} </style>\n* @example\n*\n* // Get a livethread with the given ID\n* r.getLivethread('whrdxo8dg9n0')\n* @desc For the most part, reddit distributes the content of live threads via websocket, rather than through the REST API.\nAs such, snoowrap assigns each fetched LiveThread object a `stream` property, which takes the form of an\n[EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter). To listen for new thread updates, simply\nadd listeners to that emitter.\n\nThe following events can be emitted:\n- `update`: Occurs when a new update has been posted in this thread. Emits a `LiveUpdate` object containing information\nabout the new update.\n- `activity`: Occurs periodically when the viewer count for this thread changes.\n- `settings`: Occurs when the thread's settings change. Emits an object containing the new settings.\n- `delete`: Occurs when an update has been deleted. Emits the ID of the deleted update.\n- `strike`: Occurs when an update has been striken (marked incorrect and crossed out). Emits the ID of the striken update.\n- `embeds_ready`: Occurs when embedded media is now available for a previously-posted update.\n- `complete`: Occurs when this LiveThread has been marked as complete, and no more updates will be sent.\n\n(Note: These event types are mapped directly from reddit's categorization of the updates. The descriptions above are\nparaphrased from reddit's descriptions [here](https://www.reddit.com/dev/api#section_live).)\n\nAs an example, this would log all new livethread updates to the console:\n\n```javascript\nsomeLivethread.stream.on('update', data => {\n  console.log(data.body);\n});\n```\n\n* @extends RedditContent\n*/\n\nvar LiveThread = class LiveThread extends _RedditContent.default {\n  constructor(options, _r, _hasFetched) {\n    var _this;\n\n    super(options, _r, _hasFetched);\n    _this = this;\n    this._rawStream = null;\n    this._populatedStream = null;\n\n    if (_hasFetched) {\n      Object.defineProperty(this, 'stream', {\n        get: function () {\n          if (!_this._populatedStream && _this.websocket_url) {\n            _this._setupWebSocket();\n          }\n\n          return _this._populatedStream;\n        }\n      });\n    }\n  }\n\n  get _uri() {\n    return \"live/\".concat(this.id, \"/about\");\n  }\n\n  _setupWebSocket() {\n    var _this2 = this;\n\n    this._rawStream = new WebSocket(this.websocket_url);\n    this._populatedStream = new _events.EventEmitter();\n\n    var handler = function (data) {\n      var parsed = _this2._r._populate(JSON.parse(data));\n\n      _this2._populatedStream.emit(parsed.type, parsed.payload);\n    };\n\n    if (typeof this._rawStream.on === 'function') {\n      this._rawStream.on('message', handler);\n    } else {\n      this._rawStream.onmessage = function (messageEvent) {\n        return handler(messageEvent.data);\n      };\n    }\n  }\n  /**\n  * @summary Adds a new update to this thread.\n  * @param {string} body The body of the new update\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').addUpdate('Breaking: Someone is reading the snoowrap documentation \\\\o/')\n  */\n\n\n  addUpdate(body) {\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/update\"),\n      form: {\n        api_type,\n        body\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Strikes (marks incorrect and crosses out) the given update.\n  * @param {object} options\n  * @param {string} options.id The ID of the update that should be striked.\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').strikeUpdate({id: 'LiveUpdate_edc34446-faf0-11e5-a1b4-0e858bca33cd'})\n  */\n\n\n  strikeUpdate(_ref) {\n    var id = _ref.id;\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/strike_update\"),\n      form: {\n        api_type,\n        id: \"\".concat(id.startsWith('LiveUpdate_') ? '' : 'LiveUpdate_').concat(id)\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Deletes an update from this LiveThread.\n  * @param {object} options\n  * @param {string} options.id The ID of the LiveUpdate that should be deleted\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').deleteUpdate({id: 'LiveUpdate_edc34446-faf0-11e5-a1b4-0e858bca33cd'})\n  */\n\n\n  deleteUpdate(_ref2) {\n    var id = _ref2.id;\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/delete_update\"),\n      form: {\n        api_type,\n        id: \"\".concat(id.startsWith('LiveUpdate_') ? '' : 'LiveUpdate_').concat(id)\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Gets a list of this LiveThread's contributors\n  * @returns {Promise} An Array containing RedditUsers\n  * @example\n  *\n  * r.getLivethread('whrdxo8dg9n0').getContributors().then(console.log)\n  * // => [\n  * //  RedditUser { permissions: ['edit'], name: 'not_an_aardvark', id: 't2_k83md' },\n  * //  RedditUser { permissions: ['all'], id: 't2_u3l80', name: 'snoowrap_testing' }\n  * // ]\n  */\n\n\n  getContributors() {\n    return this._get({\n      uri: \"live/\".concat(this.id, \"/contributors\")\n    }).then(function (contributors) {\n      return Array.isArray(contributors[0]) ? contributors[0] : contributors;\n    });\n  }\n  /**\n  * @summary Invites a contributor to this LiveThread.\n  * @param {object} options\n  * @param {string} options.name The name of the user who should be invited\n  * @param {Array} options.permissions The permissions that the invited user should receive. This should be an Array containing\n  some combination of `'update', 'edit', 'manage'`. To invite a contributor with full permissions, omit this property.\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').inviteContributor({name: 'actually_an_aardvark', permissions: ['update']})\n  */\n\n\n  inviteContributor(_ref3) {\n    var name = _ref3.name,\n        permissions = _ref3.permissions;\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/invite_contributor\"),\n      form: {\n        api_type,\n        name,\n        permissions: (0, _helpers.formatLivethreadPermissions)(permissions),\n        type: 'liveupdate_contributor_invite'\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Revokes an invitation for the given user to become a contributor on this LiveThread.\n  * @param {object} options\n  * @param {string} options.name The username of the account whose invitation should be revoked\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').revokeContributorInvite({name: 'actually_an_aardvark'});\n  */\n\n\n  revokeContributorInvite(_ref4) {\n    var _this3 = this;\n\n    var name = _ref4.name;\n    return this._r.getUser(name).fetch().get('id').then(function (userId) {\n      return _this3._post({\n        uri: \"api/live/\".concat(_this3.id, \"/rm_contributor_invite\"),\n        form: {\n          api_type,\n          id: \"t2_\".concat(userId)\n        }\n      });\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Accepts a pending contributor invitation on this LiveThread.\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').acceptContributorInvite()\n  */\n\n\n  acceptContributorInvite() {\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/accept_contributor_invite\"),\n      form: {\n        api_type\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Abdicates contributor status on this LiveThread.\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').leaveContributor()\n  */\n\n\n  leaveContributor() {\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/leave_contributor\"),\n      form: {\n        api_type\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Removes the given user from contributor status on this LiveThread.\n  * @param {object} options\n  * @param {string} options.name The username of the account who should be removed\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').removeContributor({name: 'actually_an_aardvark'})\n  */\n\n\n  removeContributor(_ref5) {\n    var _this4 = this;\n\n    var name = _ref5.name;\n    return this._r.getUser(name).fetch().get('id').then(function (userId) {\n      return _this4._post({\n        uri: \"api/live/\".concat(_this4.id, \"/rm_contributor\"),\n        form: {\n          api_type,\n          id: \"t2_\".concat(userId)\n        }\n      });\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Sets the permissions of the given contributor.\n  * @param {object} options\n  * @param {string} options.name The name of the user whose permissions should be changed\n  * @param {Array} options.permissions The updated permissions that the user should have. This should be an Array containing\n  some combination of `'update', 'edit', 'manage'`. To give the contributor with full permissions, omit this property.\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').setContributorPermissions({name: 'actually_an_aardvark', permissions: ['edit']})\n  */\n\n\n  setContributorPermissions(_ref6) {\n    var name = _ref6.name,\n        permissions = _ref6.permissions;\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/set_contributor_permissions\"),\n      form: {\n        api_type,\n        name,\n        permissions: (0, _helpers.formatLivethreadPermissions)(permissions),\n        type: 'liveupdate_contributor'\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Edits the settings on this LiveThread.\n  * @param {object} options\n  * @param {string} options.title The title of the thread\n  * @param {string} [options.description] A descriptions of the thread. 120 characters max\n  * @param {string} [options.resources] Information and useful links related to the thread.\n  * @param {boolean} options.nsfw Determines whether the thread is Not Safe For Work\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').editSettings({title: 'My livethread', description: 'an updated description'})\n  */\n\n\n  editSettings(_ref7) {\n    var title = _ref7.title,\n        description = _ref7.description,\n        resources = _ref7.resources,\n        nsfw = _ref7.nsfw;\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/edit\"),\n      form: {\n        api_type,\n        description,\n        nsfw,\n        resources,\n        title\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Permanently closes this thread, preventing any more updates from being added.\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').closeThread()\n  */\n\n\n  closeThread() {\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/close_thread\"),\n      form: {\n        api_type\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Reports this LiveThread for breaking reddit's rules.\n  * @param {object} options\n  * @param {string} options.reason The reason for the report. One of `spam`, `vote-manipulation`, `personal-information`,\n  `sexualizing-minors`, `site-breaking`\n  * @returns {Promise} A Promise that fulfills with this LiveThread when the request is complete\n  * @example r.getLivethread('whrdxo8dg9n0').report({reason: 'Breaking a rule blah blah blah'})\n  */\n\n\n  report(_ref8) {\n    var reason = _ref8.reason;\n    return this._post({\n      uri: \"api/live/\".concat(this.id, \"/report\"),\n      form: {\n        api_type,\n        type: reason\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Gets a Listing containing past updates to this LiveThread.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing LiveUpdates\n  * @example\n  *\n  * r.getLivethread('whrdxo8dg9n0').getRecentUpdates().then(console.log)\n  * // => Listing [\n  * //  LiveUpdate { ... },\n  * //  LiveUpdate { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getRecentUpdates(options) {\n    return this._getListing({\n      uri: \"live/\".concat(this.id),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a list of reddit submissions linking to this LiveThread.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions\n  * @example\n  *\n  * r.getLivethread('whrdxo8dg9n0').getDiscussions().then(console.log)\n  * // => Listing [\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getDiscussions(options) {\n    return this._getListing({\n      uri: \"live/\".concat(this.id, \"/discussions\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Stops listening for new updates on this LiveThread.\n  * @desc To avoid memory leaks that can result from open sockets, it's recommended that you call this method when you're\n  finished listening for updates on this LiveThread.\n  *\n  * This should not be confused with {@link LiveThread#closeThread}, which marks the thread as \"closed\" on reddit.\n  * @returns undefined\n  * @example\n  *\n  * var myThread = r.getLivethread('whrdxo8dg9n0');\n  * myThread.stream.on('update', content => {\n  *   console.log(content);\n  *   myThread.closeStream();\n  * })\n  *\n  */\n\n\n  closeStream() {\n    if (this._rawStream) {\n      this._rawStream.close();\n    }\n  }\n\n};\nvar _default = LiveThread;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL0xpdmVUaHJlYWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsY0FBYyxtQkFBTyxDQUFDLHNCQUFROztBQUU5QixlQUFlLG1CQUFPLENBQUMsb0VBQWU7O0FBRXRDLDRDQUE0QyxtQkFBTyxDQUFDLHVGQUFvQjs7QUFFeEUsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsd0RBQXdELG1CQUFPLENBQUMsa0VBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QiwyREFBMkQsc0RBQXNEO0FBQ2pIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQzFCLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L29iamVjdHMvTGl2ZVRocmVhZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9ldmVudHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuXG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKFwiLi4vaGVscGVycy5qc1wiKTtcblxudmFyIF9SZWRkaXRDb250ZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZWRkaXRDb250ZW50LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFdlYlNvY2tldCA9IF9oZWxwZXJzLmlzQnJvd3NlciA/IGdsb2JhbC5XZWJTb2NrZXQgOiByZXF1aXJlKCd3cycpO1xudmFyIGFwaV90eXBlID0gJ2pzb24nO1xuLyoqXG4qIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgbGl2ZSByZWRkaXQgdGhyZWFkXG4qIDxzdHlsZT4gI0xpdmVUaHJlYWQge2Rpc3BsYXk6IG5vbmV9IDwvc3R5bGU+XG4qIEBleGFtcGxlXG4qXG4qIC8vIEdldCBhIGxpdmV0aHJlYWQgd2l0aCB0aGUgZ2l2ZW4gSURcbiogci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKVxuKiBAZGVzYyBGb3IgdGhlIG1vc3QgcGFydCwgcmVkZGl0IGRpc3RyaWJ1dGVzIHRoZSBjb250ZW50IG9mIGxpdmUgdGhyZWFkcyB2aWEgd2Vic29ja2V0LCByYXRoZXIgdGhhbiB0aHJvdWdoIHRoZSBSRVNUIEFQSS5cbkFzIHN1Y2gsIHNub293cmFwIGFzc2lnbnMgZWFjaCBmZXRjaGVkIExpdmVUaHJlYWQgb2JqZWN0IGEgYHN0cmVhbWAgcHJvcGVydHksIHdoaWNoIHRha2VzIHRoZSBmb3JtIG9mIGFuXG5bRXZlbnRFbWl0dGVyXShodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXIpLiBUbyBsaXN0ZW4gZm9yIG5ldyB0aHJlYWQgdXBkYXRlcywgc2ltcGx5XG5hZGQgbGlzdGVuZXJzIHRvIHRoYXQgZW1pdHRlci5cblxuVGhlIGZvbGxvd2luZyBldmVudHMgY2FuIGJlIGVtaXR0ZWQ6XG4tIGB1cGRhdGVgOiBPY2N1cnMgd2hlbiBhIG5ldyB1cGRhdGUgaGFzIGJlZW4gcG9zdGVkIGluIHRoaXMgdGhyZWFkLiBFbWl0cyBhIGBMaXZlVXBkYXRlYCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIG5ldyB1cGRhdGUuXG4tIGBhY3Rpdml0eWA6IE9jY3VycyBwZXJpb2RpY2FsbHkgd2hlbiB0aGUgdmlld2VyIGNvdW50IGZvciB0aGlzIHRocmVhZCBjaGFuZ2VzLlxuLSBgc2V0dGluZ3NgOiBPY2N1cnMgd2hlbiB0aGUgdGhyZWFkJ3Mgc2V0dGluZ3MgY2hhbmdlLiBFbWl0cyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IHNldHRpbmdzLlxuLSBgZGVsZXRlYDogT2NjdXJzIHdoZW4gYW4gdXBkYXRlIGhhcyBiZWVuIGRlbGV0ZWQuIEVtaXRzIHRoZSBJRCBvZiB0aGUgZGVsZXRlZCB1cGRhdGUuXG4tIGBzdHJpa2VgOiBPY2N1cnMgd2hlbiBhbiB1cGRhdGUgaGFzIGJlZW4gc3RyaWtlbiAobWFya2VkIGluY29ycmVjdCBhbmQgY3Jvc3NlZCBvdXQpLiBFbWl0cyB0aGUgSUQgb2YgdGhlIHN0cmlrZW4gdXBkYXRlLlxuLSBgZW1iZWRzX3JlYWR5YDogT2NjdXJzIHdoZW4gZW1iZWRkZWQgbWVkaWEgaXMgbm93IGF2YWlsYWJsZSBmb3IgYSBwcmV2aW91c2x5LXBvc3RlZCB1cGRhdGUuXG4tIGBjb21wbGV0ZWA6IE9jY3VycyB3aGVuIHRoaXMgTGl2ZVRocmVhZCBoYXMgYmVlbiBtYXJrZWQgYXMgY29tcGxldGUsIGFuZCBubyBtb3JlIHVwZGF0ZXMgd2lsbCBiZSBzZW50LlxuXG4oTm90ZTogVGhlc2UgZXZlbnQgdHlwZXMgYXJlIG1hcHBlZCBkaXJlY3RseSBmcm9tIHJlZGRpdCdzIGNhdGVnb3JpemF0aW9uIG9mIHRoZSB1cGRhdGVzLiBUaGUgZGVzY3JpcHRpb25zIGFib3ZlIGFyZVxucGFyYXBocmFzZWQgZnJvbSByZWRkaXQncyBkZXNjcmlwdGlvbnMgW2hlcmVdKGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vZGV2L2FwaSNzZWN0aW9uX2xpdmUpLilcblxuQXMgYW4gZXhhbXBsZSwgdGhpcyB3b3VsZCBsb2cgYWxsIG5ldyBsaXZldGhyZWFkIHVwZGF0ZXMgdG8gdGhlIGNvbnNvbGU6XG5cbmBgYGphdmFzY3JpcHRcbnNvbWVMaXZldGhyZWFkLnN0cmVhbS5vbigndXBkYXRlJywgZGF0YSA9PiB7XG4gIGNvbnNvbGUubG9nKGRhdGEuYm9keSk7XG59KTtcbmBgYFxuXG4qIEBleHRlbmRzIFJlZGRpdENvbnRlbnRcbiovXG5cbnZhciBMaXZlVGhyZWFkID0gY2xhc3MgTGl2ZVRocmVhZCBleHRlbmRzIF9SZWRkaXRDb250ZW50LmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBfciwgX2hhc0ZldGNoZWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBzdXBlcihvcHRpb25zLCBfciwgX2hhc0ZldGNoZWQpO1xuICAgIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9yYXdTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3BvcHVsYXRlZFN0cmVhbSA9IG51bGw7XG5cbiAgICBpZiAoX2hhc0ZldGNoZWQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RyZWFtJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLl9wb3B1bGF0ZWRTdHJlYW0gJiYgX3RoaXMud2Vic29ja2V0X3VybCkge1xuICAgICAgICAgICAgX3RoaXMuX3NldHVwV2ViU29ja2V0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9wb3B1bGF0ZWRTdHJlYW07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfdXJpKCkge1xuICAgIHJldHVybiBcImxpdmUvXCIuY29uY2F0KHRoaXMuaWQsIFwiL2Fib3V0XCIpO1xuICB9XG5cbiAgX3NldHVwV2ViU29ja2V0KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5fcmF3U3RyZWFtID0gbmV3IFdlYlNvY2tldCh0aGlzLndlYnNvY2tldF91cmwpO1xuICAgIHRoaXMuX3BvcHVsYXRlZFN0cmVhbSA9IG5ldyBfZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHBhcnNlZCA9IF90aGlzMi5fci5fcG9wdWxhdGUoSlNPTi5wYXJzZShkYXRhKSk7XG5cbiAgICAgIF90aGlzMi5fcG9wdWxhdGVkU3RyZWFtLmVtaXQocGFyc2VkLnR5cGUsIHBhcnNlZC5wYXlsb2FkKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9yYXdTdHJlYW0ub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3Jhd1N0cmVhbS5vbignbWVzc2FnZScsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yYXdTdHJlYW0ub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcihtZXNzYWdlRXZlbnQuZGF0YSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBBZGRzIGEgbmV3IHVwZGF0ZSB0byB0aGlzIHRocmVhZC5cbiAgKiBAcGFyYW0ge3N0cmluZ30gYm9keSBUaGUgYm9keSBvZiB0aGUgbmV3IHVwZGF0ZVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgTGl2ZVRocmVhZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5hZGRVcGRhdGUoJ0JyZWFraW5nOiBTb21lb25lIGlzIHJlYWRpbmcgdGhlIHNub293cmFwIGRvY3VtZW50YXRpb24gXFxcXG8vJylcbiAgKi9cblxuXG4gIGFkZFVwZGF0ZShib2R5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcImFwaS9saXZlL1wiLmNvbmNhdCh0aGlzLmlkLCBcIi91cGRhdGVcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlLFxuICAgICAgICBib2R5XG4gICAgICB9XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFN0cmlrZXMgKG1hcmtzIGluY29ycmVjdCBhbmQgY3Jvc3NlcyBvdXQpIHRoZSBnaXZlbiB1cGRhdGUuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCBUaGUgSUQgb2YgdGhlIHVwZGF0ZSB0aGF0IHNob3VsZCBiZSBzdHJpa2VkLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgTGl2ZVRocmVhZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5zdHJpa2VVcGRhdGUoe2lkOiAnTGl2ZVVwZGF0ZV9lZGMzNDQ0Ni1mYWYwLTExZTUtYTFiNC0wZTg1OGJjYTMzY2QnfSlcbiAgKi9cblxuXG4gIHN0cmlrZVVwZGF0ZShfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZDtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwiYXBpL2xpdmUvXCIuY29uY2F0KHRoaXMuaWQsIFwiL3N0cmlrZV91cGRhdGVcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlLFxuICAgICAgICBpZDogXCJcIi5jb25jYXQoaWQuc3RhcnRzV2l0aCgnTGl2ZVVwZGF0ZV8nKSA/ICcnIDogJ0xpdmVVcGRhdGVfJykuY29uY2F0KGlkKVxuICAgICAgfVxuICAgIH0pLnRoZW4oKDAsIF9oZWxwZXJzLmhhbmRsZUpzb25FcnJvcnMpKHRoaXMpKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBEZWxldGVzIGFuIHVwZGF0ZSBmcm9tIHRoaXMgTGl2ZVRocmVhZC5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmlkIFRoZSBJRCBvZiB0aGUgTGl2ZVVwZGF0ZSB0aGF0IHNob3VsZCBiZSBkZWxldGVkXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBMaXZlVGhyZWFkIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldExpdmV0aHJlYWQoJ3docmR4bzhkZzluMCcpLmRlbGV0ZVVwZGF0ZSh7aWQ6ICdMaXZlVXBkYXRlX2VkYzM0NDQ2LWZhZjAtMTFlNS1hMWI0LTBlODU4YmNhMzNjZCd9KVxuICAqL1xuXG5cbiAgZGVsZXRlVXBkYXRlKF9yZWYyKSB7XG4gICAgdmFyIGlkID0gX3JlZjIuaWQ7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcImFwaS9saXZlL1wiLmNvbmNhdCh0aGlzLmlkLCBcIi9kZWxldGVfdXBkYXRlXCIpLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGlkLnN0YXJ0c1dpdGgoJ0xpdmVVcGRhdGVfJykgPyAnJyA6ICdMaXZlVXBkYXRlXycpLmNvbmNhdChpZClcbiAgICAgIH1cbiAgICB9KS50aGVuKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgdGhpcyBMaXZlVGhyZWFkJ3MgY29udHJpYnV0b3JzXG4gICogQHJldHVybnMge1Byb21pc2V9IEFuIEFycmF5IGNvbnRhaW5pbmcgUmVkZGl0VXNlcnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5nZXRDb250cmlidXRvcnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IFtcbiAgKiAvLyAgUmVkZGl0VXNlciB7IHBlcm1pc3Npb25zOiBbJ2VkaXQnXSwgbmFtZTogJ25vdF9hbl9hYXJkdmFyaycsIGlkOiAndDJfazgzbWQnIH0sXG4gICogLy8gIFJlZGRpdFVzZXIgeyBwZXJtaXNzaW9uczogWydhbGwnXSwgaWQ6ICd0Ml91M2w4MCcsIG5hbWU6ICdzbm9vd3JhcF90ZXN0aW5nJyB9XG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0Q29udHJpYnV0b3JzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiBcImxpdmUvXCIuY29uY2F0KHRoaXMuaWQsIFwiL2NvbnRyaWJ1dG9yc1wiKVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbnRyaWJ1dG9ycykge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY29udHJpYnV0b3JzWzBdKSA/IGNvbnRyaWJ1dG9yc1swXSA6IGNvbnRyaWJ1dG9ycztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBJbnZpdGVzIGEgY29udHJpYnV0b3IgdG8gdGhpcyBMaXZlVGhyZWFkLlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgbmFtZSBvZiB0aGUgdXNlciB3aG8gc2hvdWxkIGJlIGludml0ZWRcbiAgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnBlcm1pc3Npb25zIFRoZSBwZXJtaXNzaW9ucyB0aGF0IHRoZSBpbnZpdGVkIHVzZXIgc2hvdWxkIHJlY2VpdmUuIFRoaXMgc2hvdWxkIGJlIGFuIEFycmF5IGNvbnRhaW5pbmdcbiAgc29tZSBjb21iaW5hdGlvbiBvZiBgJ3VwZGF0ZScsICdlZGl0JywgJ21hbmFnZSdgLiBUbyBpbnZpdGUgYSBjb250cmlidXRvciB3aXRoIGZ1bGwgcGVybWlzc2lvbnMsIG9taXQgdGhpcyBwcm9wZXJ0eS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIExpdmVUaHJlYWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0TGl2ZXRocmVhZCgnd2hyZHhvOGRnOW4wJykuaW52aXRlQ29udHJpYnV0b3Ioe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsIHBlcm1pc3Npb25zOiBbJ3VwZGF0ZSddfSlcbiAgKi9cblxuXG4gIGludml0ZUNvbnRyaWJ1dG9yKF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBwZXJtaXNzaW9ucyA9IF9yZWYzLnBlcm1pc3Npb25zO1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJhcGkvbGl2ZS9cIi5jb25jYXQodGhpcy5pZCwgXCIvaW52aXRlX2NvbnRyaWJ1dG9yXCIpLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGVybWlzc2lvbnM6ICgwLCBfaGVscGVycy5mb3JtYXRMaXZldGhyZWFkUGVybWlzc2lvbnMpKHBlcm1pc3Npb25zKSxcbiAgICAgICAgdHlwZTogJ2xpdmV1cGRhdGVfY29udHJpYnV0b3JfaW52aXRlJ1xuICAgICAgfVxuICAgIH0pLnRoZW4oKDAsIF9oZWxwZXJzLmhhbmRsZUpzb25FcnJvcnMpKHRoaXMpKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBSZXZva2VzIGFuIGludml0YXRpb24gZm9yIHRoZSBnaXZlbiB1c2VyIHRvIGJlY29tZSBhIGNvbnRyaWJ1dG9yIG9uIHRoaXMgTGl2ZVRocmVhZC5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIHVzZXJuYW1lIG9mIHRoZSBhY2NvdW50IHdob3NlIGludml0YXRpb24gc2hvdWxkIGJlIHJldm9rZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIExpdmVUaHJlYWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0TGl2ZXRocmVhZCgnd2hyZHhvOGRnOW4wJykucmV2b2tlQ29udHJpYnV0b3JJbnZpdGUoe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyayd9KTtcbiAgKi9cblxuXG4gIHJldm9rZUNvbnRyaWJ1dG9ySW52aXRlKF9yZWY0KSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgbmFtZSA9IF9yZWY0Lm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3IuZ2V0VXNlcihuYW1lKS5mZXRjaCgpLmdldCgnaWQnKS50aGVuKGZ1bmN0aW9uICh1c2VySWQpIHtcbiAgICAgIHJldHVybiBfdGhpczMuX3Bvc3Qoe1xuICAgICAgICB1cmk6IFwiYXBpL2xpdmUvXCIuY29uY2F0KF90aGlzMy5pZCwgXCIvcm1fY29udHJpYnV0b3JfaW52aXRlXCIpLFxuICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgICAgaWQ6IFwidDJfXCIuY29uY2F0KHVzZXJJZClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEFjY2VwdHMgYSBwZW5kaW5nIGNvbnRyaWJ1dG9yIGludml0YXRpb24gb24gdGhpcyBMaXZlVGhyZWFkLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgTGl2ZVRocmVhZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5hY2NlcHRDb250cmlidXRvckludml0ZSgpXG4gICovXG5cblxuICBhY2NlcHRDb250cmlidXRvckludml0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwiYXBpL2xpdmUvXCIuY29uY2F0KHRoaXMuaWQsIFwiL2FjY2VwdF9jb250cmlidXRvcl9pbnZpdGVcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEFiZGljYXRlcyBjb250cmlidXRvciBzdGF0dXMgb24gdGhpcyBMaXZlVGhyZWFkLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgTGl2ZVRocmVhZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5sZWF2ZUNvbnRyaWJ1dG9yKClcbiAgKi9cblxuXG4gIGxlYXZlQ29udHJpYnV0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcImFwaS9saXZlL1wiLmNvbmNhdCh0aGlzLmlkLCBcIi9sZWF2ZV9jb250cmlidXRvclwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgUmVtb3ZlcyB0aGUgZ2l2ZW4gdXNlciBmcm9tIGNvbnRyaWJ1dG9yIHN0YXR1cyBvbiB0aGlzIExpdmVUaHJlYWQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uYW1lIFRoZSB1c2VybmFtZSBvZiB0aGUgYWNjb3VudCB3aG8gc2hvdWxkIGJlIHJlbW92ZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIExpdmVUaHJlYWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0TGl2ZXRocmVhZCgnd2hyZHhvOGRnOW4wJykucmVtb3ZlQ29udHJpYnV0b3Ioe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyayd9KVxuICAqL1xuXG5cbiAgcmVtb3ZlQ29udHJpYnV0b3IoX3JlZjUpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBuYW1lID0gX3JlZjUubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fci5nZXRVc2VyKG5hbWUpLmZldGNoKCkuZ2V0KCdpZCcpLnRoZW4oZnVuY3Rpb24gKHVzZXJJZCkge1xuICAgICAgcmV0dXJuIF90aGlzNC5fcG9zdCh7XG4gICAgICAgIHVyaTogXCJhcGkvbGl2ZS9cIi5jb25jYXQoX3RoaXM0LmlkLCBcIi9ybV9jb250cmlidXRvclwiKSxcbiAgICAgICAgZm9ybToge1xuICAgICAgICAgIGFwaV90eXBlLFxuICAgICAgICAgIGlkOiBcInQyX1wiLmNvbmNhdCh1c2VySWQpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKDAsIF9oZWxwZXJzLmhhbmRsZUpzb25FcnJvcnMpKHRoaXMpKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBTZXRzIHRoZSBwZXJtaXNzaW9ucyBvZiB0aGUgZ2l2ZW4gY29udHJpYnV0b3IuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uYW1lIFRoZSBuYW1lIG9mIHRoZSB1c2VyIHdob3NlIHBlcm1pc3Npb25zIHNob3VsZCBiZSBjaGFuZ2VkXG4gICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5wZXJtaXNzaW9ucyBUaGUgdXBkYXRlZCBwZXJtaXNzaW9ucyB0aGF0IHRoZSB1c2VyIHNob3VsZCBoYXZlLiBUaGlzIHNob3VsZCBiZSBhbiBBcnJheSBjb250YWluaW5nXG4gIHNvbWUgY29tYmluYXRpb24gb2YgYCd1cGRhdGUnLCAnZWRpdCcsICdtYW5hZ2UnYC4gVG8gZ2l2ZSB0aGUgY29udHJpYnV0b3Igd2l0aCBmdWxsIHBlcm1pc3Npb25zLCBvbWl0IHRoaXMgcHJvcGVydHkuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBMaXZlVGhyZWFkIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldExpdmV0aHJlYWQoJ3docmR4bzhkZzluMCcpLnNldENvbnRyaWJ1dG9yUGVybWlzc2lvbnMoe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsIHBlcm1pc3Npb25zOiBbJ2VkaXQnXX0pXG4gICovXG5cblxuICBzZXRDb250cmlidXRvclBlcm1pc3Npb25zKF9yZWY2KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmNi5uYW1lLFxuICAgICAgICBwZXJtaXNzaW9ucyA9IF9yZWY2LnBlcm1pc3Npb25zO1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJhcGkvbGl2ZS9cIi5jb25jYXQodGhpcy5pZCwgXCIvc2V0X2NvbnRyaWJ1dG9yX3Blcm1pc3Npb25zXCIpLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGVybWlzc2lvbnM6ICgwLCBfaGVscGVycy5mb3JtYXRMaXZldGhyZWFkUGVybWlzc2lvbnMpKHBlcm1pc3Npb25zKSxcbiAgICAgICAgdHlwZTogJ2xpdmV1cGRhdGVfY29udHJpYnV0b3InXG4gICAgICB9XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEVkaXRzIHRoZSBzZXR0aW5ncyBvbiB0aGlzIExpdmVUaHJlYWQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSBUaGUgdGl0bGUgb2YgdGhlIHRocmVhZFxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl0gQSBkZXNjcmlwdGlvbnMgb2YgdGhlIHRocmVhZC4gMTIwIGNoYXJhY3RlcnMgbWF4XG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlc291cmNlc10gSW5mb3JtYXRpb24gYW5kIHVzZWZ1bCBsaW5rcyByZWxhdGVkIHRvIHRoZSB0aHJlYWQuXG4gICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLm5zZncgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0aHJlYWQgaXMgTm90IFNhZmUgRm9yIFdvcmtcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIExpdmVUaHJlYWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0TGl2ZXRocmVhZCgnd2hyZHhvOGRnOW4wJykuZWRpdFNldHRpbmdzKHt0aXRsZTogJ015IGxpdmV0aHJlYWQnLCBkZXNjcmlwdGlvbjogJ2FuIHVwZGF0ZWQgZGVzY3JpcHRpb24nfSlcbiAgKi9cblxuXG4gIGVkaXRTZXR0aW5ncyhfcmVmNykge1xuICAgIHZhciB0aXRsZSA9IF9yZWY3LnRpdGxlLFxuICAgICAgICBkZXNjcmlwdGlvbiA9IF9yZWY3LmRlc2NyaXB0aW9uLFxuICAgICAgICByZXNvdXJjZXMgPSBfcmVmNy5yZXNvdXJjZXMsXG4gICAgICAgIG5zZncgPSBfcmVmNy5uc2Z3O1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJhcGkvbGl2ZS9cIi5jb25jYXQodGhpcy5pZCwgXCIvZWRpdFwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBuc2Z3LFxuICAgICAgICByZXNvdXJjZXMsXG4gICAgICAgIHRpdGxlXG4gICAgICB9XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFBlcm1hbmVudGx5IGNsb3NlcyB0aGlzIHRocmVhZCwgcHJldmVudGluZyBhbnkgbW9yZSB1cGRhdGVzIGZyb20gYmVpbmcgYWRkZWQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBMaXZlVGhyZWFkIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldExpdmV0aHJlYWQoJ3docmR4bzhkZzluMCcpLmNsb3NlVGhyZWFkKClcbiAgKi9cblxuXG4gIGNsb3NlVGhyZWFkKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJhcGkvbGl2ZS9cIi5jb25jYXQodGhpcy5pZCwgXCIvY2xvc2VfdGhyZWFkXCIpLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBSZXBvcnRzIHRoaXMgTGl2ZVRocmVhZCBmb3IgYnJlYWtpbmcgcmVkZGl0J3MgcnVsZXMuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yZWFzb24gVGhlIHJlYXNvbiBmb3IgdGhlIHJlcG9ydC4gT25lIG9mIGBzcGFtYCwgYHZvdGUtbWFuaXB1bGF0aW9uYCwgYHBlcnNvbmFsLWluZm9ybWF0aW9uYCxcbiAgYHNleHVhbGl6aW5nLW1pbm9yc2AsIGBzaXRlLWJyZWFraW5nYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgTGl2ZVRocmVhZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5yZXBvcnQoe3JlYXNvbjogJ0JyZWFraW5nIGEgcnVsZSBibGFoIGJsYWggYmxhaCd9KVxuICAqL1xuXG5cbiAgcmVwb3J0KF9yZWY4KSB7XG4gICAgdmFyIHJlYXNvbiA9IF9yZWY4LnJlYXNvbjtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwiYXBpL2xpdmUvXCIuY29uY2F0KHRoaXMuaWQsIFwiL3JlcG9ydFwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIHR5cGU6IHJlYXNvblxuICAgICAgfVxuICAgIH0pLnRoZW4oKDAsIF9oZWxwZXJzLmhhbmRsZUpzb25FcnJvcnMpKHRoaXMpKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBjb250YWluaW5nIHBhc3QgdXBkYXRlcyB0byB0aGlzIExpdmVUaHJlYWQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgTGl2ZVVwZGF0ZXNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5nZXRSZWNlbnRVcGRhdGVzKCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgTGl2ZVVwZGF0ZSB7IC4uLiB9LFxuICAqIC8vICBMaXZlVXBkYXRlIHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldFJlY2VudFVwZGF0ZXMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJsaXZlL1wiLmNvbmNhdCh0aGlzLmlkKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgcmVkZGl0IHN1Ym1pc3Npb25zIGxpbmtpbmcgdG8gdGhpcyBMaXZlVGhyZWFkLlxuICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIFN1Ym1pc3Npb25zXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0TGl2ZXRocmVhZCgnd2hyZHhvOGRnOW4wJykuZ2V0RGlzY3Vzc2lvbnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIFN1Ym1pc3Npb24geyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0RGlzY3Vzc2lvbnMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJsaXZlL1wiLmNvbmNhdCh0aGlzLmlkLCBcIi9kaXNjdXNzaW9uc1wiKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgU3RvcHMgbGlzdGVuaW5nIGZvciBuZXcgdXBkYXRlcyBvbiB0aGlzIExpdmVUaHJlYWQuXG4gICogQGRlc2MgVG8gYXZvaWQgbWVtb3J5IGxlYWtzIHRoYXQgY2FuIHJlc3VsdCBmcm9tIG9wZW4gc29ja2V0cywgaXQncyByZWNvbW1lbmRlZCB0aGF0IHlvdSBjYWxsIHRoaXMgbWV0aG9kIHdoZW4geW91J3JlXG4gIGZpbmlzaGVkIGxpc3RlbmluZyBmb3IgdXBkYXRlcyBvbiB0aGlzIExpdmVUaHJlYWQuXG4gICpcbiAgKiBUaGlzIHNob3VsZCBub3QgYmUgY29uZnVzZWQgd2l0aCB7QGxpbmsgTGl2ZVRocmVhZCNjbG9zZVRocmVhZH0sIHdoaWNoIG1hcmtzIHRoZSB0aHJlYWQgYXMgXCJjbG9zZWRcIiBvbiByZWRkaXQuXG4gICogQHJldHVybnMgdW5kZWZpbmVkXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHZhciBteVRocmVhZCA9IHIuZ2V0TGl2ZXRocmVhZCgnd2hyZHhvOGRnOW4wJyk7XG4gICogbXlUaHJlYWQuc3RyZWFtLm9uKCd1cGRhdGUnLCBjb250ZW50ID0+IHtcbiAgKiAgIGNvbnNvbGUubG9nKGNvbnRlbnQpO1xuICAqICAgbXlUaHJlYWQuY2xvc2VTdHJlYW0oKTtcbiAgKiB9KVxuICAqXG4gICovXG5cblxuICBjbG9zZVN0cmVhbSgpIHtcbiAgICBpZiAodGhpcy5fcmF3U3RyZWFtKSB7XG4gICAgICB0aGlzLl9yYXdTdHJlYW0uY2xvc2UoKTtcbiAgICB9XG4gIH1cblxufTtcbnZhciBfZGVmYXVsdCA9IExpdmVUaHJlYWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/LiveThread.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/ModmailConversation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/ModmailConversation.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = exports.modActionStates = exports.conversationStates = void 0;\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @global\n * @enum {number}\n * @readonly\n * @summary Represents the current status of a given Modmail conversation.\n * @type {Readonly<{New: number, InProgress: number, Archived: number}>}\n */\nvar conversationStates = Object.freeze({\n  New: 0,\n  InProgress: 1,\n  Archived: 2\n});\n/**\n * @global\n * @enum {number}\n * @readonly\n * @summary Represents all the possible states that is used within a Modmail conversations.\n * @type {Readonly<{UnArchive: number, Highlight: number, Archive: number, ReportedToAdmins: number, Mute: number, UnHighlight: number, Unmute: number}>}\n */\n\nexports.conversationStates = conversationStates;\nvar modActionStates = Object.freeze({\n  Highlight: 0,\n  UnHighlight: 1,\n  Archive: 2,\n  UnArchive: 3,\n  ReportedToAdmins: 4,\n  Mute: 5,\n  Unmute: 6\n});\n/**\n * @class\n * A class representing a conversation from new modmail\n * <style> #ModmailConversation {display: none} </style>\n * @name ModmailConversation\n * @example\n *\n * // Get a Modmail Conversation with a given ID\n * r.getNewModmailConversation('75hxt')\n * @extends RedditContent\n */\n\nexports.modActionStates = modActionStates;\nvar ModmailConversation = class ModmailConversation extends _RedditContent.default {\n  static get conversationStates() {\n    return conversationStates;\n  }\n\n  static get modActionStates() {\n    return modActionStates;\n  }\n\n  get _uri() {\n    return \"api/mod/conversations/\".concat(this.id, \"?markRead=false\");\n  }\n  /**\n   * @summary Converts relevant fields in the ModmailConversation to snoowrap models.\n   * @param response API Response\n   * @return {ModmailConversation}\n   * @private\n   */\n\n\n  _transformApiResponse(response) {\n    response.conversation.owner = this._r._newObject('Subreddit', {\n      id: response.conversation.owner.id,\n      display_name: response.conversation.owner.displayName\n    });\n    response.conversation.participant = this._r._newObject('ModmailConversationAuthor', response.user.name, true);\n\n    for (var author of response.conversation.authors) {\n      author = this._r._newObject('ModmailConversationAuthor', author, true);\n    }\n\n    var conversationObjects = ModmailConversation._getConversationObjects(response.conversation, response);\n\n    return this._r._newObject('ModmailConversation', _objectSpread({}, conversationObjects, {}, response.conversation), true);\n  }\n  /**\n   * @summary Maps objects to the ModmailConversation\n   * @param conversation The conversation to map objects to\n   * @param response API Response\n   * @return {object}\n   * @private\n   */\n\n\n  static _getConversationObjects(conversation, response) {\n    var conversationObjects = {};\n\n    for (var objId of conversation.objIds) {\n      if (!conversationObjects[objId.key]) {\n        conversationObjects[objId.key] = [];\n      }\n\n      conversationObjects[objId.key].push(response[objId.key][objId.id]);\n    }\n\n    return conversationObjects;\n  }\n  /**\n   * @summary Reply to current ModmailConversation\n   * @param {string} body Markdown text\n   * @param {boolean} isAuthorHidden Subreddit-name reply if true, user's name if false\n   * @param {boolean} isInternal If reply should be to internal moderators only\n   * @return {Promise}\n   */\n\n\n  reply(body) {\n    var isAuthorHidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return this._post({\n      uri: \"api/mod/conversations/\".concat(this.id),\n      form: {\n        body,\n        isAuthorHidden,\n        isInternal\n      }\n    });\n  }\n  /**\n   * @summary Archives the ModmailConversation\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').archive()\n   */\n\n\n  archive() {\n    return this._post({\n      uri: \"api/mod/conversations/\".concat(this.id, \"/archive\")\n    });\n  }\n  /**\n   * @summary Unarchives the ModmailConversation\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').unarchive()\n   */\n\n\n  unarchive() {\n    return this._post({\n      uri: \"api/mod/conversations/\".concat(this.id, \"/unarchive\")\n    });\n  }\n  /**\n   * @summary Marks a ModmailConversation as highlighted\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').highlight()\n   */\n\n\n  highlight() {\n    return this._post({\n      uri: \"api/mod/conversations/\".concat(this.id, \"/highlight\")\n    });\n  }\n  /**\n   * @summary Removed highlighted from a ModmailConversation\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').unhighlight()\n   */\n\n\n  unhighlight() {\n    return this._delete({\n      uri: \"api/mod/conversations/\".concat(this.id, \"/highlight\")\n    });\n  }\n  /**\n   * @summary Mute the participant of the ModmailConversation\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').mute()\n   */\n\n\n  mute() {\n    return this._post({\n      uri: \"api/mod/conversations/\".concat(this.id, \"/mute\")\n    });\n  }\n  /**\n   * @summary Unmute the participant of the ModmailConversation\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').unmute()\n   */\n\n\n  unmute() {\n    return this._post({\n      uri: \"api/mod/conversations/\".concat(this.id, \"/unmute\")\n    });\n  }\n  /**\n   * @summary Marks the ModmailConversation as read\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').read()\n   */\n\n\n  read() {\n    return this._r.markNewModmailConversationsAsRead([this.id]);\n  }\n  /**\n   * @summary Marks the ModmailConversation as unread\n   * @return {Promise}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').unread()\n   */\n\n\n  unread() {\n    return this._r.markNewModmailConversationsAsUnread([this.id]);\n  }\n  /**\n   * @summary Fetches the participant of the conversation\n   * @return {Promise<ModmailConversationAuthor>}\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').getParticipant().then(console.log)\n   * // ModmailConversationAuthor { muteStatus: {...}, name: \"SpyTec13\", created: '2015-11-22T14:30:38.821292+00:00', ...}\n   */\n\n\n  getParticipant() {\n    var _this = this;\n\n    return this._get({\n      uri: \"api/mod/conversations/\".concat(this.id, \"/user\")\n    }).then(function (res) {\n      return _this._r._newObject('ModmailConversationAuthor', res, true);\n    });\n  }\n  /**\n   * @summary Returns whether the ModmailConversation is read.\n   * @return {boolean} true, if read. false otherwise\n   */\n\n\n  isRead() {\n    return this.lastUnread === null;\n  }\n\n  get name() {\n    return this.id;\n  }\n\n};\nvar _default = ModmailConversation;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL01vZG1haWxDb252ZXJzYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWUsR0FBRyx1QkFBdUIsR0FBRywwQkFBMEI7O0FBRXRFLDRDQUE0QyxtQkFBTyxDQUFDLHVGQUFvQjs7QUFFeEUsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxpRUFBaUUsR0FBRyxrQ0FBa0M7O0FBRXZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsK0NBQStDLDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyx5Q0FBeUMsbUZBQW1GLE9BQU87O0FBRXRmLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVwTTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVLFVBQVUsa0RBQWtEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSxVQUFVLG1JQUFtSTtBQUN2Sjs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUVBQXFFLHlCQUF5QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhLElBQUk7QUFDckQ7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL2Rpc3Qvb2JqZWN0cy9Nb2RtYWlsQ29udmVyc2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5tb2RBY3Rpb25TdGF0ZXMgPSBleHBvcnRzLmNvbnZlcnNhdGlvblN0YXRlcyA9IHZvaWQgMDtcblxudmFyIF9SZWRkaXRDb250ZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZWRkaXRDb250ZW50LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBAZ2xvYmFsXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQHJlYWRvbmx5XG4gKiBAc3VtbWFyeSBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIGdpdmVuIE1vZG1haWwgY29udmVyc2F0aW9uLlxuICogQHR5cGUge1JlYWRvbmx5PHtOZXc6IG51bWJlciwgSW5Qcm9ncmVzczogbnVtYmVyLCBBcmNoaXZlZDogbnVtYmVyfT59XG4gKi9cbnZhciBjb252ZXJzYXRpb25TdGF0ZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgTmV3OiAwLFxuICBJblByb2dyZXNzOiAxLFxuICBBcmNoaXZlZDogMlxufSk7XG4vKipcbiAqIEBnbG9iYWxcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAcmVhZG9ubHlcbiAqIEBzdW1tYXJ5IFJlcHJlc2VudHMgYWxsIHRoZSBwb3NzaWJsZSBzdGF0ZXMgdGhhdCBpcyB1c2VkIHdpdGhpbiBhIE1vZG1haWwgY29udmVyc2F0aW9ucy5cbiAqIEB0eXBlIHtSZWFkb25seTx7VW5BcmNoaXZlOiBudW1iZXIsIEhpZ2hsaWdodDogbnVtYmVyLCBBcmNoaXZlOiBudW1iZXIsIFJlcG9ydGVkVG9BZG1pbnM6IG51bWJlciwgTXV0ZTogbnVtYmVyLCBVbkhpZ2hsaWdodDogbnVtYmVyLCBVbm11dGU6IG51bWJlcn0+fVxuICovXG5cbmV4cG9ydHMuY29udmVyc2F0aW9uU3RhdGVzID0gY29udmVyc2F0aW9uU3RhdGVzO1xudmFyIG1vZEFjdGlvblN0YXRlcyA9IE9iamVjdC5mcmVlemUoe1xuICBIaWdobGlnaHQ6IDAsXG4gIFVuSGlnaGxpZ2h0OiAxLFxuICBBcmNoaXZlOiAyLFxuICBVbkFyY2hpdmU6IDMsXG4gIFJlcG9ydGVkVG9BZG1pbnM6IDQsXG4gIE11dGU6IDUsXG4gIFVubXV0ZTogNlxufSk7XG4vKipcbiAqIEBjbGFzc1xuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBjb252ZXJzYXRpb24gZnJvbSBuZXcgbW9kbWFpbFxuICogPHN0eWxlPiAjTW9kbWFpbENvbnZlcnNhdGlvbiB7ZGlzcGxheTogbm9uZX0gPC9zdHlsZT5cbiAqIEBuYW1lIE1vZG1haWxDb252ZXJzYXRpb25cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gR2V0IGEgTW9kbWFpbCBDb252ZXJzYXRpb24gd2l0aCBhIGdpdmVuIElEXG4gKiByLmdldE5ld01vZG1haWxDb252ZXJzYXRpb24oJzc1aHh0JylcbiAqIEBleHRlbmRzIFJlZGRpdENvbnRlbnRcbiAqL1xuXG5leHBvcnRzLm1vZEFjdGlvblN0YXRlcyA9IG1vZEFjdGlvblN0YXRlcztcbnZhciBNb2RtYWlsQ29udmVyc2F0aW9uID0gY2xhc3MgTW9kbWFpbENvbnZlcnNhdGlvbiBleHRlbmRzIF9SZWRkaXRDb250ZW50LmRlZmF1bHQge1xuICBzdGF0aWMgZ2V0IGNvbnZlcnNhdGlvblN0YXRlcygpIHtcbiAgICByZXR1cm4gY29udmVyc2F0aW9uU3RhdGVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBtb2RBY3Rpb25TdGF0ZXMoKSB7XG4gICAgcmV0dXJuIG1vZEFjdGlvblN0YXRlcztcbiAgfVxuXG4gIGdldCBfdXJpKCkge1xuICAgIHJldHVybiBcImFwaS9tb2QvY29udmVyc2F0aW9ucy9cIi5jb25jYXQodGhpcy5pZCwgXCI/bWFya1JlYWQ9ZmFsc2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENvbnZlcnRzIHJlbGV2YW50IGZpZWxkcyBpbiB0aGUgTW9kbWFpbENvbnZlcnNhdGlvbiB0byBzbm9vd3JhcCBtb2RlbHMuXG4gICAqIEBwYXJhbSByZXNwb25zZSBBUEkgUmVzcG9uc2VcbiAgICogQHJldHVybiB7TW9kbWFpbENvbnZlcnNhdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBfdHJhbnNmb3JtQXBpUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXNwb25zZS5jb252ZXJzYXRpb24ub3duZXIgPSB0aGlzLl9yLl9uZXdPYmplY3QoJ1N1YnJlZGRpdCcsIHtcbiAgICAgIGlkOiByZXNwb25zZS5jb252ZXJzYXRpb24ub3duZXIuaWQsXG4gICAgICBkaXNwbGF5X25hbWU6IHJlc3BvbnNlLmNvbnZlcnNhdGlvbi5vd25lci5kaXNwbGF5TmFtZVxuICAgIH0pO1xuICAgIHJlc3BvbnNlLmNvbnZlcnNhdGlvbi5wYXJ0aWNpcGFudCA9IHRoaXMuX3IuX25ld09iamVjdCgnTW9kbWFpbENvbnZlcnNhdGlvbkF1dGhvcicsIHJlc3BvbnNlLnVzZXIubmFtZSwgdHJ1ZSk7XG5cbiAgICBmb3IgKHZhciBhdXRob3Igb2YgcmVzcG9uc2UuY29udmVyc2F0aW9uLmF1dGhvcnMpIHtcbiAgICAgIGF1dGhvciA9IHRoaXMuX3IuX25ld09iamVjdCgnTW9kbWFpbENvbnZlcnNhdGlvbkF1dGhvcicsIGF1dGhvciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnZlcnNhdGlvbk9iamVjdHMgPSBNb2RtYWlsQ29udmVyc2F0aW9uLl9nZXRDb252ZXJzYXRpb25PYmplY3RzKHJlc3BvbnNlLmNvbnZlcnNhdGlvbiwgcmVzcG9uc2UpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3IuX25ld09iamVjdCgnTW9kbWFpbENvbnZlcnNhdGlvbicsIF9vYmplY3RTcHJlYWQoe30sIGNvbnZlcnNhdGlvbk9iamVjdHMsIHt9LCByZXNwb25zZS5jb252ZXJzYXRpb24pLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgTWFwcyBvYmplY3RzIHRvIHRoZSBNb2RtYWlsQ29udmVyc2F0aW9uXG4gICAqIEBwYXJhbSBjb252ZXJzYXRpb24gVGhlIGNvbnZlcnNhdGlvbiB0byBtYXAgb2JqZWN0cyB0b1xuICAgKiBAcGFyYW0gcmVzcG9uc2UgQVBJIFJlc3BvbnNlXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBzdGF0aWMgX2dldENvbnZlcnNhdGlvbk9iamVjdHMoY29udmVyc2F0aW9uLCByZXNwb25zZSkge1xuICAgIHZhciBjb252ZXJzYXRpb25PYmplY3RzID0ge307XG5cbiAgICBmb3IgKHZhciBvYmpJZCBvZiBjb252ZXJzYXRpb24ub2JqSWRzKSB7XG4gICAgICBpZiAoIWNvbnZlcnNhdGlvbk9iamVjdHNbb2JqSWQua2V5XSkge1xuICAgICAgICBjb252ZXJzYXRpb25PYmplY3RzW29iaklkLmtleV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgY29udmVyc2F0aW9uT2JqZWN0c1tvYmpJZC5rZXldLnB1c2gocmVzcG9uc2Vbb2JqSWQua2V5XVtvYmpJZC5pZF0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJzYXRpb25PYmplY3RzO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXBseSB0byBjdXJyZW50IE1vZG1haWxDb252ZXJzYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgTWFya2Rvd24gdGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQXV0aG9ySGlkZGVuIFN1YnJlZGRpdC1uYW1lIHJlcGx5IGlmIHRydWUsIHVzZXIncyBuYW1lIGlmIGZhbHNlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNJbnRlcm5hbCBJZiByZXBseSBzaG91bGQgYmUgdG8gaW50ZXJuYWwgbW9kZXJhdG9ycyBvbmx5XG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgcmVwbHkoYm9keSkge1xuICAgIHZhciBpc0F1dGhvckhpZGRlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIGlzSW50ZXJuYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJhcGkvbW9kL2NvbnZlcnNhdGlvbnMvXCIuY29uY2F0KHRoaXMuaWQpLFxuICAgICAgZm9ybToge1xuICAgICAgICBib2R5LFxuICAgICAgICBpc0F1dGhvckhpZGRlbixcbiAgICAgICAgaXNJbnRlcm5hbFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBBcmNoaXZlcyB0aGUgTW9kbWFpbENvbnZlcnNhdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE5ld01vZG1haWxDb252ZXJzYXRpb24oJzc1aHh0JykuYXJjaGl2ZSgpXG4gICAqL1xuXG5cbiAgYXJjaGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwiYXBpL21vZC9jb252ZXJzYXRpb25zL1wiLmNvbmNhdCh0aGlzLmlkLCBcIi9hcmNoaXZlXCIpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFVuYXJjaGl2ZXMgdGhlIE1vZG1haWxDb252ZXJzYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXROZXdNb2RtYWlsQ29udmVyc2F0aW9uKCc3NWh4dCcpLnVuYXJjaGl2ZSgpXG4gICAqL1xuXG5cbiAgdW5hcmNoaXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJhcGkvbW9kL2NvbnZlcnNhdGlvbnMvXCIuY29uY2F0KHRoaXMuaWQsIFwiL3VuYXJjaGl2ZVwiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBNYXJrcyBhIE1vZG1haWxDb252ZXJzYXRpb24gYXMgaGlnaGxpZ2h0ZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXROZXdNb2RtYWlsQ29udmVyc2F0aW9uKCc3NWh4dCcpLmhpZ2hsaWdodCgpXG4gICAqL1xuXG5cbiAgaGlnaGxpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJhcGkvbW9kL2NvbnZlcnNhdGlvbnMvXCIuY29uY2F0KHRoaXMuaWQsIFwiL2hpZ2hsaWdodFwiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZW1vdmVkIGhpZ2hsaWdodGVkIGZyb20gYSBNb2RtYWlsQ29udmVyc2F0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0TmV3TW9kbWFpbENvbnZlcnNhdGlvbignNzVoeHQnKS51bmhpZ2hsaWdodCgpXG4gICAqL1xuXG5cbiAgdW5oaWdobGlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGV0ZSh7XG4gICAgICB1cmk6IFwiYXBpL21vZC9jb252ZXJzYXRpb25zL1wiLmNvbmNhdCh0aGlzLmlkLCBcIi9oaWdobGlnaHRcIilcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgTXV0ZSB0aGUgcGFydGljaXBhbnQgb2YgdGhlIE1vZG1haWxDb252ZXJzYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXROZXdNb2RtYWlsQ29udmVyc2F0aW9uKCc3NWh4dCcpLm11dGUoKVxuICAgKi9cblxuXG4gIG11dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcImFwaS9tb2QvY29udmVyc2F0aW9ucy9cIi5jb25jYXQodGhpcy5pZCwgXCIvbXV0ZVwiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBVbm11dGUgdGhlIHBhcnRpY2lwYW50IG9mIHRoZSBNb2RtYWlsQ29udmVyc2F0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0TmV3TW9kbWFpbENvbnZlcnNhdGlvbignNzVoeHQnKS51bm11dGUoKVxuICAgKi9cblxuXG4gIHVubXV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwiYXBpL21vZC9jb252ZXJzYXRpb25zL1wiLmNvbmNhdCh0aGlzLmlkLCBcIi91bm11dGVcIilcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgTWFya3MgdGhlIE1vZG1haWxDb252ZXJzYXRpb24gYXMgcmVhZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE5ld01vZG1haWxDb252ZXJzYXRpb24oJzc1aHh0JykucmVhZCgpXG4gICAqL1xuXG5cbiAgcmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fci5tYXJrTmV3TW9kbWFpbENvbnZlcnNhdGlvbnNBc1JlYWQoW3RoaXMuaWRdKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgTWFya3MgdGhlIE1vZG1haWxDb252ZXJzYXRpb24gYXMgdW5yZWFkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0TmV3TW9kbWFpbENvbnZlcnNhdGlvbignNzVoeHQnKS51bnJlYWQoKVxuICAgKi9cblxuXG4gIHVucmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fci5tYXJrTmV3TW9kbWFpbENvbnZlcnNhdGlvbnNBc1VucmVhZChbdGhpcy5pZF0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBGZXRjaGVzIHRoZSBwYXJ0aWNpcGFudCBvZiB0aGUgY29udmVyc2F0aW9uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TW9kbWFpbENvbnZlcnNhdGlvbkF1dGhvcj59XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0TmV3TW9kbWFpbENvbnZlcnNhdGlvbignNzVoeHQnKS5nZXRQYXJ0aWNpcGFudCgpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vIE1vZG1haWxDb252ZXJzYXRpb25BdXRob3IgeyBtdXRlU3RhdHVzOiB7Li4ufSwgbmFtZTogXCJTcHlUZWMxM1wiLCBjcmVhdGVkOiAnMjAxNS0xMS0yMlQxNDozMDozOC44MjEyOTIrMDA6MDAnLCAuLi59XG4gICAqL1xuXG5cbiAgZ2V0UGFydGljaXBhbnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiBcImFwaS9tb2QvY29udmVyc2F0aW9ucy9cIi5jb25jYXQodGhpcy5pZCwgXCIvdXNlclwiKVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgcmV0dXJuIF90aGlzLl9yLl9uZXdPYmplY3QoJ01vZG1haWxDb252ZXJzYXRpb25BdXRob3InLCByZXMsIHRydWUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXR1cm5zIHdoZXRoZXIgdGhlIE1vZG1haWxDb252ZXJzYXRpb24gaXMgcmVhZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSwgaWYgcmVhZC4gZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuXG5cbiAgaXNSZWFkKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RVbnJlYWQgPT09IG51bGw7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuXG59O1xudmFyIF9kZWZhdWx0ID0gTW9kbWFpbENvbnZlcnNhdGlvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/ModmailConversation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/More.js":
/*!****************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/More.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = exports.emptyChildren = void 0;\n\nvar _lodash = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ../Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _constants = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/snoowrap/dist/constants.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar api_type = 'json';\n/**\n* The `More` class is a helper representing reddit's exposed `more` type in comment threads, used to fetch additional comments\non a thread.\n* No instances of the `More` class are exposed externally by snoowrap; instead, comment lists are exposed as Listings.\nAdditional replies on an item can be fetched by calling `fetchMore` on a Listing, in the same manner as what would be done\nwith a Listing of posts. snoowrap should handle the differences internally, and expose a nearly-identical interface for the\ntwo use-cases.\n\nCombining reddit's `Listing` and `more` objects has the advantage of having a more consistent exposed interface; for example,\nif a consumer iterates over the comments on a Submission, all of the iterated items will actually be Comment objects, so the\nconsumer won't encounter an unexpected `more` object at the end. However, there are a few disadvantages, namely that (a) this\nleads to an increase in internal complexity, and (b) there are a few cases where reddit's `more` objects have different amounts\nof available information (e.g. all the child IDs of a `more` object are known on creation), which leads to different optimal\nbehavior.\n*/\n\nvar More = class More {\n  constructor(options, _r) {\n    Object.assign(this, options);\n    this._r = _r;\n  }\n  /* Requests to /api/morechildren are capped at 20 comments at a time, but requests to /api/info are capped at 100, so\n  it's easier to send to the latter. The disadvantage is that comment replies are not automatically sent from requests\n  to /api/info. */\n\n\n  fetchMore(options) {\n    var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (options.amount <= 0 || startIndex >= this.children.length) {\n      return _Promise.default.resolve([]);\n    }\n\n    if (!options.skipReplies) {\n      return this.fetchTree(options, startIndex);\n    }\n\n    var ids = getNextIdSlice(this.children, startIndex, options.amount, _constants.MAX_API_INFO_AMOUNT).map(function (id) {\n      return \"t1_\".concat(id);\n    }); // Requests are capped at 100 comments. Send lots of requests recursively to get the comments, then concatenate them.\n    // (This speed-requesting is only possible with comment Listings since the entire list of ids is present initially.)\n\n    var promiseForThisBatch = this._r._getListing({\n      uri: 'api/info',\n      qs: {\n        id: ids.join(',')\n      }\n    });\n\n    var nextRequestOptions = _objectSpread({}, options, {\n      amount: options.amount - ids.length\n    });\n\n    var promiseForRemainingItems = this.fetchMore(nextRequestOptions, startIndex + ids.length);\n    return _Promise.default.all([promiseForThisBatch, promiseForRemainingItems]).then(_lodash.flatten);\n  }\n\n  fetchTree(options, startIndex) {\n    var _this = this;\n\n    if (options.amount <= 0 || startIndex >= this.children.length) {\n      return _Promise.default.resolve([]);\n    }\n\n    var ids = getNextIdSlice(this.children, startIndex, options.amount, _constants.MAX_API_MORECHILDREN_AMOUNT);\n    return this._r._get({\n      uri: 'api/morechildren',\n      qs: {\n        api_type,\n        children: ids.join(','),\n        link_id: this.link_id || this.parent_id\n      }\n    }).tap(_helpers.handleJsonErrors).then(function (res) {\n      return res.json.data.things;\n    }).map(_helpers.addEmptyRepliesListing).then(_helpers.buildRepliesTree).then(function (resultTrees) {\n      /* Sometimes, when sending a request to reddit to get multiple comments from a `more` object, reddit decides to only\n      send some of the requested comments, and then stub out the remaining ones in a smaller `more` object. ( ¯\\_(ツ)_/¯ )\n      In these cases, recursively fetch the smaller `more` objects as well. */\n      var childMores = (0, _lodash.remove)(resultTrees, function (c) {\n        return c instanceof More;\n      });\n      (0, _lodash.forEach)(childMores, function (c) {\n        c.link_id = _this.link_id || _this.parent_id;\n      });\n      return _Promise.default.mapSeries(childMores, function (c) {\n        return c.fetchTree(_objectSpread({}, options, {\n          amount: Infinity\n        }), 0);\n      }).then(function (expandedTrees) {\n        return _this.fetchMore(_objectSpread({}, options, {\n          amount: options.amount - ids.length\n        }), startIndex + ids.length).then(function (nexts) {\n          return (0, _lodash.concat)(resultTrees, (0, _lodash.flatten)(expandedTrees), nexts);\n        });\n      });\n    });\n  }\n\n  _clone() {\n    return new More((0, _lodash.pick)(this, Object.getOwnPropertyNames(this)), this._r);\n  }\n\n};\n\nfunction getNextIdSlice(children, startIndex, desiredAmount, limit) {\n  return children.slice(startIndex, startIndex + Math.min(desiredAmount, limit));\n}\n\nvar emptyChildren = new More({\n  children: []\n});\nexports.emptyChildren = emptyChildren;\nvar _default = More;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL01vcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWUsR0FBRyxxQkFBcUI7O0FBRXZDLGNBQWMsbUJBQU8sQ0FBQyxxREFBUTs7QUFFOUIsc0NBQXNDLG1CQUFPLENBQUMsb0VBQWU7O0FBRTdELGVBQWUsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFdEMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWlCOztBQUUxQyx1Q0FBdUMsdUNBQXVDOztBQUU5RSwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsOERBQThELGlFQUFpRSxHQUFHLGtDQUFrQzs7QUFFdlUsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSwrQ0FBK0MsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLHlDQUF5QyxtRkFBbUYsT0FBTzs7QUFFdGYsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNkNBQTZDO0FBQzdDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLCtDQUErQztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUI7QUFDckI7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L29iamVjdHMvTW9yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZW1wdHlDaGlsZHJlbiA9IHZvaWQgMDtcblxudmFyIF9sb2Rhc2ggPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuXG52YXIgX1Byb21pc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9Qcm9taXNlLmpzXCIpKTtcblxudmFyIF9oZWxwZXJzID0gcmVxdWlyZShcIi4uL2hlbHBlcnMuanNcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy5qc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGFwaV90eXBlID0gJ2pzb24nO1xuLyoqXG4qIFRoZSBgTW9yZWAgY2xhc3MgaXMgYSBoZWxwZXIgcmVwcmVzZW50aW5nIHJlZGRpdCdzIGV4cG9zZWQgYG1vcmVgIHR5cGUgaW4gY29tbWVudCB0aHJlYWRzLCB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgY29tbWVudHNcbm9uIGEgdGhyZWFkLlxuKiBObyBpbnN0YW5jZXMgb2YgdGhlIGBNb3JlYCBjbGFzcyBhcmUgZXhwb3NlZCBleHRlcm5hbGx5IGJ5IHNub293cmFwOyBpbnN0ZWFkLCBjb21tZW50IGxpc3RzIGFyZSBleHBvc2VkIGFzIExpc3RpbmdzLlxuQWRkaXRpb25hbCByZXBsaWVzIG9uIGFuIGl0ZW0gY2FuIGJlIGZldGNoZWQgYnkgY2FsbGluZyBgZmV0Y2hNb3JlYCBvbiBhIExpc3RpbmcsIGluIHRoZSBzYW1lIG1hbm5lciBhcyB3aGF0IHdvdWxkIGJlIGRvbmVcbndpdGggYSBMaXN0aW5nIG9mIHBvc3RzLiBzbm9vd3JhcCBzaG91bGQgaGFuZGxlIHRoZSBkaWZmZXJlbmNlcyBpbnRlcm5hbGx5LCBhbmQgZXhwb3NlIGEgbmVhcmx5LWlkZW50aWNhbCBpbnRlcmZhY2UgZm9yIHRoZVxudHdvIHVzZS1jYXNlcy5cblxuQ29tYmluaW5nIHJlZGRpdCdzIGBMaXN0aW5nYCBhbmQgYG1vcmVgIG9iamVjdHMgaGFzIHRoZSBhZHZhbnRhZ2Ugb2YgaGF2aW5nIGEgbW9yZSBjb25zaXN0ZW50IGV4cG9zZWQgaW50ZXJmYWNlOyBmb3IgZXhhbXBsZSxcbmlmIGEgY29uc3VtZXIgaXRlcmF0ZXMgb3ZlciB0aGUgY29tbWVudHMgb24gYSBTdWJtaXNzaW9uLCBhbGwgb2YgdGhlIGl0ZXJhdGVkIGl0ZW1zIHdpbGwgYWN0dWFsbHkgYmUgQ29tbWVudCBvYmplY3RzLCBzbyB0aGVcbmNvbnN1bWVyIHdvbid0IGVuY291bnRlciBhbiB1bmV4cGVjdGVkIGBtb3JlYCBvYmplY3QgYXQgdGhlIGVuZC4gSG93ZXZlciwgdGhlcmUgYXJlIGEgZmV3IGRpc2FkdmFudGFnZXMsIG5hbWVseSB0aGF0IChhKSB0aGlzXG5sZWFkcyB0byBhbiBpbmNyZWFzZSBpbiBpbnRlcm5hbCBjb21wbGV4aXR5LCBhbmQgKGIpIHRoZXJlIGFyZSBhIGZldyBjYXNlcyB3aGVyZSByZWRkaXQncyBgbW9yZWAgb2JqZWN0cyBoYXZlIGRpZmZlcmVudCBhbW91bnRzXG5vZiBhdmFpbGFibGUgaW5mb3JtYXRpb24gKGUuZy4gYWxsIHRoZSBjaGlsZCBJRHMgb2YgYSBgbW9yZWAgb2JqZWN0IGFyZSBrbm93biBvbiBjcmVhdGlvbiksIHdoaWNoIGxlYWRzIHRvIGRpZmZlcmVudCBvcHRpbWFsXG5iZWhhdmlvci5cbiovXG5cbnZhciBNb3JlID0gY2xhc3MgTW9yZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIF9yKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9yID0gX3I7XG4gIH1cbiAgLyogUmVxdWVzdHMgdG8gL2FwaS9tb3JlY2hpbGRyZW4gYXJlIGNhcHBlZCBhdCAyMCBjb21tZW50cyBhdCBhIHRpbWUsIGJ1dCByZXF1ZXN0cyB0byAvYXBpL2luZm8gYXJlIGNhcHBlZCBhdCAxMDAsIHNvXG4gIGl0J3MgZWFzaWVyIHRvIHNlbmQgdG8gdGhlIGxhdHRlci4gVGhlIGRpc2FkdmFudGFnZSBpcyB0aGF0IGNvbW1lbnQgcmVwbGllcyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgc2VudCBmcm9tIHJlcXVlc3RzXG4gIHRvIC9hcGkvaW5mby4gKi9cblxuXG4gIGZldGNoTW9yZShvcHRpb25zKSB7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICBpZiAob3B0aW9ucy5hbW91bnQgPD0gMCB8fCBzdGFydEluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuc2tpcFJlcGxpZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoVHJlZShvcHRpb25zLCBzdGFydEluZGV4KTtcbiAgICB9XG5cbiAgICB2YXIgaWRzID0gZ2V0TmV4dElkU2xpY2UodGhpcy5jaGlsZHJlbiwgc3RhcnRJbmRleCwgb3B0aW9ucy5hbW91bnQsIF9jb25zdGFudHMuTUFYX0FQSV9JTkZPX0FNT1VOVCkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIFwidDFfXCIuY29uY2F0KGlkKTtcbiAgICB9KTsgLy8gUmVxdWVzdHMgYXJlIGNhcHBlZCBhdCAxMDAgY29tbWVudHMuIFNlbmQgbG90cyBvZiByZXF1ZXN0cyByZWN1cnNpdmVseSB0byBnZXQgdGhlIGNvbW1lbnRzLCB0aGVuIGNvbmNhdGVuYXRlIHRoZW0uXG4gICAgLy8gKFRoaXMgc3BlZWQtcmVxdWVzdGluZyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggY29tbWVudCBMaXN0aW5ncyBzaW5jZSB0aGUgZW50aXJlIGxpc3Qgb2YgaWRzIGlzIHByZXNlbnQgaW5pdGlhbGx5LilcblxuICAgIHZhciBwcm9taXNlRm9yVGhpc0JhdGNoID0gdGhpcy5fci5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6ICdhcGkvaW5mbycsXG4gICAgICBxczoge1xuICAgICAgICBpZDogaWRzLmpvaW4oJywnKVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG5leHRSZXF1ZXN0T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFtb3VudDogb3B0aW9ucy5hbW91bnQgLSBpZHMubGVuZ3RoXG4gICAgfSk7XG5cbiAgICB2YXIgcHJvbWlzZUZvclJlbWFpbmluZ0l0ZW1zID0gdGhpcy5mZXRjaE1vcmUobmV4dFJlcXVlc3RPcHRpb25zLCBzdGFydEluZGV4ICsgaWRzLmxlbmd0aCk7XG4gICAgcmV0dXJuIF9Qcm9taXNlLmRlZmF1bHQuYWxsKFtwcm9taXNlRm9yVGhpc0JhdGNoLCBwcm9taXNlRm9yUmVtYWluaW5nSXRlbXNdKS50aGVuKF9sb2Rhc2guZmxhdHRlbik7XG4gIH1cblxuICBmZXRjaFRyZWUob3B0aW9ucywgc3RhcnRJbmRleCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucy5hbW91bnQgPD0gMCB8fCBzdGFydEluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICB2YXIgaWRzID0gZ2V0TmV4dElkU2xpY2UodGhpcy5jaGlsZHJlbiwgc3RhcnRJbmRleCwgb3B0aW9ucy5hbW91bnQsIF9jb25zdGFudHMuTUFYX0FQSV9NT1JFQ0hJTERSRU5fQU1PVU5UKTtcbiAgICByZXR1cm4gdGhpcy5fci5fZ2V0KHtcbiAgICAgIHVyaTogJ2FwaS9tb3JlY2hpbGRyZW4nLFxuICAgICAgcXM6IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIGNoaWxkcmVuOiBpZHMuam9pbignLCcpLFxuICAgICAgICBsaW5rX2lkOiB0aGlzLmxpbmtfaWQgfHwgdGhpcy5wYXJlbnRfaWRcbiAgICAgIH1cbiAgICB9KS50YXAoX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICByZXR1cm4gcmVzLmpzb24uZGF0YS50aGluZ3M7XG4gICAgfSkubWFwKF9oZWxwZXJzLmFkZEVtcHR5UmVwbGllc0xpc3RpbmcpLnRoZW4oX2hlbHBlcnMuYnVpbGRSZXBsaWVzVHJlZSkudGhlbihmdW5jdGlvbiAocmVzdWx0VHJlZXMpIHtcbiAgICAgIC8qIFNvbWV0aW1lcywgd2hlbiBzZW5kaW5nIGEgcmVxdWVzdCB0byByZWRkaXQgdG8gZ2V0IG11bHRpcGxlIGNvbW1lbnRzIGZyb20gYSBgbW9yZWAgb2JqZWN0LCByZWRkaXQgZGVjaWRlcyB0byBvbmx5XG4gICAgICBzZW5kIHNvbWUgb2YgdGhlIHJlcXVlc3RlZCBjb21tZW50cywgYW5kIHRoZW4gc3R1YiBvdXQgdGhlIHJlbWFpbmluZyBvbmVzIGluIGEgc21hbGxlciBgbW9yZWAgb2JqZWN0LiAoIMKvXFxfKOODhClfL8KvIClcbiAgICAgIEluIHRoZXNlIGNhc2VzLCByZWN1cnNpdmVseSBmZXRjaCB0aGUgc21hbGxlciBgbW9yZWAgb2JqZWN0cyBhcyB3ZWxsLiAqL1xuICAgICAgdmFyIGNoaWxkTW9yZXMgPSAoMCwgX2xvZGFzaC5yZW1vdmUpKHJlc3VsdFRyZWVzLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyBpbnN0YW5jZW9mIE1vcmU7XG4gICAgICB9KTtcbiAgICAgICgwLCBfbG9kYXNoLmZvckVhY2gpKGNoaWxkTW9yZXMsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGMubGlua19pZCA9IF90aGlzLmxpbmtfaWQgfHwgX3RoaXMucGFyZW50X2lkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5tYXBTZXJpZXMoY2hpbGRNb3JlcywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMuZmV0Y2hUcmVlKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICBhbW91bnQ6IEluZmluaXR5XG4gICAgICAgIH0pLCAwKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGV4cGFuZGVkVHJlZXMpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoTW9yZShfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgYW1vdW50OiBvcHRpb25zLmFtb3VudCAtIGlkcy5sZW5ndGhcbiAgICAgICAgfSksIHN0YXJ0SW5kZXggKyBpZHMubGVuZ3RoKS50aGVuKGZ1bmN0aW9uIChuZXh0cykge1xuICAgICAgICAgIHJldHVybiAoMCwgX2xvZGFzaC5jb25jYXQpKHJlc3VsdFRyZWVzLCAoMCwgX2xvZGFzaC5mbGF0dGVuKShleHBhbmRlZFRyZWVzKSwgbmV4dHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX2Nsb25lKCkge1xuICAgIHJldHVybiBuZXcgTW9yZSgoMCwgX2xvZGFzaC5waWNrKSh0aGlzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSksIHRoaXMuX3IpO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGdldE5leHRJZFNsaWNlKGNoaWxkcmVuLCBzdGFydEluZGV4LCBkZXNpcmVkQW1vdW50LCBsaW1pdCkge1xuICByZXR1cm4gY2hpbGRyZW4uc2xpY2Uoc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIE1hdGgubWluKGRlc2lyZWRBbW91bnQsIGxpbWl0KSk7XG59XG5cbnZhciBlbXB0eUNoaWxkcmVuID0gbmV3IE1vcmUoe1xuICBjaGlsZHJlbjogW11cbn0pO1xuZXhwb3J0cy5lbXB0eUNoaWxkcmVuID0gZW1wdHlDaGlsZHJlbjtcbnZhciBfZGVmYXVsdCA9IE1vcmU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/More.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/MultiReddit.js":
/*!***********************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/MultiReddit.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* @summary A class representing a multireddit.\n* <style> #MultiReddit {display: none} </style>\n* @example\n*\n* // Get a multireddit belonging to a specific user\n* r.getUser('multi-mod').getMultireddit('coding_languages')\n*/\nvar MultiReddit = class MultiReddit extends _RedditContent.default {\n  constructor(options, _r, _hasFetched) {\n    var _this;\n\n    super(options, _r, _hasFetched);\n    _this = this;\n\n    if (_hasFetched) {\n      this.curator = _r.getUser(this.path.split('/')[2]);\n      this.subreddits = this.subreddits.map(function (item) {\n        return _this._r._newObject('Subreddit', item.data || {\n          display_name: item.name\n        });\n      });\n    }\n  }\n\n  get _uri() {\n    return \"api/multi\".concat(this._path, \"?expand_srs=true\");\n  }\n\n  get _path() {\n    return \"/user/\".concat(this.curator.name, \"/m/\").concat(this.name);\n  }\n  /**\n  * @summary Copies this multireddit to the requester's own account.\n  * @param {object} options\n  * @param {string} options.newName The new name for the copied multireddit\n  * @returns {Promise} A Promise for the newly-copied multireddit\n  * @example r.getUser('multi-mod').getMultireddit('coding_languages').copy({newName: 'my_coding_languages_copy'})\n  */\n\n\n  copy(_ref) {\n    var _this2 = this;\n\n    var new_name = _ref.new_name,\n        _ref$newName = _ref.newName,\n        newName = _ref$newName === void 0 ? new_name : _ref$newName;\n    return this._r._getMyName().then(function (name) {\n      return _this2._post({\n        uri: 'api/multi/copy',\n        form: {\n          from: _this2._path,\n          to: \"/user/\".concat(name, \"/m/\").concat(newName),\n          display_name: newName\n        }\n      });\n    });\n  }\n  /**\n  * @summary Renames this multireddit.\n  * @desc **Note**: This method mutates this MultiReddit.\n  * @param {object} options\n  * @param {string} options.newName The new name for this multireddit.\n  * @returns {Promise} A Promise that fulfills with this multireddit\n  * @example r.getUser('multi-mod').getMultireddit('coding_languages').copy({newName: 'cookie_languages '})\n  * @deprecated Reddit no longer provides the corresponding API endpoint. Please use `edit()` with a new name.\n  */\n\n\n  rename(_ref2) {\n    var _this3 = this;\n\n    var new_name = _ref2.new_name,\n        _ref2$newName = _ref2.newName,\n        newName = _ref2$newName === void 0 ? new_name : _ref2$newName;\n    return this._r._getMyName().then(function (name) {\n      return _this3._post({\n        uri: 'api/multi/rename',\n        form: {\n          from: _this3._path,\n          to: \"/user/\".concat(name, \"/m/\").concat(newName),\n          display_name: newName\n        }\n      });\n    }).then(function (res) {\n      _this3.name = res.name;\n    }).return(this);\n  }\n  /**\n  * @summary Edits the properties of this multireddit.\n  * @desc **Note**: Any omitted properties here will simply retain their previous values.\n  * @param {object} options\n  * @param {string} [options.name] The name of the new multireddit. 50 characters max.\n  * @param {string} [options.description] A description for the new multireddit, in markdown.\n  * @param {string} [options.visibility] The multireddit's visibility setting. One of `private`, `public`, `hidden`.\n  * @param {string} [options.icon_name] One of `art and design`, `ask`, `books`, `business`, `cars`, `comics`, `cute animals`,\n  `diy`, `entertainment`, `food and drink`, `funny`, `games`, `grooming`, `health`, `life advice`, `military`, `models pinup`,\n  `music`, `news`, `philosophy`, `pictures and gifs`, `science`, `shopping`, `sports`, `style`, `tech`, `travel`,\n  `unusual stories`, `video`, `None`\n  * @param {string} [options.key_color] A six-digit RGB hex color, preceded by '#'\n  * @param {string} [options.weighting_scheme] One of 'classic', 'fresh'\n  * @returns {Promise} The updated version of this multireddit\n  * @example r.getUser('not_an_aardvark').getMultireddit('cookie_languages').edit({visibility: 'hidden'})\n  */\n\n\n  edit(_ref3) {\n    var _ref3$name = _ref3.name,\n        name = _ref3$name === void 0 ? '' : _ref3$name,\n        description = _ref3.description,\n        icon_name = _ref3.icon_name,\n        key_color = _ref3.key_color,\n        visibility = _ref3.visibility,\n        weighting_scheme = _ref3.weighting_scheme;\n    var display_name = name.length ? name : this.name;\n    return this._put({\n      uri: \"api/multi\".concat(this._path),\n      form: {\n        model: JSON.stringify({\n          description_md: description,\n          display_name,\n          icon_name,\n          key_color,\n          visibility,\n          weighting_scheme\n        })\n      }\n    });\n  }\n  /**\n  * @summary Adds a subreddit to this multireddit.\n  * @param {Subreddit} sub The Subreddit object to add (or a string representing a subreddit name)\n  * @returns {Promise} A Promise that fulfills with this multireddit when the reuqest is complete\n  * @example r.getUser('not_an_aardvark').getMultireddit('cookie_languages').addSubreddit('cookies')\n  */\n\n\n  addSubreddit(sub) {\n    sub = typeof sub === 'string' ? sub : sub.display_name;\n    return this._put({\n      uri: \"api/multi\".concat(this._path, \"/r/\").concat(sub),\n      form: {\n        model: JSON.stringify({\n          name: sub\n        })\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Removes a subreddit from this multireddit.\n  * @param {Subreddit} sub The Subreddit object to remove (or a string representing a subreddit name)\n  * @returns {Promise} A Promise that fulfills with this multireddit when the request is complete\n  * @example r.getUser('not_an_aardvark').getMultireddit('cookie_languages').removeSubreddit('cookies')\n  */\n\n\n  removeSubreddit(sub) {\n    return this._delete({\n      uri: \"api/multi\".concat(this._path, \"/r/\").concat(typeof sub === 'string' ? sub : sub.display_name)\n    }).return(this);\n  }\n  /* Note: The endpoints GET/PUT /api/multi/multipath/description and GET /api/multi/multipath/r/srname are intentionally not\n  included, because they're redundant and the same thing can be achieved by simply using fetch() and edit(). */\n\n\n}; // MultiReddit#delete is not in the class body since Safari 9 can't parse the `delete` function name in class bodies.\n\n/**\n* @function\n* @name delete\n* @summary Deletes this multireddit.\n* @returns {Promise} A Promise that fulfills when this request is complete\n* @example r.getUser('not_an_aardvark').getMultireddit('cookie_languages').delete()\n* @memberof MultiReddit\n* @instance\n*/\n\nObject.defineProperty(MultiReddit.prototype, 'delete', {\n  value() {\n    return this._delete({\n      uri: \"api/multi\".concat(this._path)\n    });\n  },\n\n  configurable: true,\n  writable: true\n});\nvar _default = MultiReddit;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL011bHRpUmVkZGl0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmLDRDQUE0QyxtQkFBTyxDQUFDLHVGQUFvQjs7QUFFeEUsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkIsNkVBQTZFLG9DQUFvQztBQUNqSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCLDZFQUE2RSw2QkFBNkI7QUFDMUc7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkIsbUZBQW1GLHFCQUFxQjtBQUN4Rzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL011bHRpUmVkZGl0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX1JlZGRpdENvbnRlbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlZGRpdENvbnRlbnQuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiogQHN1bW1hcnkgQSBjbGFzcyByZXByZXNlbnRpbmcgYSBtdWx0aXJlZGRpdC5cbiogPHN0eWxlPiAjTXVsdGlSZWRkaXQge2Rpc3BsYXk6IG5vbmV9IDwvc3R5bGU+XG4qIEBleGFtcGxlXG4qXG4qIC8vIEdldCBhIG11bHRpcmVkZGl0IGJlbG9uZ2luZyB0byBhIHNwZWNpZmljIHVzZXJcbiogci5nZXRVc2VyKCdtdWx0aS1tb2QnKS5nZXRNdWx0aXJlZGRpdCgnY29kaW5nX2xhbmd1YWdlcycpXG4qL1xudmFyIE11bHRpUmVkZGl0ID0gY2xhc3MgTXVsdGlSZWRkaXQgZXh0ZW5kcyBfUmVkZGl0Q29udGVudC5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgX3IsIF9oYXNGZXRjaGVkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgc3VwZXIob3B0aW9ucywgX3IsIF9oYXNGZXRjaGVkKTtcbiAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoX2hhc0ZldGNoZWQpIHtcbiAgICAgIHRoaXMuY3VyYXRvciA9IF9yLmdldFVzZXIodGhpcy5wYXRoLnNwbGl0KCcvJylbMl0pO1xuICAgICAgdGhpcy5zdWJyZWRkaXRzID0gdGhpcy5zdWJyZWRkaXRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3IuX25ld09iamVjdCgnU3VicmVkZGl0JywgaXRlbS5kYXRhIHx8IHtcbiAgICAgICAgICBkaXNwbGF5X25hbWU6IGl0ZW0ubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfdXJpKCkge1xuICAgIHJldHVybiBcImFwaS9tdWx0aVwiLmNvbmNhdCh0aGlzLl9wYXRoLCBcIj9leHBhbmRfc3JzPXRydWVcIik7XG4gIH1cblxuICBnZXQgX3BhdGgoKSB7XG4gICAgcmV0dXJuIFwiL3VzZXIvXCIuY29uY2F0KHRoaXMuY3VyYXRvci5uYW1lLCBcIi9tL1wiKS5jb25jYXQodGhpcy5uYW1lKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBDb3BpZXMgdGhpcyBtdWx0aXJlZGRpdCB0byB0aGUgcmVxdWVzdGVyJ3Mgb3duIGFjY291bnQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uZXdOYW1lIFRoZSBuZXcgbmFtZSBmb3IgdGhlIGNvcGllZCBtdWx0aXJlZGRpdFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgZm9yIHRoZSBuZXdseS1jb3BpZWQgbXVsdGlyZWRkaXRcbiAgKiBAZXhhbXBsZSByLmdldFVzZXIoJ211bHRpLW1vZCcpLmdldE11bHRpcmVkZGl0KCdjb2RpbmdfbGFuZ3VhZ2VzJykuY29weSh7bmV3TmFtZTogJ215X2NvZGluZ19sYW5ndWFnZXNfY29weSd9KVxuICAqL1xuXG5cbiAgY29weShfcmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbmV3X25hbWUgPSBfcmVmLm5ld19uYW1lLFxuICAgICAgICBfcmVmJG5ld05hbWUgPSBfcmVmLm5ld05hbWUsXG4gICAgICAgIG5ld05hbWUgPSBfcmVmJG5ld05hbWUgPT09IHZvaWQgMCA/IG5ld19uYW1lIDogX3JlZiRuZXdOYW1lO1xuICAgIHJldHVybiB0aGlzLl9yLl9nZXRNeU5hbWUoKS50aGVuKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLl9wb3N0KHtcbiAgICAgICAgdXJpOiAnYXBpL211bHRpL2NvcHknLFxuICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgZnJvbTogX3RoaXMyLl9wYXRoLFxuICAgICAgICAgIHRvOiBcIi91c2VyL1wiLmNvbmNhdChuYW1lLCBcIi9tL1wiKS5jb25jYXQobmV3TmFtZSksXG4gICAgICAgICAgZGlzcGxheV9uYW1lOiBuZXdOYW1lXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFJlbmFtZXMgdGhpcyBtdWx0aXJlZGRpdC5cbiAgKiBAZGVzYyAqKk5vdGUqKjogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGlzIE11bHRpUmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmV3TmFtZSBUaGUgbmV3IG5hbWUgZm9yIHRoaXMgbXVsdGlyZWRkaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBtdWx0aXJlZGRpdFxuICAqIEBleGFtcGxlIHIuZ2V0VXNlcignbXVsdGktbW9kJykuZ2V0TXVsdGlyZWRkaXQoJ2NvZGluZ19sYW5ndWFnZXMnKS5jb3B5KHtuZXdOYW1lOiAnY29va2llX2xhbmd1YWdlcyAnfSlcbiAgKiBAZGVwcmVjYXRlZCBSZWRkaXQgbm8gbG9uZ2VyIHByb3ZpZGVzIHRoZSBjb3JyZXNwb25kaW5nIEFQSSBlbmRwb2ludC4gUGxlYXNlIHVzZSBgZWRpdCgpYCB3aXRoIGEgbmV3IG5hbWUuXG4gICovXG5cblxuICByZW5hbWUoX3JlZjIpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBuZXdfbmFtZSA9IF9yZWYyLm5ld19uYW1lLFxuICAgICAgICBfcmVmMiRuZXdOYW1lID0gX3JlZjIubmV3TmFtZSxcbiAgICAgICAgbmV3TmFtZSA9IF9yZWYyJG5ld05hbWUgPT09IHZvaWQgMCA/IG5ld19uYW1lIDogX3JlZjIkbmV3TmFtZTtcbiAgICByZXR1cm4gdGhpcy5fci5fZ2V0TXlOYW1lKCkudGhlbihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF90aGlzMy5fcG9zdCh7XG4gICAgICAgIHVyaTogJ2FwaS9tdWx0aS9yZW5hbWUnLFxuICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgZnJvbTogX3RoaXMzLl9wYXRoLFxuICAgICAgICAgIHRvOiBcIi91c2VyL1wiLmNvbmNhdChuYW1lLCBcIi9tL1wiKS5jb25jYXQobmV3TmFtZSksXG4gICAgICAgICAgZGlzcGxheV9uYW1lOiBuZXdOYW1lXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgX3RoaXMzLm5hbWUgPSByZXMubmFtZTtcbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRWRpdHMgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBtdWx0aXJlZGRpdC5cbiAgKiBAZGVzYyAqKk5vdGUqKjogQW55IG9taXR0ZWQgcHJvcGVydGllcyBoZXJlIHdpbGwgc2ltcGx5IHJldGFpbiB0aGVpciBwcmV2aW91cyB2YWx1ZXMuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gVGhlIG5hbWUgb2YgdGhlIG5ldyBtdWx0aXJlZGRpdC4gNTAgY2hhcmFjdGVycyBtYXguXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSBBIGRlc2NyaXB0aW9uIGZvciB0aGUgbmV3IG11bHRpcmVkZGl0LCBpbiBtYXJrZG93bi5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmlzaWJpbGl0eV0gVGhlIG11bHRpcmVkZGl0J3MgdmlzaWJpbGl0eSBzZXR0aW5nLiBPbmUgb2YgYHByaXZhdGVgLCBgcHVibGljYCwgYGhpZGRlbmAuXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmljb25fbmFtZV0gT25lIG9mIGBhcnQgYW5kIGRlc2lnbmAsIGBhc2tgLCBgYm9va3NgLCBgYnVzaW5lc3NgLCBgY2Fyc2AsIGBjb21pY3NgLCBgY3V0ZSBhbmltYWxzYCxcbiAgYGRpeWAsIGBlbnRlcnRhaW5tZW50YCwgYGZvb2QgYW5kIGRyaW5rYCwgYGZ1bm55YCwgYGdhbWVzYCwgYGdyb29taW5nYCwgYGhlYWx0aGAsIGBsaWZlIGFkdmljZWAsIGBtaWxpdGFyeWAsIGBtb2RlbHMgcGludXBgLFxuICBgbXVzaWNgLCBgbmV3c2AsIGBwaGlsb3NvcGh5YCwgYHBpY3R1cmVzIGFuZCBnaWZzYCwgYHNjaWVuY2VgLCBgc2hvcHBpbmdgLCBgc3BvcnRzYCwgYHN0eWxlYCwgYHRlY2hgLCBgdHJhdmVsYCxcbiAgYHVudXN1YWwgc3Rvcmllc2AsIGB2aWRlb2AsIGBOb25lYFxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5rZXlfY29sb3JdIEEgc2l4LWRpZ2l0IFJHQiBoZXggY29sb3IsIHByZWNlZGVkIGJ5ICcjJ1xuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53ZWlnaHRpbmdfc2NoZW1lXSBPbmUgb2YgJ2NsYXNzaWMnLCAnZnJlc2gnXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBtdWx0aXJlZGRpdFxuICAqIEBleGFtcGxlIHIuZ2V0VXNlcignbm90X2FuX2FhcmR2YXJrJykuZ2V0TXVsdGlyZWRkaXQoJ2Nvb2tpZV9sYW5ndWFnZXMnKS5lZGl0KHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pXG4gICovXG5cblxuICBlZGl0KF9yZWYzKSB7XG4gICAgdmFyIF9yZWYzJG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBuYW1lID0gX3JlZjMkbmFtZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmMyRuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbiA9IF9yZWYzLmRlc2NyaXB0aW9uLFxuICAgICAgICBpY29uX25hbWUgPSBfcmVmMy5pY29uX25hbWUsXG4gICAgICAgIGtleV9jb2xvciA9IF9yZWYzLmtleV9jb2xvcixcbiAgICAgICAgdmlzaWJpbGl0eSA9IF9yZWYzLnZpc2liaWxpdHksXG4gICAgICAgIHdlaWdodGluZ19zY2hlbWUgPSBfcmVmMy53ZWlnaHRpbmdfc2NoZW1lO1xuICAgIHZhciBkaXNwbGF5X25hbWUgPSBuYW1lLmxlbmd0aCA/IG5hbWUgOiB0aGlzLm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3B1dCh7XG4gICAgICB1cmk6IFwiYXBpL211bHRpXCIuY29uY2F0KHRoaXMuX3BhdGgpLFxuICAgICAgZm9ybToge1xuICAgICAgICBtb2RlbDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uX21kOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICBkaXNwbGF5X25hbWUsXG4gICAgICAgICAgaWNvbl9uYW1lLFxuICAgICAgICAgIGtleV9jb2xvcixcbiAgICAgICAgICB2aXNpYmlsaXR5LFxuICAgICAgICAgIHdlaWdodGluZ19zY2hlbWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBBZGRzIGEgc3VicmVkZGl0IHRvIHRoaXMgbXVsdGlyZWRkaXQuXG4gICogQHBhcmFtIHtTdWJyZWRkaXR9IHN1YiBUaGUgU3VicmVkZGl0IG9iamVjdCB0byBhZGQgKG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHN1YnJlZGRpdCBuYW1lKVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgbXVsdGlyZWRkaXQgd2hlbiB0aGUgcmV1cWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0VXNlcignbm90X2FuX2FhcmR2YXJrJykuZ2V0TXVsdGlyZWRkaXQoJ2Nvb2tpZV9sYW5ndWFnZXMnKS5hZGRTdWJyZWRkaXQoJ2Nvb2tpZXMnKVxuICAqL1xuXG5cbiAgYWRkU3VicmVkZGl0KHN1Yikge1xuICAgIHN1YiA9IHR5cGVvZiBzdWIgPT09ICdzdHJpbmcnID8gc3ViIDogc3ViLmRpc3BsYXlfbmFtZTtcbiAgICByZXR1cm4gdGhpcy5fcHV0KHtcbiAgICAgIHVyaTogXCJhcGkvbXVsdGlcIi5jb25jYXQodGhpcy5fcGF0aCwgXCIvci9cIikuY29uY2F0KHN1YiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIG1vZGVsOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbmFtZTogc3ViXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFJlbW92ZXMgYSBzdWJyZWRkaXQgZnJvbSB0aGlzIG11bHRpcmVkZGl0LlxuICAqIEBwYXJhbSB7U3VicmVkZGl0fSBzdWIgVGhlIFN1YnJlZGRpdCBvYmplY3QgdG8gcmVtb3ZlIChvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBzdWJyZWRkaXQgbmFtZSlcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIG11bHRpcmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFVzZXIoJ25vdF9hbl9hYXJkdmFyaycpLmdldE11bHRpcmVkZGl0KCdjb29raWVfbGFuZ3VhZ2VzJykucmVtb3ZlU3VicmVkZGl0KCdjb29raWVzJylcbiAgKi9cblxuXG4gIHJlbW92ZVN1YnJlZGRpdChzdWIpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZXRlKHtcbiAgICAgIHVyaTogXCJhcGkvbXVsdGlcIi5jb25jYXQodGhpcy5fcGF0aCwgXCIvci9cIikuY29uY2F0KHR5cGVvZiBzdWIgPT09ICdzdHJpbmcnID8gc3ViIDogc3ViLmRpc3BsYXlfbmFtZSlcbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyogTm90ZTogVGhlIGVuZHBvaW50cyBHRVQvUFVUIC9hcGkvbXVsdGkvbXVsdGlwYXRoL2Rlc2NyaXB0aW9uIGFuZCBHRVQgL2FwaS9tdWx0aS9tdWx0aXBhdGgvci9zcm5hbWUgYXJlIGludGVudGlvbmFsbHkgbm90XG4gIGluY2x1ZGVkLCBiZWNhdXNlIHRoZXkncmUgcmVkdW5kYW50IGFuZCB0aGUgc2FtZSB0aGluZyBjYW4gYmUgYWNoaWV2ZWQgYnkgc2ltcGx5IHVzaW5nIGZldGNoKCkgYW5kIGVkaXQoKS4gKi9cblxuXG59OyAvLyBNdWx0aVJlZGRpdCNkZWxldGUgaXMgbm90IGluIHRoZSBjbGFzcyBib2R5IHNpbmNlIFNhZmFyaSA5IGNhbid0IHBhcnNlIHRoZSBgZGVsZXRlYCBmdW5jdGlvbiBuYW1lIGluIGNsYXNzIGJvZGllcy5cblxuLyoqXG4qIEBmdW5jdGlvblxuKiBAbmFtZSBkZWxldGVcbiogQHN1bW1hcnkgRGVsZXRlcyB0aGlzIG11bHRpcmVkZGl0LlxuKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGlzIHJlcXVlc3QgaXMgY29tcGxldGVcbiogQGV4YW1wbGUgci5nZXRVc2VyKCdub3RfYW5fYWFyZHZhcmsnKS5nZXRNdWx0aXJlZGRpdCgnY29va2llX2xhbmd1YWdlcycpLmRlbGV0ZSgpXG4qIEBtZW1iZXJvZiBNdWx0aVJlZGRpdFxuKiBAaW5zdGFuY2VcbiovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNdWx0aVJlZGRpdC5wcm90b3R5cGUsICdkZWxldGUnLCB7XG4gIHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxldGUoe1xuICAgICAgdXJpOiBcImFwaS9tdWx0aVwiLmNvbmNhdCh0aGlzLl9wYXRoKVxuICAgIH0pO1xuICB9LFxuXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xudmFyIF9kZWZhdWx0ID0gTXVsdGlSZWRkaXQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/MultiReddit.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/PrivateMessage.js":
/*!**************************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/PrivateMessage.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _ReplyableContent = _interopRequireDefault(__webpack_require__(/*! ./ReplyableContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/ReplyableContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* A class representing a private message or a modmail.\n* <style> #PrivateMessage {display: none} </style>\n* @example\n*\n* // Get a Private Message with a given ID\n* r.getMessage('51shnw')\n* @extends ReplyableContent\n*/\nvar PrivateMessage = class PrivateMessage extends _ReplyableContent.default {\n  get _uri() {\n    return \"message/messages/\".concat(this.name.slice(3));\n  }\n\n  _transformApiResponse(response) {\n    response[0].replies = (0, _helpers.buildRepliesTree)(response[0].replies || []);\n    return (0, _helpers.findMessageInTree)(this.name, response[0]);\n  } // TODO: Get rid of the repeated code here, most of these methods are exactly the same with the exception of the URIs\n\n  /**\n  * @summary Marks this message as read.\n  * @returns {Promise} A Promise that fulfills with this message after the request is complete\n  * @example r.getMessage('51shxv').markAsRead()\n  */\n\n\n  markAsRead() {\n    return this._r.markMessagesAsRead([this]).return(this);\n  }\n  /**\n  * @summary Marks this message as unread.\n  * @returns {Promise} A Promise that fulfills with this message after the request is complete\n  * @example r.getMessage('51shxv').markAsUnread()\n  */\n\n\n  markAsUnread() {\n    return this._r.markMessagesAsUnread([this]).return(this);\n  }\n  /**\n  * @summary Mutes the author of this message for 72 hours. This can only be used on moderator mail.\n  * @returns {Promise} A Promise that fulfills with this message after the request is complete\n  * @example r.getMessage('51shxv').muteAuthor()\n  */\n\n\n  muteAuthor() {\n    return this._post({\n      uri: 'api/mute_message_author',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unmutes the author of this message.\n  * @returns {Promise} A Promise that fulfills with this message after the request is complete\n  * @example r.getMessage('51shxv').unmuteAuthor()\n  */\n\n\n  unmuteAuthor() {\n    return this._post({\n      uri: 'api/unmute_message_author',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Deletes this message from the authenticated user's inbox.\n  * @desc This only removes the item from the authenticated user's inbox. It has no effect on how the item looks to the sender.\n  * @returns {Promise} A Promise that fulfills with this message when the request is complete.\n  * @example\n  *\n  * const firstMessage = r.getInbox().get(0);\n  * firstMessage.deleteFromInbox();\n  */\n\n\n  deleteFromInbox() {\n    return this._post({\n      uri: 'api/del_msg',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n\n};\nvar _default = PrivateMessage;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1ByaXZhdGVNZXNzYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmLGVBQWUsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFdEMsK0NBQStDLG1CQUFPLENBQUMsNkZBQXVCOztBQUU5RSx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL2Rpc3Qvb2JqZWN0cy9Qcml2YXRlTWVzc2FnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9oZWxwZXJzID0gcmVxdWlyZShcIi4uL2hlbHBlcnMuanNcIik7XG5cbnZhciBfUmVwbHlhYmxlQ29udGVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVwbHlhYmxlQ29udGVudC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHByaXZhdGUgbWVzc2FnZSBvciBhIG1vZG1haWwuXG4qIDxzdHlsZT4gI1ByaXZhdGVNZXNzYWdlIHtkaXNwbGF5OiBub25lfSA8L3N0eWxlPlxuKiBAZXhhbXBsZVxuKlxuKiAvLyBHZXQgYSBQcml2YXRlIE1lc3NhZ2Ugd2l0aCBhIGdpdmVuIElEXG4qIHIuZ2V0TWVzc2FnZSgnNTFzaG53JylcbiogQGV4dGVuZHMgUmVwbHlhYmxlQ29udGVudFxuKi9cbnZhciBQcml2YXRlTWVzc2FnZSA9IGNsYXNzIFByaXZhdGVNZXNzYWdlIGV4dGVuZHMgX1JlcGx5YWJsZUNvbnRlbnQuZGVmYXVsdCB7XG4gIGdldCBfdXJpKCkge1xuICAgIHJldHVybiBcIm1lc3NhZ2UvbWVzc2FnZXMvXCIuY29uY2F0KHRoaXMubmFtZS5zbGljZSgzKSk7XG4gIH1cblxuICBfdHJhbnNmb3JtQXBpUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXNwb25zZVswXS5yZXBsaWVzID0gKDAsIF9oZWxwZXJzLmJ1aWxkUmVwbGllc1RyZWUpKHJlc3BvbnNlWzBdLnJlcGxpZXMgfHwgW10pO1xuICAgIHJldHVybiAoMCwgX2hlbHBlcnMuZmluZE1lc3NhZ2VJblRyZWUpKHRoaXMubmFtZSwgcmVzcG9uc2VbMF0pO1xuICB9IC8vIFRPRE86IEdldCByaWQgb2YgdGhlIHJlcGVhdGVkIGNvZGUgaGVyZSwgbW9zdCBvZiB0aGVzZSBtZXRob2RzIGFyZSBleGFjdGx5IHRoZSBzYW1lIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgVVJJc1xuXG4gIC8qKlxuICAqIEBzdW1tYXJ5IE1hcmtzIHRoaXMgbWVzc2FnZSBhcyByZWFkLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgbWVzc2FnZSBhZnRlciB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0TWVzc2FnZSgnNTFzaHh2JykubWFya0FzUmVhZCgpXG4gICovXG5cblxuICBtYXJrQXNSZWFkKCkge1xuICAgIHJldHVybiB0aGlzLl9yLm1hcmtNZXNzYWdlc0FzUmVhZChbdGhpc10pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBNYXJrcyB0aGlzIG1lc3NhZ2UgYXMgdW5yZWFkLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgbWVzc2FnZSBhZnRlciB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0TWVzc2FnZSgnNTFzaHh2JykubWFya0FzVW5yZWFkKClcbiAgKi9cblxuXG4gIG1hcmtBc1VucmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fci5tYXJrTWVzc2FnZXNBc1VucmVhZChbdGhpc10pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBNdXRlcyB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZSBmb3IgNzIgaG91cnMuIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBvbiBtb2RlcmF0b3IgbWFpbC5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIG1lc3NhZ2UgYWZ0ZXIgdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldE1lc3NhZ2UoJzUxc2h4dicpLm11dGVBdXRob3IoKVxuICAqL1xuXG5cbiAgbXV0ZUF1dGhvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvbXV0ZV9tZXNzYWdlX2F1dGhvcicsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgVW5tdXRlcyB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIG1lc3NhZ2UgYWZ0ZXIgdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldE1lc3NhZ2UoJzUxc2h4dicpLnVubXV0ZUF1dGhvcigpXG4gICovXG5cblxuICB1bm11dGVBdXRob3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3VubXV0ZV9tZXNzYWdlX2F1dGhvcicsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRGVsZXRlcyB0aGlzIG1lc3NhZ2UgZnJvbSB0aGUgYXV0aGVudGljYXRlZCB1c2VyJ3MgaW5ib3guXG4gICogQGRlc2MgVGhpcyBvbmx5IHJlbW92ZXMgdGhlIGl0ZW0gZnJvbSB0aGUgYXV0aGVudGljYXRlZCB1c2VyJ3MgaW5ib3guIEl0IGhhcyBubyBlZmZlY3Qgb24gaG93IHRoZSBpdGVtIGxvb2tzIHRvIHRoZSBzZW5kZXIuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBtZXNzYWdlIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIGNvbnN0IGZpcnN0TWVzc2FnZSA9IHIuZ2V0SW5ib3goKS5nZXQoMCk7XG4gICogZmlyc3RNZXNzYWdlLmRlbGV0ZUZyb21JbmJveCgpO1xuICAqL1xuXG5cbiAgZGVsZXRlRnJvbUluYm94KCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9kZWxfbXNnJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgaWQ6IHRoaXMubmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuXG59O1xudmFyIF9kZWZhdWx0ID0gUHJpdmF0ZU1lc3NhZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/PrivateMessage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js":
/*!*************************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/RedditContent.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _lodash = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ../Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _util = _interopRequireDefault(__webpack_require__(/*! util */ \"util\"));\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _constants = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/snoowrap/dist/constants.js\");\n\nvar _Listing = _interopRequireDefault(__webpack_require__(/*! ./Listing.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/Listing.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* A base class for content from reddit. With the expection of Listings, all content types extend this class.\n* This class should be considered 'abstract', to the extend that JavaScript classes can be -- it should not be necessary to\n* instantiate it directly.\n* <style> #RedditContent {display: none} </style>\n*/\nvar RedditContent = class RedditContent {\n  constructor(options, _r, _hasFetched) {\n    // _r refers to the snoowrap requester that is used to fetch this content.\n    this._r = _r;\n    this._fetch = null;\n    this._hasFetched = !!_hasFetched;\n    Object.assign(this, options);\n\n    if (typeof Proxy !== 'undefined' && !this._hasFetched && _r._config.proxies) {\n      return new Proxy(this, {\n        get(target, key) {\n          return key in target || key === 'length' || key in _Promise.default.prototype ? target[key] : target.fetch()[key];\n        }\n\n      });\n    }\n  }\n  /**\n  * @summary Fetches this content from reddit.\n  * @desc This will not mutate the original content object; all Promise properties will remain as Promises after the content has\n  * been fetched. However, the information on this object will be cached, so it may become out-of-date with the content on\n  * reddit. To clear the cache and fetch this object from reddit again, use `refresh()`.\n  *\n  * If snoowrap is running in an environment that supports ES2015 Proxies (e.g. Chrome 49+), then `fetch()` will get\n  * automatically called when an unknown property is accessed on an unfetched content object.\n  * @returns {Promise} A version of this object with all of its fetched properties from reddit. This will not mutate the\n  object. Once an object has been fetched once, its properties will be cached, so they might end up out-of-date if this\n  function is called again. To refresh an object, use refresh().\n  * @example\n  *\n  * r.getUser('not_an_aardvark').fetch().then(userInfo => {\n  *   console.log(userInfo.name); // 'not_an_aardvark'\n  *   console.log(userInfo.created_utc); // 1419104352\n  * });\n  *\n  * r.getComment('d1xchqn').fetch().then(comment => comment.body).then(console.log)\n  * // => 'This is a little too interesting for my liking'\n  *\n  * // In environments that support ES2015 Proxies, the above line is equivalent to:\n  * r.getComment('d1xchqn').body.then(console.log);\n  * // => 'This is a little too interesting for my liking'\n  */\n\n\n  fetch() {\n    var _this = this;\n\n    if (!this._fetch) {\n      this._fetch = this._r._promiseWrap(this._r._get({\n        uri: this._uri\n      }).then(function (res) {\n        return _this._transformApiResponse(res);\n      }));\n    }\n\n    return this._fetch;\n  }\n  /**\n  * @summary Refreshes this content.\n  * @returns {Promise} A newly-fetched version of this content\n  * @example\n  *\n  * var someComment = r.getComment('cmfkyus');\n  * var initialCommentBody = some_comment.fetch().then(comment => comment.body);\n  *\n  * setTimeout(() => {\n  *   someComment.refresh().then(refreshedComment => {\n  *     if (initialCommentBody.value() !== refreshedComment.body) {\n  *       console.log('This comment has changed since 10 seconds ago.');\n  *     }\n  *   });\n  * }, 10000);\n  */\n\n\n  refresh() {\n    this._fetch = null;\n    return this.fetch();\n  }\n  /**\n  * @summary Returns a stringifyable version of this object.\n  * @desc It is usually not necessary to call this method directly; simply running JSON.stringify(some_object) will strip the\n  private properties anyway.\n  * @returns {object} A version of this object with all the private properties stripped\n  * @example\n  *\n  * var user = r.getUser('not_an_aardvark');\n  * JSON.stringify(user) // => '{\"name\":\"not_an_aardvark\"}'\n  */\n\n\n  toJSON() {\n    return (0, _lodash.mapValues)(this._stripPrivateProps(), function (value, key) {\n      if (value instanceof RedditContent && !value._hasFetched) {\n        if (value.constructor._name === 'RedditUser' && _constants.USER_KEYS.has(key)) {\n          return value.name;\n        }\n\n        if (value.constructor._name === 'Subreddit' && _constants.SUBREDDIT_KEYS.has(key)) {\n          return value.display_name;\n        }\n      }\n\n      return value && value.toJSON ? value.toJSON() : value;\n    });\n  }\n\n  _stripPrivateProps() {\n    return (0, _lodash.pick)(this, Object.keys(this).filter(function (key) {\n      return !key.startsWith('_');\n    }));\n  }\n\n  _transformApiResponse(response) {\n    return response;\n  }\n\n  _clone() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$deep = _ref.deep,\n        deep = _ref$deep === void 0 ? false : _ref$deep;\n\n    var clonedProps = (0, _lodash.mapValues)(this, function (value) {\n      if (deep) {\n        return value instanceof RedditContent || value instanceof _Listing.default ? value._clone({\n          deep\n        }) : (0, _lodash.cloneDeep)(value);\n      }\n\n      return value;\n    });\n    return this._r._newObject(this.constructor._name, clonedProps, this._hasFetched);\n  }\n\n  _getListing() {\n    var _this$_r;\n\n    return (_this$_r = this._r)._getListing.apply(_this$_r, arguments);\n  }\n\n};\n(0, _helpers.defineInspectFunc)(RedditContent.prototype, function () {\n  return \"\".concat(this.constructor._name, \" \").concat(_util.default.inspect(this._stripPrivateProps()));\n});\n\n_constants.HTTP_VERBS.forEach(function (method) {\n  Object.defineProperty(RedditContent.prototype, \"_\".concat(method), {\n    value() {\n      var _this$_r2;\n\n      return (_this$_r2 = this._r)[\"_\".concat(method)].apply(_this$_r2, arguments);\n    },\n\n    configurable: true,\n    writable: true\n  });\n});\n\nvar _default = RedditContent;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1JlZGRpdENvbnRlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsY0FBYyxtQkFBTyxDQUFDLHFEQUFROztBQUU5QixzQ0FBc0MsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFN0QsbUNBQW1DLG1CQUFPLENBQUMsa0JBQU07O0FBRWpELGVBQWUsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFdEMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWlCOztBQUUxQyxzQ0FBc0MsbUJBQU8sQ0FBQywyRUFBYzs7QUFFNUQsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx5Q0FBeUM7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1JlZGRpdENvbnRlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfbG9kYXNoID0gcmVxdWlyZShcImxvZGFzaFwiKTtcblxudmFyIF9Qcm9taXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vUHJvbWlzZS5qc1wiKSk7XG5cbnZhciBfdXRpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInV0aWxcIikpO1xuXG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKFwiLi4vaGVscGVycy5qc1wiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzLmpzXCIpO1xuXG52YXIgX0xpc3RpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0xpc3RpbmcuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiogQSBiYXNlIGNsYXNzIGZvciBjb250ZW50IGZyb20gcmVkZGl0LiBXaXRoIHRoZSBleHBlY3Rpb24gb2YgTGlzdGluZ3MsIGFsbCBjb250ZW50IHR5cGVzIGV4dGVuZCB0aGlzIGNsYXNzLlxuKiBUaGlzIGNsYXNzIHNob3VsZCBiZSBjb25zaWRlcmVkICdhYnN0cmFjdCcsIHRvIHRoZSBleHRlbmQgdGhhdCBKYXZhU2NyaXB0IGNsYXNzZXMgY2FuIGJlIC0tIGl0IHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IHRvXG4qIGluc3RhbnRpYXRlIGl0IGRpcmVjdGx5LlxuKiA8c3R5bGU+ICNSZWRkaXRDb250ZW50IHtkaXNwbGF5OiBub25lfSA8L3N0eWxlPlxuKi9cbnZhciBSZWRkaXRDb250ZW50ID0gY2xhc3MgUmVkZGl0Q29udGVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIF9yLCBfaGFzRmV0Y2hlZCkge1xuICAgIC8vIF9yIHJlZmVycyB0byB0aGUgc25vb3dyYXAgcmVxdWVzdGVyIHRoYXQgaXMgdXNlZCB0byBmZXRjaCB0aGlzIGNvbnRlbnQuXG4gICAgdGhpcy5fciA9IF9yO1xuICAgIHRoaXMuX2ZldGNoID0gbnVsbDtcbiAgICB0aGlzLl9oYXNGZXRjaGVkID0gISFfaGFzRmV0Y2hlZDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuX2hhc0ZldGNoZWQgJiYgX3IuX2NvbmZpZy5wcm94aWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5ID09PSAnbGVuZ3RoJyB8fCBrZXkgaW4gX1Byb21pc2UuZGVmYXVsdC5wcm90b3R5cGUgPyB0YXJnZXRba2V5XSA6IHRhcmdldC5mZXRjaCgpW2tleV07XG4gICAgICAgIH1cblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEZldGNoZXMgdGhpcyBjb250ZW50IGZyb20gcmVkZGl0LlxuICAqIEBkZXNjIFRoaXMgd2lsbCBub3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBjb250ZW50IG9iamVjdDsgYWxsIFByb21pc2UgcHJvcGVydGllcyB3aWxsIHJlbWFpbiBhcyBQcm9taXNlcyBhZnRlciB0aGUgY29udGVudCBoYXNcbiAgKiBiZWVuIGZldGNoZWQuIEhvd2V2ZXIsIHRoZSBpbmZvcm1hdGlvbiBvbiB0aGlzIG9iamVjdCB3aWxsIGJlIGNhY2hlZCwgc28gaXQgbWF5IGJlY29tZSBvdXQtb2YtZGF0ZSB3aXRoIHRoZSBjb250ZW50IG9uXG4gICogcmVkZGl0LiBUbyBjbGVhciB0aGUgY2FjaGUgYW5kIGZldGNoIHRoaXMgb2JqZWN0IGZyb20gcmVkZGl0IGFnYWluLCB1c2UgYHJlZnJlc2goKWAuXG4gICpcbiAgKiBJZiBzbm9vd3JhcCBpcyBydW5uaW5nIGluIGFuIGVudmlyb25tZW50IHRoYXQgc3VwcG9ydHMgRVMyMDE1IFByb3hpZXMgKGUuZy4gQ2hyb21lIDQ5KyksIHRoZW4gYGZldGNoKClgIHdpbGwgZ2V0XG4gICogYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBhbiB1bmtub3duIHByb3BlcnR5IGlzIGFjY2Vzc2VkIG9uIGFuIHVuZmV0Y2hlZCBjb250ZW50IG9iamVjdC5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0IHdpdGggYWxsIG9mIGl0cyBmZXRjaGVkIHByb3BlcnRpZXMgZnJvbSByZWRkaXQuIFRoaXMgd2lsbCBub3QgbXV0YXRlIHRoZVxuICBvYmplY3QuIE9uY2UgYW4gb2JqZWN0IGhhcyBiZWVuIGZldGNoZWQgb25jZSwgaXRzIHByb3BlcnRpZXMgd2lsbCBiZSBjYWNoZWQsIHNvIHRoZXkgbWlnaHQgZW5kIHVwIG91dC1vZi1kYXRlIGlmIHRoaXNcbiAgZnVuY3Rpb24gaXMgY2FsbGVkIGFnYWluLiBUbyByZWZyZXNoIGFuIG9iamVjdCwgdXNlIHJlZnJlc2goKS5cbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRVc2VyKCdub3RfYW5fYWFyZHZhcmsnKS5mZXRjaCgpLnRoZW4odXNlckluZm8gPT4ge1xuICAqICAgY29uc29sZS5sb2codXNlckluZm8ubmFtZSk7IC8vICdub3RfYW5fYWFyZHZhcmsnXG4gICogICBjb25zb2xlLmxvZyh1c2VySW5mby5jcmVhdGVkX3V0Yyk7IC8vIDE0MTkxMDQzNTJcbiAgKiB9KTtcbiAgKlxuICAqIHIuZ2V0Q29tbWVudCgnZDF4Y2hxbicpLmZldGNoKCkudGhlbihjb21tZW50ID0+IGNvbW1lbnQuYm9keSkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiAnVGhpcyBpcyBhIGxpdHRsZSB0b28gaW50ZXJlc3RpbmcgZm9yIG15IGxpa2luZydcbiAgKlxuICAqIC8vIEluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgRVMyMDE1IFByb3hpZXMsIHRoZSBhYm92ZSBsaW5lIGlzIGVxdWl2YWxlbnQgdG86XG4gICogci5nZXRDb21tZW50KCdkMXhjaHFuJykuYm9keS50aGVuKGNvbnNvbGUubG9nKTtcbiAgKiAvLyA9PiAnVGhpcyBpcyBhIGxpdHRsZSB0b28gaW50ZXJlc3RpbmcgZm9yIG15IGxpa2luZydcbiAgKi9cblxuXG4gIGZldGNoKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuX2ZldGNoKSB7XG4gICAgICB0aGlzLl9mZXRjaCA9IHRoaXMuX3IuX3Byb21pc2VXcmFwKHRoaXMuX3IuX2dldCh7XG4gICAgICAgIHVyaTogdGhpcy5fdXJpXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl90cmFuc2Zvcm1BcGlSZXNwb25zZShyZXMpO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9mZXRjaDtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBSZWZyZXNoZXMgdGhpcyBjb250ZW50LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIG5ld2x5LWZldGNoZWQgdmVyc2lvbiBvZiB0aGlzIGNvbnRlbnRcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogdmFyIHNvbWVDb21tZW50ID0gci5nZXRDb21tZW50KCdjbWZreXVzJyk7XG4gICogdmFyIGluaXRpYWxDb21tZW50Qm9keSA9IHNvbWVfY29tbWVudC5mZXRjaCgpLnRoZW4oY29tbWVudCA9PiBjb21tZW50LmJvZHkpO1xuICAqXG4gICogc2V0VGltZW91dCgoKSA9PiB7XG4gICogICBzb21lQ29tbWVudC5yZWZyZXNoKCkudGhlbihyZWZyZXNoZWRDb21tZW50ID0+IHtcbiAgKiAgICAgaWYgKGluaXRpYWxDb21tZW50Qm9keS52YWx1ZSgpICE9PSByZWZyZXNoZWRDb21tZW50LmJvZHkpIHtcbiAgKiAgICAgICBjb25zb2xlLmxvZygnVGhpcyBjb21tZW50IGhhcyBjaGFuZ2VkIHNpbmNlIDEwIHNlY29uZHMgYWdvLicpO1xuICAqICAgICB9XG4gICogICB9KTtcbiAgKiB9LCAxMDAwMCk7XG4gICovXG5cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX2ZldGNoID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCgpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFJldHVybnMgYSBzdHJpbmdpZnlhYmxlIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICogQGRlc2MgSXQgaXMgdXN1YWxseSBub3QgbmVjZXNzYXJ5IHRvIGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHk7IHNpbXBseSBydW5uaW5nIEpTT04uc3RyaW5naWZ5KHNvbWVfb2JqZWN0KSB3aWxsIHN0cmlwIHRoZVxuICBwcml2YXRlIHByb3BlcnRpZXMgYW55d2F5LlxuICAqIEByZXR1cm5zIHtvYmplY3R9IEEgdmVyc2lvbiBvZiB0aGlzIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJpdmF0ZSBwcm9wZXJ0aWVzIHN0cmlwcGVkXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHZhciB1c2VyID0gci5nZXRVc2VyKCdub3RfYW5fYWFyZHZhcmsnKTtcbiAgKiBKU09OLnN0cmluZ2lmeSh1c2VyKSAvLyA9PiAne1wibmFtZVwiOlwibm90X2FuX2FhcmR2YXJrXCJ9J1xuICAqL1xuXG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiAoMCwgX2xvZGFzaC5tYXBWYWx1ZXMpKHRoaXMuX3N0cmlwUHJpdmF0ZVByb3BzKCksIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWRkaXRDb250ZW50ICYmICF2YWx1ZS5faGFzRmV0Y2hlZCkge1xuICAgICAgICBpZiAodmFsdWUuY29uc3RydWN0b3IuX25hbWUgPT09ICdSZWRkaXRVc2VyJyAmJiBfY29uc3RhbnRzLlVTRVJfS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yLl9uYW1lID09PSAnU3VicmVkZGl0JyAmJiBfY29uc3RhbnRzLlNVQlJFRERJVF9LRVlTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudG9KU09OID8gdmFsdWUudG9KU09OKCkgOiB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zdHJpcFByaXZhdGVQcm9wcygpIHtcbiAgICByZXR1cm4gKDAsIF9sb2Rhc2gucGljaykodGhpcywgT2JqZWN0LmtleXModGhpcykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiAha2V5LnN0YXJ0c1dpdGgoJ18nKTtcbiAgICB9KSk7XG4gIH1cblxuICBfdHJhbnNmb3JtQXBpUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBfY2xvbmUoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJGRlZXAgPSBfcmVmLmRlZXAsXG4gICAgICAgIGRlZXAgPSBfcmVmJGRlZXAgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRkZWVwO1xuXG4gICAgdmFyIGNsb25lZFByb3BzID0gKDAsIF9sb2Rhc2gubWFwVmFsdWVzKSh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZGRpdENvbnRlbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBfTGlzdGluZy5kZWZhdWx0ID8gdmFsdWUuX2Nsb25lKHtcbiAgICAgICAgICBkZWVwXG4gICAgICAgIH0pIDogKDAsIF9sb2Rhc2guY2xvbmVEZWVwKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fci5fbmV3T2JqZWN0KHRoaXMuY29uc3RydWN0b3IuX25hbWUsIGNsb25lZFByb3BzLCB0aGlzLl9oYXNGZXRjaGVkKTtcbiAgfVxuXG4gIF9nZXRMaXN0aW5nKCkge1xuICAgIHZhciBfdGhpcyRfcjtcblxuICAgIHJldHVybiAoX3RoaXMkX3IgPSB0aGlzLl9yKS5fZ2V0TGlzdGluZy5hcHBseShfdGhpcyRfciwgYXJndW1lbnRzKTtcbiAgfVxuXG59O1xuKDAsIF9oZWxwZXJzLmRlZmluZUluc3BlY3RGdW5jKShSZWRkaXRDb250ZW50LnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5jb25zdHJ1Y3Rvci5fbmFtZSwgXCIgXCIpLmNvbmNhdChfdXRpbC5kZWZhdWx0Lmluc3BlY3QodGhpcy5fc3RyaXBQcml2YXRlUHJvcHMoKSkpO1xufSk7XG5cbl9jb25zdGFudHMuSFRUUF9WRVJCUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZGRpdENvbnRlbnQucHJvdG90eXBlLCBcIl9cIi5jb25jYXQobWV0aG9kKSwge1xuICAgIHZhbHVlKCkge1xuICAgICAgdmFyIF90aGlzJF9yMjtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfcjIgPSB0aGlzLl9yKVtcIl9cIi5jb25jYXQobWV0aG9kKV0uYXBwbHkoX3RoaXMkX3IyLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSk7XG59KTtcblxudmFyIF9kZWZhdWx0ID0gUmVkZGl0Q29udGVudDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/RedditUser.js":
/*!**********************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/RedditUser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _constants = __webpack_require__(/*! ../constants.js */ \"(rsc)/./node_modules/snoowrap/dist/constants.js\");\n\nvar _errors = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/snoowrap/dist/errors.js\");\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n* A class representing a reddit user\n* <style> #RedditUser {display: none} </style>\n* @extends ReplyableContent\n* @example\n*\n* // Get a user with the given username\n* r.getUser('spez')\n*/\nvar RedditUser = class RedditUser extends _RedditContent.default {\n  get _uri() {\n    if (typeof this.name !== 'string' || !_constants.USERNAME_REGEX.test(this.name)) {\n      throw new _errors.InvalidUserError(this.name);\n    }\n\n    return \"user/\".concat(this.name, \"/about\");\n  }\n  /**\n  * @summary Gives reddit gold to a user\n  * @param {number} months The number of months of gold to give. This must be a number between 1 and 36.\n  * @returns {Promise} A Promise that fulfills when the request is complete\n  * @example r.getUser('not_an_aardvark').giveGold(12)\n  */\n\n\n  giveGold(months) {\n    /* Ideally this would allow for more than 36 months by sending multiple requests, but I don't have the resources to test\n    that code, and it's probably better that such a big investment be deliberate anyway. */\n    if (typeof months !== 'number' || months < 1 || months > 36) {\n      throw new _errors.InvalidMethodCallError('Invalid argument to RedditUser#giveGold; `months` must be between 1 and 36.');\n    }\n\n    return this._post({\n      uri: \"api/v1/gold/give/\".concat(this.name),\n      form: {\n        months\n      }\n    });\n  }\n  /**\n  * Assigns flair to this user on a given subreddit (as a moderator).\n  * @param {object} options\n  * @param {string} options.subredditName The subreddit that flair should be assigned on\n  * @param {string} [options.text=''] The text that the user's flair should have\n  * @param {string} [options.cssClass=''] The CSS class that the user's flair should have\n  * @returns {Promise} A Promise that fulfills with the current user after the request is complete\n  * @example r.getUser('not_an_aardvark').assignFlair({subredditName: 'snoowrap', text: \"Isn't an aardvark\"})\n  */\n\n\n  assignFlair(options) {\n    return this._r._assignFlair(_objectSpread({}, options, {\n      name: this.name\n    })).return(this);\n  }\n  /**\n  * @summary Adds this user as a friend, or modifies their friend note.\n  * @desc **Note:** reddit.com only permits \"notes\" to be added on friends if the authenticated account has a subscription to\n  reddit gold.\n  * @param {object} options\n  * @param {string} [options.note] An optional note to add on the user (300 characters max)\n  * @returns {Promise} A Promise that fulfills when this request is complete\n  * @example r.getUser('actually_an_aardvark').friend({note: 'Is an aardvark'})\n  */\n\n\n  friend() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        note = _ref.note;\n\n    return this._put({\n      uri: \"api/v1/me/friends/\".concat(this.name),\n      body: {\n        user: this.name,\n        note\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Removes this user from the requester's friend list.\n  * @returns {Promise} A Promise that fulfills with this user when the request is complete\n  * @example r.getUser('actually_an_aardvark').unfriend()\n  */\n\n\n  unfriend() {\n    return this._delete({\n      uri: \"api/v1/me/friends/\".concat(this.name)\n    });\n  }\n  /**\n  * @summary Gets information on this user related to their presence on the friend list.\n  * @returns {Promise} A Promise that fulfills with an object containing friend information\n  * @example\n  *\n  * r.getUser('not_an_aardvark').getFriendInformation().then(console.log)\n  * // => { date: 1460318190, note: 'Is an aardvark', name: 'actually_an_aardvark', id: 't2_q3519' }\n  */\n\n\n  getFriendInformation() {\n    return this._get({\n      uri: \"api/v1/me/friends/\".concat(this.name)\n    });\n  }\n  /**\n  * @summary Gets a list of this user's trophies.\n  * @returns {Promise} A TrophyList containing this user's trophies\n  * @example\n  *\n  * r.getUser('not_an_aardvark').getTrophies().then(console.log)\n  * // => TrophyList { trophies: [\n  * //  Trophy { ... },\n  * //  Trophy { ... },\n  * //  ...\n  * // ] }\n  */\n\n\n  getTrophies() {\n    return this._get({\n      uri: \"api/v1/user/\".concat(this.name, \"/trophies\")\n    });\n  }\n  /**\n  * @summary Gets a Listing of the content this user has submitted.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions and Comments\n  * @example\n  *\n  * r.getUser('spez').getOverview().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getOverview(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/overview\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of this user's submissions.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions\n  * @example\n  *\n  * r.getUser('spez').getSubmissions().then(console.log)\n  * // => Listing [\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getSubmissions(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/submitted\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of this user's comments.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Comments\n  * @example\n  *\n  * r.getUser('spez').getComments().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getComments(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/comments\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of the content that this user has upvoted.\n  * @desc **Note**: This can only be used to view one's own upvoted content, unless the user in question has chosen to\n  make this information public in their preferences.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions and Comments\n  * @example\n  *\n  * r.getMe().getUpvotedContent().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getUpvotedContent(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/upvoted\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of the content that this user has downvoted.\n  * @desc **Note**: This can only be used to view one's own downvoted content, unless the user in question has chosen to\n  make this information public in their preferences.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions and Comments\n  * @example\n  *\n  * r.getMe().getDownvotedContent().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getDownvotedContent(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/downvoted\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of the submissions that this user has hidden.\n  * @desc **Note**: This can only be used to view one's own set of hidden posts, as reddit will return a 403 error when\n  attempting to view another users' hidden posts.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions\n  * @example\n  *\n  * r.getMe().getHiddenContent().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getHiddenContent(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/hidden\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of the content that this user has saved.\n  * @desc **Note**: This can only be used to view one's own set of saved content, as reddit will return a 403 error when\n  attempting to view other users' saved content.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions and Comments.\n  * @example\n  *\n  * r.getMe().getSavedContent().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getSavedContent(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/saved\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of this user's content which has been gilded.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing Submissions and Comments\n  * @example\n  *\n  * r.getMe().getGildedContent().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getGildedContent(options) {\n    return this._getListing({\n      uri: \"user/\".concat(this.name, \"/gilded\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a multireddit belonging to this user.\n  * @param {string} name The name of the multireddit\n  * @returns {MultiReddit} An unfetched MultiReddit object\n  * @example\n  *\n  * r.getUser('multi-mod').getMultireddit('coding_languages')\n  * // => MultiReddit {\n  * //  name: 'coding_languages',\n  * //  curator: RedditUser { name: 'multi-mod' },\n  * //  path: '/user/multi-mod/m/coding_languages'\n  * // }\n  */\n\n\n  getMultireddit(name) {\n    return this._r._newObject('MultiReddit', {\n      name,\n      curator: this\n    });\n  }\n  /**\n  * @summary Gets an Array of all of this user's MultiReddits.\n  * @returns {Promise} A Promise that fulfills with an Array containing MultiReddits.\n  * @example\n  *\n  * r.getUser('multi-mod').getMultireddits().then(console.log)\n  *\n  * // => [\n  *   MultiReddit { ... },\n  *   MultiReddit { ... },\n  *   MultiReddit { ... },\n  *   ...\n  * ]\n  */\n\n\n  getMultireddits() {\n    return this._get({\n      uri: \"api/multi/user/\".concat(this.name),\n      qs: {\n        expand_srs: true\n      }\n    });\n  }\n\n};\nvar _default = RedditUser;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1JlZGRpdFVzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWlCOztBQUUxQyxjQUFjLG1CQUFPLENBQUMsa0VBQWM7O0FBRXBDLDRDQUE0QyxtQkFBTyxDQUFDLHVGQUFvQjs7QUFFeEUsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxpRUFBaUUsR0FBRyxrQ0FBa0M7O0FBRXZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsK0NBQStDLDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyx5Q0FBeUMsbUZBQW1GLE9BQU87O0FBRXRmLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVwTTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCLHVEQUF1RCxxREFBcUQ7QUFDNUc7OztBQUdBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxR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QUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekIsb0JBQW9CLEtBQUs7QUFDekIsb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL2Rpc3Qvb2JqZWN0cy9SZWRkaXRVc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMuanNcIik7XG5cbnZhciBfZXJyb3JzID0gcmVxdWlyZShcIi4uL2Vycm9ycy5qc1wiKTtcblxudmFyIF9SZWRkaXRDb250ZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZWRkaXRDb250ZW50LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4qIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgcmVkZGl0IHVzZXJcbiogPHN0eWxlPiAjUmVkZGl0VXNlciB7ZGlzcGxheTogbm9uZX0gPC9zdHlsZT5cbiogQGV4dGVuZHMgUmVwbHlhYmxlQ29udGVudFxuKiBAZXhhbXBsZVxuKlxuKiAvLyBHZXQgYSB1c2VyIHdpdGggdGhlIGdpdmVuIHVzZXJuYW1lXG4qIHIuZ2V0VXNlcignc3BleicpXG4qL1xudmFyIFJlZGRpdFVzZXIgPSBjbGFzcyBSZWRkaXRVc2VyIGV4dGVuZHMgX1JlZGRpdENvbnRlbnQuZGVmYXVsdCB7XG4gIGdldCBfdXJpKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5uYW1lICE9PSAnc3RyaW5nJyB8fCAhX2NvbnN0YW50cy5VU0VSTkFNRV9SRUdFWC50ZXN0KHRoaXMubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBfZXJyb3JzLkludmFsaWRVc2VyRXJyb3IodGhpcy5uYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJ1c2VyL1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiL2Fib3V0XCIpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdpdmVzIHJlZGRpdCBnb2xkIHRvIGEgdXNlclxuICAqIEBwYXJhbSB7bnVtYmVyfSBtb250aHMgVGhlIG51bWJlciBvZiBtb250aHMgb2YgZ29sZCB0byBnaXZlLiBUaGlzIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAzNi5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0VXNlcignbm90X2FuX2FhcmR2YXJrJykuZ2l2ZUdvbGQoMTIpXG4gICovXG5cblxuICBnaXZlR29sZChtb250aHMpIHtcbiAgICAvKiBJZGVhbGx5IHRoaXMgd291bGQgYWxsb3cgZm9yIG1vcmUgdGhhbiAzNiBtb250aHMgYnkgc2VuZGluZyBtdWx0aXBsZSByZXF1ZXN0cywgYnV0IEkgZG9uJ3QgaGF2ZSB0aGUgcmVzb3VyY2VzIHRvIHRlc3RcbiAgICB0aGF0IGNvZGUsIGFuZCBpdCdzIHByb2JhYmx5IGJldHRlciB0aGF0IHN1Y2ggYSBiaWcgaW52ZXN0bWVudCBiZSBkZWxpYmVyYXRlIGFueXdheS4gKi9cbiAgICBpZiAodHlwZW9mIG1vbnRocyAhPT0gJ251bWJlcicgfHwgbW9udGhzIDwgMSB8fCBtb250aHMgPiAzNikge1xuICAgICAgdGhyb3cgbmV3IF9lcnJvcnMuSW52YWxpZE1ldGhvZENhbGxFcnJvcignSW52YWxpZCBhcmd1bWVudCB0byBSZWRkaXRVc2VyI2dpdmVHb2xkOyBgbW9udGhzYCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMzYuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcImFwaS92MS9nb2xkL2dpdmUvXCIuY29uY2F0KHRoaXMubmFtZSksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIG1vbnRoc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEFzc2lnbnMgZmxhaXIgdG8gdGhpcyB1c2VyIG9uIGEgZ2l2ZW4gc3VicmVkZGl0IChhcyBhIG1vZGVyYXRvcikuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdWJyZWRkaXROYW1lIFRoZSBzdWJyZWRkaXQgdGhhdCBmbGFpciBzaG91bGQgYmUgYXNzaWduZWQgb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGV4dD0nJ10gVGhlIHRleHQgdGhhdCB0aGUgdXNlcidzIGZsYWlyIHNob3VsZCBoYXZlXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNzc0NsYXNzPScnXSBUaGUgQ1NTIGNsYXNzIHRoYXQgdGhlIHVzZXIncyBmbGFpciBzaG91bGQgaGF2ZVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoZSBjdXJyZW50IHVzZXIgYWZ0ZXIgdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFVzZXIoJ25vdF9hbl9hYXJkdmFyaycpLmFzc2lnbkZsYWlyKHtzdWJyZWRkaXROYW1lOiAnc25vb3dyYXAnLCB0ZXh0OiBcIklzbid0IGFuIGFhcmR2YXJrXCJ9KVxuICAqL1xuXG5cbiAgYXNzaWduRmxhaXIob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yLl9hc3NpZ25GbGFpcihfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICB9KSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEFkZHMgdGhpcyB1c2VyIGFzIGEgZnJpZW5kLCBvciBtb2RpZmllcyB0aGVpciBmcmllbmQgbm90ZS5cbiAgKiBAZGVzYyAqKk5vdGU6KiogcmVkZGl0LmNvbSBvbmx5IHBlcm1pdHMgXCJub3Rlc1wiIHRvIGJlIGFkZGVkIG9uIGZyaWVuZHMgaWYgdGhlIGF1dGhlbnRpY2F0ZWQgYWNjb3VudCBoYXMgYSBzdWJzY3JpcHRpb24gdG9cbiAgcmVkZGl0IGdvbGQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubm90ZV0gQW4gb3B0aW9uYWwgbm90ZSB0byBhZGQgb24gdGhlIHVzZXIgKDMwMCBjaGFyYWN0ZXJzIG1heClcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGlzIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFVzZXIoJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJykuZnJpZW5kKHtub3RlOiAnSXMgYW4gYWFyZHZhcmsnfSlcbiAgKi9cblxuXG4gIGZyaWVuZCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIG5vdGUgPSBfcmVmLm5vdGU7XG5cbiAgICByZXR1cm4gdGhpcy5fcHV0KHtcbiAgICAgIHVyaTogXCJhcGkvdjEvbWUvZnJpZW5kcy9cIi5jb25jYXQodGhpcy5uYW1lKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgdXNlcjogdGhpcy5uYW1lLFxuICAgICAgICBub3RlXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFJlbW92ZXMgdGhpcyB1c2VyIGZyb20gdGhlIHJlcXVlc3RlcidzIGZyaWVuZCBsaXN0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgdXNlciB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRVc2VyKCdhY3R1YWxseV9hbl9hYXJkdmFyaycpLnVuZnJpZW5kKClcbiAgKi9cblxuXG4gIHVuZnJpZW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxldGUoe1xuICAgICAgdXJpOiBcImFwaS92MS9tZS9mcmllbmRzL1wiLmNvbmNhdCh0aGlzLm5hbWUpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBpbmZvcm1hdGlvbiBvbiB0aGlzIHVzZXIgcmVsYXRlZCB0byB0aGVpciBwcmVzZW5jZSBvbiB0aGUgZnJpZW5kIGxpc3QuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgZnJpZW5kIGluZm9ybWF0aW9uXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0VXNlcignbm90X2FuX2FhcmR2YXJrJykuZ2V0RnJpZW5kSW5mb3JtYXRpb24oKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IHsgZGF0ZTogMTQ2MDMxODE5MCwgbm90ZTogJ0lzIGFuIGFhcmR2YXJrJywgbmFtZTogJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJywgaWQ6ICd0Ml9xMzUxOScgfVxuICAqL1xuXG5cbiAgZ2V0RnJpZW5kSW5mb3JtYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6IFwiYXBpL3YxL21lL2ZyaWVuZHMvXCIuY29uY2F0KHRoaXMubmFtZSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiB0aGlzIHVzZXIncyB0cm9waGllcy5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBUcm9waHlMaXN0IGNvbnRhaW5pbmcgdGhpcyB1c2VyJ3MgdHJvcGhpZXNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRVc2VyKCdub3RfYW5fYWFyZHZhcmsnKS5nZXRUcm9waGllcygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gVHJvcGh5TGlzdCB7IHRyb3BoaWVzOiBbXG4gICogLy8gIFRyb3BoeSB7IC4uLiB9LFxuICAqIC8vICBUcm9waHkgeyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXSB9XG4gICovXG5cblxuICBnZXRUcm9waGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogXCJhcGkvdjEvdXNlci9cIi5jb25jYXQodGhpcy5uYW1lLCBcIi90cm9waGllc1wiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYSBMaXN0aW5nIG9mIHRoZSBjb250ZW50IHRoaXMgdXNlciBoYXMgc3VibWl0dGVkLlxuICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIFN1Ym1pc3Npb25zIGFuZCBDb21tZW50c1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFVzZXIoJ3NwZXonKS5nZXRPdmVydmlldygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldE92ZXJ2aWV3KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwidXNlci9cIi5jb25jYXQodGhpcy5uYW1lLCBcIi9vdmVydmlld1wiKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIExpc3Rpbmcgb2YgdGhpcyB1c2VyJ3Mgc3VibWlzc2lvbnMuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VibWlzc2lvbnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRVc2VyKCdzcGV6JykuZ2V0U3VibWlzc2lvbnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIFN1Ym1pc3Npb24geyAuLi4gfSxcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRTdWJtaXNzaW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInVzZXIvXCIuY29uY2F0KHRoaXMubmFtZSwgXCIvc3VibWl0dGVkXCIpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiB0aGlzIHVzZXIncyBjb21tZW50cy5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyBDb21tZW50c1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFVzZXIoJ3NwZXonKS5nZXRDb21tZW50cygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldENvbW1lbnRzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwidXNlci9cIi5jb25jYXQodGhpcy5uYW1lLCBcIi9jb21tZW50c1wiKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIExpc3Rpbmcgb2YgdGhlIGNvbnRlbnQgdGhhdCB0aGlzIHVzZXIgaGFzIHVwdm90ZWQuXG4gICogQGRlc2MgKipOb3RlKio6IFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB0byB2aWV3IG9uZSdzIG93biB1cHZvdGVkIGNvbnRlbnQsIHVubGVzcyB0aGUgdXNlciBpbiBxdWVzdGlvbiBoYXMgY2hvc2VuIHRvXG4gIG1ha2UgdGhpcyBpbmZvcm1hdGlvbiBwdWJsaWMgaW4gdGhlaXIgcHJlZmVyZW5jZXMuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VibWlzc2lvbnMgYW5kIENvbW1lbnRzXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0TWUoKS5nZXRVcHZvdGVkQ29udGVudCgpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldFVwdm90ZWRDb250ZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwidXNlci9cIi5jb25jYXQodGhpcy5uYW1lLCBcIi91cHZvdGVkXCIpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiB0aGUgY29udGVudCB0aGF0IHRoaXMgdXNlciBoYXMgZG93bnZvdGVkLlxuICAqIEBkZXNjICoqTm90ZSoqOiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgdG8gdmlldyBvbmUncyBvd24gZG93bnZvdGVkIGNvbnRlbnQsIHVubGVzcyB0aGUgdXNlciBpbiBxdWVzdGlvbiBoYXMgY2hvc2VuIHRvXG4gIG1ha2UgdGhpcyBpbmZvcm1hdGlvbiBwdWJsaWMgaW4gdGhlaXIgcHJlZmVyZW5jZXMuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VibWlzc2lvbnMgYW5kIENvbW1lbnRzXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0TWUoKS5nZXREb3dudm90ZWRDb250ZW50KCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIFN1Ym1pc3Npb24geyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0RG93bnZvdGVkQ29udGVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInVzZXIvXCIuY29uY2F0KHRoaXMubmFtZSwgXCIvZG93bnZvdGVkXCIpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiB0aGUgc3VibWlzc2lvbnMgdGhhdCB0aGlzIHVzZXIgaGFzIGhpZGRlbi5cbiAgKiBAZGVzYyAqKk5vdGUqKjogVGhpcyBjYW4gb25seSBiZSB1c2VkIHRvIHZpZXcgb25lJ3Mgb3duIHNldCBvZiBoaWRkZW4gcG9zdHMsIGFzIHJlZGRpdCB3aWxsIHJldHVybiBhIDQwMyBlcnJvciB3aGVuXG4gIGF0dGVtcHRpbmcgdG8gdmlldyBhbm90aGVyIHVzZXJzJyBoaWRkZW4gcG9zdHMuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VibWlzc2lvbnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRNZSgpLmdldEhpZGRlbkNvbnRlbnQoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRIaWRkZW5Db250ZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwidXNlci9cIi5jb25jYXQodGhpcy5uYW1lLCBcIi9oaWRkZW5cIiksXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYSBMaXN0aW5nIG9mIHRoZSBjb250ZW50IHRoYXQgdGhpcyB1c2VyIGhhcyBzYXZlZC5cbiAgKiBAZGVzYyAqKk5vdGUqKjogVGhpcyBjYW4gb25seSBiZSB1c2VkIHRvIHZpZXcgb25lJ3Mgb3duIHNldCBvZiBzYXZlZCBjb250ZW50LCBhcyByZWRkaXQgd2lsbCByZXR1cm4gYSA0MDMgZXJyb3Igd2hlblxuICBhdHRlbXB0aW5nIHRvIHZpZXcgb3RoZXIgdXNlcnMnIHNhdmVkIGNvbnRlbnQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VibWlzc2lvbnMgYW5kIENvbW1lbnRzLlxuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldE1lKCkuZ2V0U2F2ZWRDb250ZW50KCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIFN1Ym1pc3Npb24geyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0U2F2ZWRDb250ZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwidXNlci9cIi5jb25jYXQodGhpcy5uYW1lLCBcIi9zYXZlZFwiKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIExpc3Rpbmcgb2YgdGhpcyB1c2VyJ3MgY29udGVudCB3aGljaCBoYXMgYmVlbiBnaWxkZWQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VibWlzc2lvbnMgYW5kIENvbW1lbnRzXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0TWUoKS5nZXRHaWxkZWRDb250ZW50KCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIFN1Ym1pc3Npb24geyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0R2lsZGVkQ29udGVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInVzZXIvXCIuY29uY2F0KHRoaXMubmFtZSwgXCIvZ2lsZGVkXCIpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgbXVsdGlyZWRkaXQgYmVsb25naW5nIHRvIHRoaXMgdXNlci5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbXVsdGlyZWRkaXRcbiAgKiBAcmV0dXJucyB7TXVsdGlSZWRkaXR9IEFuIHVuZmV0Y2hlZCBNdWx0aVJlZGRpdCBvYmplY3RcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRVc2VyKCdtdWx0aS1tb2QnKS5nZXRNdWx0aXJlZGRpdCgnY29kaW5nX2xhbmd1YWdlcycpXG4gICogLy8gPT4gTXVsdGlSZWRkaXQge1xuICAqIC8vICBuYW1lOiAnY29kaW5nX2xhbmd1YWdlcycsXG4gICogLy8gIGN1cmF0b3I6IFJlZGRpdFVzZXIgeyBuYW1lOiAnbXVsdGktbW9kJyB9LFxuICAqIC8vICBwYXRoOiAnL3VzZXIvbXVsdGktbW9kL20vY29kaW5nX2xhbmd1YWdlcydcbiAgKiAvLyB9XG4gICovXG5cblxuICBnZXRNdWx0aXJlZGRpdChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3IuX25ld09iamVjdCgnTXVsdGlSZWRkaXQnLCB7XG4gICAgICBuYW1lLFxuICAgICAgY3VyYXRvcjogdGhpc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYW4gQXJyYXkgb2YgYWxsIG9mIHRoaXMgdXNlcidzIE11bHRpUmVkZGl0cy5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCBhbiBBcnJheSBjb250YWluaW5nIE11bHRpUmVkZGl0cy5cbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRVc2VyKCdtdWx0aS1tb2QnKS5nZXRNdWx0aXJlZGRpdHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqXG4gICogLy8gPT4gW1xuICAqICAgTXVsdGlSZWRkaXQgeyAuLi4gfSxcbiAgKiAgIE11bHRpUmVkZGl0IHsgLi4uIH0sXG4gICogICBNdWx0aVJlZGRpdCB7IC4uLiB9LFxuICAqICAgLi4uXG4gICogXVxuICAqL1xuXG5cbiAgZ2V0TXVsdGlyZWRkaXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiBcImFwaS9tdWx0aS91c2VyL1wiLmNvbmNhdCh0aGlzLm5hbWUpLFxuICAgICAgcXM6IHtcbiAgICAgICAgZXhwYW5kX3NyczogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG52YXIgX2RlZmF1bHQgPSBSZWRkaXRVc2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/RedditUser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/ReplyableContent.js":
/*!****************************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/ReplyableContent.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar api_type = 'json';\n/**\n* A set of mixin functions that apply to Submissions, Comments, and PrivateMessages\n* <style> #ReplyableContent {display: none} </style>\n* @extends RedditContent\n*/\n\nvar ReplyableContent = class ReplyableContent extends _RedditContent.default {\n  /**\n  * @summary Removes this Comment, Submission or PrivateMessage from public listings.\n  * @desc This requires the authenticated user to be a moderator of the subreddit with the `posts` permission.\n  * @param {object} options\n  * @param {boolean} [options.spam=false] Determines whether this should be marked as spam\n  * @returns {Promise} A Promise that fulfills with this content when the request is complete\n  * @example r.getComment('c08pp5z').remove({spam: true})\n  */\n  remove() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$spam = _ref.spam,\n        spam = _ref$spam === void 0 ? false : _ref$spam;\n\n    return this._post({\n      uri: 'api/remove',\n      form: {\n        spam,\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Approves this Comment, Submission, or PrivateMessage, re-adding it to public listings if it had been removed\n  * @returns {Promise} A Promise that fulfills with this content when the request is complete\n  * @example r.getComment('c08pp5z').approve()\n  */\n\n\n  approve() {\n    return this._post({\n      uri: 'api/approve',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Reports this content anonymously to subreddit moderators (for Comments and Submissions)\n  or to the reddit admins (for PrivateMessages)\n  * @param {object} [options]\n  * @param {string} [options.reason] The reason for the report\n  * @returns {Promise} A Promise that fulfills with this content when the request is complete\n  * @example r.getComment('c08pp5z').report({reason: 'Breaking the subreddit rules'})\n  */\n\n\n  report() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        reason = _ref2.reason;\n\n    return this._post({\n      uri: 'api/report',\n      form: {\n        api_type,\n        reason: 'other',\n        other_reason: reason,\n        thing_id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Ignores reports on this Comment, Submission, or PrivateMessage\n  * @returns {Promise} A Promise that fulfills with this content when the request is complete\n  * @example r.getComment('c08pp5z').ignoreReports()\n  */\n\n\n  ignoreReports() {\n    return this._post({\n      uri: 'api/ignore_reports',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unignores reports on this Comment, Submission, or PrivateMessages\n  * @returns {Promise} A Promise that fulfills with this content when the request is complete\n  * @example r.getComment('c08pp5z').unignoreReports()\n  */\n\n\n  unignoreReports() {\n    return this._post({\n      uri: 'api/unignore_reports',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Submits a new reply to this object. (This takes the form of a new Comment if this object is a Submission/Comment,\n  or a new PrivateMessage if this object is a PrivateMessage.)\n  * @param {string} text The content of the reply, in raw markdown text\n  * @returns {Promise} A Promise that fulfills with the newly-created reply\n  * @example r.getSubmission('4e60m3').reply('This was an interesting post. Thanks.');\n  */\n\n\n  reply(text) {\n    return this._post({\n      uri: 'api/comment',\n      form: {\n        api_type,\n        text,\n        thing_id: this.name\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).then(function (res) {\n      return res.json.data.things[0];\n    });\n  }\n  /**\n  * @summary Blocks the author of this content.\n  * @desc **Note:** In order for this function to have an effect, this item **must** be in the authenticated account's inbox or\n  modmail somewhere. The reddit API gives no outward indication of whether this condition is satisfied, so the returned Promise\n  will fulfill even if this is not the case.\n  * @returns {Promise} A Promise that fulfills with this message after the request is complete\n  * @example\n  *\n  * r.getInbox({limit: 1}).then(messages =>\n  *   messages[0].blockAuthor();\n  * );\n  */\n\n\n  blockAuthor() {\n    return this._post({\n      uri: 'api/block',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n\n};\nvar _default = ReplyableContent;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1JlcGx5YWJsZUNvbnRlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsZUFBZSxtQkFBTyxDQUFDLG9FQUFlOztBQUV0Qyw0Q0FBNEMsbUJBQU8sQ0FBQyx1RkFBb0I7O0FBRXhFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLGNBQWMsU0FBUztBQUN2Qiw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2Qiw2Q0FBNkMsdUNBQXVDO0FBQ3BGOzs7QUFHQTtBQUNBLHNGQUFzRjtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L29iamVjdHMvUmVwbHlhYmxlQ29udGVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9oZWxwZXJzID0gcmVxdWlyZShcIi4uL2hlbHBlcnMuanNcIik7XG5cbnZhciBfUmVkZGl0Q29udGVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVkZGl0Q29udGVudC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBhcGlfdHlwZSA9ICdqc29uJztcbi8qKlxuKiBBIHNldCBvZiBtaXhpbiBmdW5jdGlvbnMgdGhhdCBhcHBseSB0byBTdWJtaXNzaW9ucywgQ29tbWVudHMsIGFuZCBQcml2YXRlTWVzc2FnZXNcbiogPHN0eWxlPiAjUmVwbHlhYmxlQ29udGVudCB7ZGlzcGxheTogbm9uZX0gPC9zdHlsZT5cbiogQGV4dGVuZHMgUmVkZGl0Q29udGVudFxuKi9cblxudmFyIFJlcGx5YWJsZUNvbnRlbnQgPSBjbGFzcyBSZXBseWFibGVDb250ZW50IGV4dGVuZHMgX1JlZGRpdENvbnRlbnQuZGVmYXVsdCB7XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFJlbW92ZXMgdGhpcyBDb21tZW50LCBTdWJtaXNzaW9uIG9yIFByaXZhdGVNZXNzYWdlIGZyb20gcHVibGljIGxpc3RpbmdzLlxuICAqIEBkZXNjIFRoaXMgcmVxdWlyZXMgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlciB0byBiZSBhIG1vZGVyYXRvciBvZiB0aGUgc3VicmVkZGl0IHdpdGggdGhlIGBwb3N0c2AgcGVybWlzc2lvbi5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3BhbT1mYWxzZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgc2hvdWxkIGJlIG1hcmtlZCBhcyBzcGFtXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBjb250ZW50IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldENvbW1lbnQoJ2MwOHBwNXonKS5yZW1vdmUoe3NwYW06IHRydWV9KVxuICAqL1xuICByZW1vdmUoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJHNwYW0gPSBfcmVmLnNwYW0sXG4gICAgICAgIHNwYW0gPSBfcmVmJHNwYW0gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzcGFtO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3JlbW92ZScsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIHNwYW0sXG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgQXBwcm92ZXMgdGhpcyBDb21tZW50LCBTdWJtaXNzaW9uLCBvciBQcml2YXRlTWVzc2FnZSwgcmUtYWRkaW5nIGl0IHRvIHB1YmxpYyBsaXN0aW5ncyBpZiBpdCBoYWQgYmVlbiByZW1vdmVkXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBjb250ZW50IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldENvbW1lbnQoJ2MwOHBwNXonKS5hcHByb3ZlKClcbiAgKi9cblxuXG4gIGFwcHJvdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL2FwcHJvdmUnLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFJlcG9ydHMgdGhpcyBjb250ZW50IGFub255bW91c2x5IHRvIHN1YnJlZGRpdCBtb2RlcmF0b3JzIChmb3IgQ29tbWVudHMgYW5kIFN1Ym1pc3Npb25zKVxuICBvciB0byB0aGUgcmVkZGl0IGFkbWlucyAoZm9yIFByaXZhdGVNZXNzYWdlcylcbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlYXNvbl0gVGhlIHJlYXNvbiBmb3IgdGhlIHJlcG9ydFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgY29udGVudCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRDb21tZW50KCdjMDhwcDV6JykucmVwb3J0KHtyZWFzb246ICdCcmVha2luZyB0aGUgc3VicmVkZGl0IHJ1bGVzJ30pXG4gICovXG5cblxuICByZXBvcnQoKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgcmVhc29uID0gX3JlZjIucmVhc29uO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3JlcG9ydCcsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlLFxuICAgICAgICByZWFzb246ICdvdGhlcicsXG4gICAgICAgIG90aGVyX3JlYXNvbjogcmVhc29uLFxuICAgICAgICB0aGluZ19pZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IElnbm9yZXMgcmVwb3J0cyBvbiB0aGlzIENvbW1lbnQsIFN1Ym1pc3Npb24sIG9yIFByaXZhdGVNZXNzYWdlXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBjb250ZW50IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldENvbW1lbnQoJ2MwOHBwNXonKS5pZ25vcmVSZXBvcnRzKClcbiAgKi9cblxuXG4gIGlnbm9yZVJlcG9ydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL2lnbm9yZV9yZXBvcnRzJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgaWQ6IHRoaXMubmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBVbmlnbm9yZXMgcmVwb3J0cyBvbiB0aGlzIENvbW1lbnQsIFN1Ym1pc3Npb24sIG9yIFByaXZhdGVNZXNzYWdlc1xuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgY29udGVudCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRDb21tZW50KCdjMDhwcDV6JykudW5pZ25vcmVSZXBvcnRzKClcbiAgKi9cblxuXG4gIHVuaWdub3JlUmVwb3J0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvdW5pZ25vcmVfcmVwb3J0cycsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgU3VibWl0cyBhIG5ldyByZXBseSB0byB0aGlzIG9iamVjdC4gKFRoaXMgdGFrZXMgdGhlIGZvcm0gb2YgYSBuZXcgQ29tbWVudCBpZiB0aGlzIG9iamVjdCBpcyBhIFN1Ym1pc3Npb24vQ29tbWVudCxcbiAgb3IgYSBuZXcgUHJpdmF0ZU1lc3NhZ2UgaWYgdGhpcyBvYmplY3QgaXMgYSBQcml2YXRlTWVzc2FnZS4pXG4gICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGNvbnRlbnQgb2YgdGhlIHJlcGx5LCBpbiByYXcgbWFya2Rvd24gdGV4dFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoZSBuZXdseS1jcmVhdGVkIHJlcGx5XG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCc0ZTYwbTMnKS5yZXBseSgnVGhpcyB3YXMgYW4gaW50ZXJlc3RpbmcgcG9zdC4gVGhhbmtzLicpO1xuICAqL1xuXG5cbiAgcmVwbHkodGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9jb21tZW50JyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHRoaW5nX2lkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS50YXAoKDAsIF9oZWxwZXJzLmhhbmRsZUpzb25FcnJvcnMpKHRoaXMpKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJldHVybiByZXMuanNvbi5kYXRhLnRoaW5nc1swXTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBCbG9ja3MgdGhlIGF1dGhvciBvZiB0aGlzIGNvbnRlbnQuXG4gICogQGRlc2MgKipOb3RlOioqIEluIG9yZGVyIGZvciB0aGlzIGZ1bmN0aW9uIHRvIGhhdmUgYW4gZWZmZWN0LCB0aGlzIGl0ZW0gKiptdXN0KiogYmUgaW4gdGhlIGF1dGhlbnRpY2F0ZWQgYWNjb3VudCdzIGluYm94IG9yXG4gIG1vZG1haWwgc29tZXdoZXJlLiBUaGUgcmVkZGl0IEFQSSBnaXZlcyBubyBvdXR3YXJkIGluZGljYXRpb24gb2Ygd2hldGhlciB0aGlzIGNvbmRpdGlvbiBpcyBzYXRpc2ZpZWQsIHNvIHRoZSByZXR1cm5lZCBQcm9taXNlXG4gIHdpbGwgZnVsZmlsbCBldmVuIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgbWVzc2FnZSBhZnRlciB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldEluYm94KHtsaW1pdDogMX0pLnRoZW4obWVzc2FnZXMgPT5cbiAgKiAgIG1lc3NhZ2VzWzBdLmJsb2NrQXV0aG9yKCk7XG4gICogKTtcbiAgKi9cblxuXG4gIGJsb2NrQXV0aG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9ibG9jaycsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cblxufTtcbnZhciBfZGVmYXVsdCA9IFJlcGx5YWJsZUNvbnRlbnQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/ReplyableContent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/Submission.js":
/*!**********************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/Submission.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _VoteableContent = _interopRequireDefault(__webpack_require__(/*! ./VoteableContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/VoteableContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar api_type = 'json';\n/**\n* A class representing a reddit submission\n* <style> #Submission {display: none} </style>\n* @extends VoteableContent\n* @example\n*\n* // Get a submission by ID\n* r.getSubmission('2np694')\n*/\n\nvar Submission = class Submission extends _VoteableContent.default {\n  constructor(data, _r, _hasFetched) {\n    super(data, _r, _hasFetched);\n\n    if (_hasFetched) {\n      this.comments = this.comments || (0, _helpers.getEmptyRepliesListing)(this);\n    }\n  }\n\n  get _uri() {\n    return \"comments/\".concat(this.name.slice(3));\n  }\n  /**\n  * @summary Hides this Submission, preventing it from appearing on most Listings.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').hide()\n  */\n\n\n  hide() {\n    return this._post({\n      uri: 'api/hide',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unhides this Submission, allowing it to reappear on most Listings.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').unhide()\n  */\n\n\n  unhide() {\n    return this._post({\n      uri: 'api/unhide',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Locks this Submission, preventing new comments from being posted on it.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').lock()\n  */\n\n\n  lock() {\n    return this._post({\n      uri: 'api/lock',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unlocks this Submission, allowing comments to be posted on it again.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').unlock()\n  */\n\n\n  unlock() {\n    return this._post({\n      uri: 'api/unlock',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Marks this Submission as NSFW (Not Safe For Work).\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').markNsfw()\n  */\n\n\n  markNsfw() {\n    return this._post({\n      uri: 'api/marknsfw',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unmarks this Submission as NSFW (Not Safe For Work).\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').unmarkNsfw()\n  */\n\n\n  unmarkNsfw() {\n    return this._post({\n      uri: 'api/unmarknsfw',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Mark a submission as a spoiler\n  * @desc **Note:** This will silently fail if the subreddit has disabled spoilers.\n  * @returns {Promise} A Promise that fulfills with this Submission when the request is complete\n  * @example r.getSubmission('2np694').markSpoiler()\n  */\n\n\n  markSpoiler() {\n    return this._post({\n      uri: 'api/spoiler',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unmark a submission as a spoiler\n  * @returns {Promise} A Promise that fulfills with this Submission when the request is complete\n  * @example r.getSubmission('2np694').unmarkSpoiler()\n  */\n\n\n  unmarkSpoiler() {\n    return this._post({\n      uri: 'api/unspoiler',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Sets the contest mode status of this submission.\n  * @private\n  * @param {boolean} state The desired contest mode status\n  * @returns {Promise} The updated version of this Submission\n  */\n\n\n  _setContestModeEnabled(state) {\n    return this._post({\n      uri: 'api/set_contest_mode',\n      form: {\n        api_type,\n        state,\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Enables contest mode for this Submission.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').enableContestMode()\n  */\n\n\n  enableContestMode() {\n    return this._setContestModeEnabled(true);\n  }\n  /**\n  * @summary Disables contest mode for this Submission.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').disableContestMode()\n  */\n\n\n  disableContestMode() {\n    return this._setContestModeEnabled(false);\n  }\n\n  _setStickied(_ref) {\n    var state = _ref.state,\n        num = _ref.num;\n    return this._post({\n      uri: 'api/set_subreddit_sticky',\n      form: {\n        api_type,\n        state,\n        num,\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Stickies this Submission.\n  * @param {object} [options]\n  * @param {number} [options.num=1] The sticky slot to put this submission in; this should be either 1 or 2.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').sticky({num: 2})\n  */\n\n\n  sticky() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$num = _ref2.num,\n        num = _ref2$num === void 0 ? 1 : _ref2$num;\n\n    return this._setStickied({\n      state: true,\n      num\n    });\n  }\n  /**\n  * @summary Unstickies this Submission.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').unsticky()\n  */\n\n\n  unsticky() {\n    return this._setStickied({\n      state: false\n    });\n  }\n  /**\n  * @summary Sets the suggested comment sort method on this Submission\n  * @desc **Note**: To enable contest mode, use {@link Submission#enableContestMode} instead.\n  * @param {string} sort The suggested sort method. This should be one of\n  `confidence, top, new, controversial, old, random, qa, blank`\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').setSuggestedSort('new')\n  */\n\n\n  setSuggestedSort(sort) {\n    return this._post({\n      uri: 'api/set_suggested_sort',\n      form: {\n        api_type,\n        id: this.name,\n        sort\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Marks this submission as 'visited'.\n  * @desc **Note**: This function only works if the authenticated account has a subscription to reddit gold.\n  * @returns {Promise} The updated version of this Submission\n  * @example r.getSubmission('2np694').markAsRead()\n  */\n\n\n  markAsRead() {\n    return this._post({\n      uri: 'api/store_visits',\n      form: {\n        links: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Gets a Listing of other submissions on reddit that had the same link as this one.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @returns {Promise} A Listing of other Submission objects\n  * @example r.getSubmission('2np694').getDuplicates()\n  */\n\n\n  getDuplicates() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"duplicates/\".concat(this.name.slice(3)),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a Listing of Submissions that are related to this one.\n  * @deprecated This function uses the <code>/related/submission_id</code> endpoint, which was recently changed on reddit.com;\n  instead of returning a Listing containing related posts, the reddit API now simply returns the post itself. As such, this\n  function only exists for backwards compatability and should not be used in practice.\n  * @param {object} [options={}] ~~Options for the resulting Listing~~\n  * @returns {Promise} ~~A Listing of other Submission objects~~ The submission in question.\n  * @example r.getSubmission('2np694').getRelated()\n  */\n\n\n  getRelated() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"related/\".concat(this.name.slice(3)),\n      qs: options\n    }).tap(function (result) {\n      if (result.constructor._name === 'Submission') {\n        _this._r._warn('Submission#getRelated has been deprecated upstream, and will not work as expected.');\n      }\n    });\n  }\n  /**\n  * @summary Gets a list of flair template options for this post.\n  * @returns {Promise} An Array of flair templates\n  * @example\n  *\n  * r.getSubmission('2np694').getLinkFlairTemplates().then(console.log)\n  *\n  * // => [\n  * //   { flair_text: 'Text 1', flair_css_class: '', flair_text_editable: false, flair_template_id: '(UUID not shown)' ... },\n  * //   { flair_text: 'Text 2', flair_css_class: 'aa', flair_text_editable: false, flair_template_id: '(UUID not shown)' ... },\n  * //   ...\n  * // ]\n  */\n\n\n  getLinkFlairTemplates() {\n    var _this2 = this;\n\n    return this.fetch().get('subreddit').then(function (sub) {\n      return sub.getLinkFlairTemplates(_this2.name);\n    });\n  }\n  /**\n  * @summary Assigns flair on this Submission (as a moderator; also see [selectFlair]{@link Submission#selectFlair})\n  * @param {object} options\n  * @param {string} options.text The text that this link's flair should have\n  * @param {string} options.cssClass The CSS class that the link's flair should have\n  * @returns {Promise} A Promise that fulfills with an updated version of this Submission\n  * @example r.getSubmission('2np694').assignFlair({text: 'this is a flair text', cssClass: 'these are css classes'})\n  */\n\n\n  assignFlair(options) {\n    return this._r._assignFlair(_objectSpread({}, options, {\n      link: this.name,\n      subredditName: this.subreddit.display_name\n    })).return(this);\n  }\n  /**\n  * @summary Selects a flair for this Submission (as the OP; also see [assignFlair]{@link Submission#assignFlair})\n  * @param {object} options\n  * @param {string} options.flair_template_id A flair template ID to use for this Submission. (This should be obtained\n  beforehand using {@link getLinkFlairTemplates}.)\n  * @param {string} [options.text] The flair text to use for the submission. (This is only necessary/useful if the given flair\n  template has the `text_editable` property set to `true`.)\n  * @returns {Promise} A Promise that fulfills with this objects after the request is complete\n  * @example r.getSubmission('2np694').selectFlair({flair_template_id: 'e3340d80-8152-11e4-a76a-22000bc1096c'})\n  */\n\n\n  selectFlair(options) {\n    return this._r._selectFlair(_objectSpread({}, options, {\n      link: this.name,\n      subredditName: this.subreddit.display_name\n    })).return(this);\n  }\n  /**\n   * @summary Crossposts this submission to a different subreddit\n   * @desc **NOTE**: To create a crosspost, the authenticated account must be subscribed to the subreddit where\n   * the crosspost is being submitted, and that subreddit be configured to allow crossposts.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the crosspost should be submitted to\n   * @param {string} options.title The title of the crosspost\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * await r.getSubmission('6vths0').submitCrosspost({ title: 'I found an interesting post', subredditName: 'snoowrap' })\n   */\n\n\n  submitCrosspost(options) {\n    return this._r.submitCrosspost(_objectSpread({}, options, {\n      originalPost: this\n    }));\n  }\n\n};\nvar _default = Submission;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1N1Ym1pc3Npb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsZUFBZSxtQkFBTyxDQUFDLG9FQUFlOztBQUV0Qyw4Q0FBOEMsbUJBQU8sQ0FBQywyRkFBc0I7O0FBRTVFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsaUVBQWlFLEdBQUcsa0NBQWtDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLCtDQUErQyw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8seUNBQXlDLG1GQUFtRixPQUFPOztBQUV0Ziw0Q0FBNEMsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjs7QUFFcE07QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsdURBQXVELGlFQUFpRTtBQUN4SDs7O0FBR0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL2Rpc3Qvb2JqZWN0cy9TdWJtaXNzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKFwiLi4vaGVscGVycy5qc1wiKTtcblxudmFyIF9Wb3RlYWJsZUNvbnRlbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1ZvdGVhYmxlQ29udGVudC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBhcGlfdHlwZSA9ICdqc29uJztcbi8qKlxuKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHJlZGRpdCBzdWJtaXNzaW9uXG4qIDxzdHlsZT4gI1N1Ym1pc3Npb24ge2Rpc3BsYXk6IG5vbmV9IDwvc3R5bGU+XG4qIEBleHRlbmRzIFZvdGVhYmxlQ29udGVudFxuKiBAZXhhbXBsZVxuKlxuKiAvLyBHZXQgYSBzdWJtaXNzaW9uIGJ5IElEXG4qIHIuZ2V0U3VibWlzc2lvbignMm5wNjk0JylcbiovXG5cbnZhciBTdWJtaXNzaW9uID0gY2xhc3MgU3VibWlzc2lvbiBleHRlbmRzIF9Wb3RlYWJsZUNvbnRlbnQuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIF9yLCBfaGFzRmV0Y2hlZCkge1xuICAgIHN1cGVyKGRhdGEsIF9yLCBfaGFzRmV0Y2hlZCk7XG5cbiAgICBpZiAoX2hhc0ZldGNoZWQpIHtcbiAgICAgIHRoaXMuY29tbWVudHMgPSB0aGlzLmNvbW1lbnRzIHx8ICgwLCBfaGVscGVycy5nZXRFbXB0eVJlcGxpZXNMaXN0aW5nKSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX3VyaSgpIHtcbiAgICByZXR1cm4gXCJjb21tZW50cy9cIi5jb25jYXQodGhpcy5uYW1lLnNsaWNlKDMpKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBIaWRlcyB0aGlzIFN1Ym1pc3Npb24sIHByZXZlbnRpbmcgaXQgZnJvbSBhcHBlYXJpbmcgb24gbW9zdCBMaXN0aW5ncy5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGlzIFN1Ym1pc3Npb25cbiAgKiBAZXhhbXBsZSByLmdldFN1Ym1pc3Npb24oJzJucDY5NCcpLmhpZGUoKVxuICAqL1xuXG5cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvaGlkZScsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgVW5oaWRlcyB0aGlzIFN1Ym1pc3Npb24sIGFsbG93aW5nIGl0IHRvIHJlYXBwZWFyIG9uIG1vc3QgTGlzdGluZ3MuXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS51bmhpZGUoKVxuICAqL1xuXG5cbiAgdW5oaWRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS91bmhpZGUnLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IExvY2tzIHRoaXMgU3VibWlzc2lvbiwgcHJldmVudGluZyBuZXcgY29tbWVudHMgZnJvbSBiZWluZyBwb3N0ZWQgb24gaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5sb2NrKClcbiAgKi9cblxuXG4gIGxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL2xvY2snLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVubG9ja3MgdGhpcyBTdWJtaXNzaW9uLCBhbGxvd2luZyBjb21tZW50cyB0byBiZSBwb3N0ZWQgb24gaXQgYWdhaW4uXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS51bmxvY2soKVxuICAqL1xuXG5cbiAgdW5sb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS91bmxvY2snLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IE1hcmtzIHRoaXMgU3VibWlzc2lvbiBhcyBOU0ZXIChOb3QgU2FmZSBGb3IgV29yaykuXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5tYXJrTnNmdygpXG4gICovXG5cblxuICBtYXJrTnNmdygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvbWFya25zZncnLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVubWFya3MgdGhpcyBTdWJtaXNzaW9uIGFzIE5TRlcgKE5vdCBTYWZlIEZvciBXb3JrKS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGlzIFN1Ym1pc3Npb25cbiAgKiBAZXhhbXBsZSByLmdldFN1Ym1pc3Npb24oJzJucDY5NCcpLnVubWFya05zZncoKVxuICAqL1xuXG5cbiAgdW5tYXJrTnNmdygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvdW5tYXJrbnNmdycsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgTWFyayBhIHN1Ym1pc3Npb24gYXMgYSBzcG9pbGVyXG4gICogQGRlc2MgKipOb3RlOioqIFRoaXMgd2lsbCBzaWxlbnRseSBmYWlsIGlmIHRoZSBzdWJyZWRkaXQgaGFzIGRpc2FibGVkIHNwb2lsZXJzLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VibWlzc2lvbiB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5tYXJrU3BvaWxlcigpXG4gICovXG5cblxuICBtYXJrU3BvaWxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvc3BvaWxlcicsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgVW5tYXJrIGEgc3VibWlzc2lvbiBhcyBhIHNwb2lsZXJcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1Ym1pc3Npb24gd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VibWlzc2lvbignMm5wNjk0JykudW5tYXJrU3BvaWxlcigpXG4gICovXG5cblxuICB1bm1hcmtTcG9pbGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS91bnNwb2lsZXInLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFNldHMgdGhlIGNvbnRlc3QgbW9kZSBzdGF0dXMgb2YgdGhpcyBzdWJtaXNzaW9uLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSBUaGUgZGVzaXJlZCBjb250ZXN0IG1vZGUgc3RhdHVzXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICovXG5cblxuICBfc2V0Q29udGVzdE1vZGVFbmFibGVkKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3NldF9jb250ZXN0X21vZGUnLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGlkOiB0aGlzLm5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRW5hYmxlcyBjb250ZXN0IG1vZGUgZm9yIHRoaXMgU3VibWlzc2lvbi5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGlzIFN1Ym1pc3Npb25cbiAgKiBAZXhhbXBsZSByLmdldFN1Ym1pc3Npb24oJzJucDY5NCcpLmVuYWJsZUNvbnRlc3RNb2RlKClcbiAgKi9cblxuXG4gIGVuYWJsZUNvbnRlc3RNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXRDb250ZXN0TW9kZUVuYWJsZWQodHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRGlzYWJsZXMgY29udGVzdCBtb2RlIGZvciB0aGlzIFN1Ym1pc3Npb24uXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5kaXNhYmxlQ29udGVzdE1vZGUoKVxuICAqL1xuXG5cbiAgZGlzYWJsZUNvbnRlc3RNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXRDb250ZXN0TW9kZUVuYWJsZWQoZmFsc2UpO1xuICB9XG5cbiAgX3NldFN0aWNraWVkKF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICBudW0gPSBfcmVmLm51bTtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvc2V0X3N1YnJlZGRpdF9zdGlja3knLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIG51bSxcbiAgICAgICAgaWQ6IHRoaXMubmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBTdGlja2llcyB0aGlzIFN1Ym1pc3Npb24uXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5udW09MV0gVGhlIHN0aWNreSBzbG90IHRvIHB1dCB0aGlzIHN1Ym1pc3Npb24gaW47IHRoaXMgc2hvdWxkIGJlIGVpdGhlciAxIG9yIDIuXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5zdGlja3koe251bTogMn0pXG4gICovXG5cblxuICBzdGlja3koKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZjIkbnVtID0gX3JlZjIubnVtLFxuICAgICAgICBudW0gPSBfcmVmMiRudW0gPT09IHZvaWQgMCA/IDEgOiBfcmVmMiRudW07XG5cbiAgICByZXR1cm4gdGhpcy5fc2V0U3RpY2tpZWQoe1xuICAgICAgc3RhdGU6IHRydWUsXG4gICAgICBudW1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBVbnN0aWNraWVzIHRoaXMgU3VibWlzc2lvbi5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGlzIFN1Ym1pc3Npb25cbiAgKiBAZXhhbXBsZSByLmdldFN1Ym1pc3Npb24oJzJucDY5NCcpLnVuc3RpY2t5KClcbiAgKi9cblxuXG4gIHVuc3RpY2t5KCkge1xuICAgIHJldHVybiB0aGlzLl9zZXRTdGlja2llZCh7XG4gICAgICBzdGF0ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBTZXRzIHRoZSBzdWdnZXN0ZWQgY29tbWVudCBzb3J0IG1ldGhvZCBvbiB0aGlzIFN1Ym1pc3Npb25cbiAgKiBAZGVzYyAqKk5vdGUqKjogVG8gZW5hYmxlIGNvbnRlc3QgbW9kZSwgdXNlIHtAbGluayBTdWJtaXNzaW9uI2VuYWJsZUNvbnRlc3RNb2RlfSBpbnN0ZWFkLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0IFRoZSBzdWdnZXN0ZWQgc29ydCBtZXRob2QuIFRoaXMgc2hvdWxkIGJlIG9uZSBvZlxuICBgY29uZmlkZW5jZSwgdG9wLCBuZXcsIGNvbnRyb3ZlcnNpYWwsIG9sZCwgcmFuZG9tLCBxYSwgYmxhbmtgXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5zZXRTdWdnZXN0ZWRTb3J0KCduZXcnKVxuICAqL1xuXG5cbiAgc2V0U3VnZ2VzdGVkU29ydChzb3J0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3NldF9zdWdnZXN0ZWRfc29ydCcsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlLFxuICAgICAgICBpZDogdGhpcy5uYW1lLFxuICAgICAgICBzb3J0XG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IE1hcmtzIHRoaXMgc3VibWlzc2lvbiBhcyAndmlzaXRlZCcuXG4gICogQGRlc2MgKipOb3RlKio6IFRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyBpZiB0aGUgYXV0aGVudGljYXRlZCBhY2NvdW50IGhhcyBhIHN1YnNjcmlwdGlvbiB0byByZWRkaXQgZ29sZC5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGlzIFN1Ym1pc3Npb25cbiAgKiBAZXhhbXBsZSByLmdldFN1Ym1pc3Npb24oJzJucDY5NCcpLm1hcmtBc1JlYWQoKVxuICAqL1xuXG5cbiAgbWFya0FzUmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvc3RvcmVfdmlzaXRzJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgbGlua3M6IHRoaXMubmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiBvdGhlciBzdWJtaXNzaW9ucyBvbiByZWRkaXQgdGhhdCBoYWQgdGhlIHNhbWUgbGluayBhcyB0aGlzIG9uZS5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3Rpbmcgb2Ygb3RoZXIgU3VibWlzc2lvbiBvYmplY3RzXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5nZXREdXBsaWNhdGVzKClcbiAgKi9cblxuXG4gIGdldER1cGxpY2F0ZXMoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJkdXBsaWNhdGVzL1wiLmNvbmNhdCh0aGlzLm5hbWUuc2xpY2UoMykpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiBTdWJtaXNzaW9ucyB0aGF0IGFyZSByZWxhdGVkIHRvIHRoaXMgb25lLlxuICAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgPGNvZGU+L3JlbGF0ZWQvc3VibWlzc2lvbl9pZDwvY29kZT4gZW5kcG9pbnQsIHdoaWNoIHdhcyByZWNlbnRseSBjaGFuZ2VkIG9uIHJlZGRpdC5jb207XG4gIGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgTGlzdGluZyBjb250YWluaW5nIHJlbGF0ZWQgcG9zdHMsIHRoZSByZWRkaXQgQVBJIG5vdyBzaW1wbHkgcmV0dXJucyB0aGUgcG9zdCBpdHNlbGYuIEFzIHN1Y2gsIHRoaXNcbiAgZnVuY3Rpb24gb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5IGFuZCBzaG91bGQgbm90IGJlIHVzZWQgaW4gcHJhY3RpY2UuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSB+fk9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ35+XG4gICogQHJldHVybnMge1Byb21pc2V9IH5+QSBMaXN0aW5nIG9mIG90aGVyIFN1Ym1pc3Npb24gb2JqZWN0c35+IFRoZSBzdWJtaXNzaW9uIGluIHF1ZXN0aW9uLlxuICAqIEBleGFtcGxlIHIuZ2V0U3VibWlzc2lvbignMm5wNjk0JykuZ2V0UmVsYXRlZCgpXG4gICovXG5cblxuICBnZXRSZWxhdGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInJlbGF0ZWQvXCIuY29uY2F0KHRoaXMubmFtZS5zbGljZSgzKSksXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pLnRhcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0LmNvbnN0cnVjdG9yLl9uYW1lID09PSAnU3VibWlzc2lvbicpIHtcbiAgICAgICAgX3RoaXMuX3IuX3dhcm4oJ1N1Ym1pc3Npb24jZ2V0UmVsYXRlZCBoYXMgYmVlbiBkZXByZWNhdGVkIHVwc3RyZWFtLCBhbmQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiBmbGFpciB0ZW1wbGF0ZSBvcHRpb25zIGZvciB0aGlzIHBvc3QuXG4gICogQHJldHVybnMge1Byb21pc2V9IEFuIEFycmF5IG9mIGZsYWlyIHRlbXBsYXRlc1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1Ym1pc3Npb24oJzJucDY5NCcpLmdldExpbmtGbGFpclRlbXBsYXRlcygpLnRoZW4oY29uc29sZS5sb2cpXG4gICpcbiAgKiAvLyA9PiBbXG4gICogLy8gICB7IGZsYWlyX3RleHQ6ICdUZXh0IDEnLCBmbGFpcl9jc3NfY2xhc3M6ICcnLCBmbGFpcl90ZXh0X2VkaXRhYmxlOiBmYWxzZSwgZmxhaXJfdGVtcGxhdGVfaWQ6ICcoVVVJRCBub3Qgc2hvd24pJyAuLi4gfSxcbiAgKiAvLyAgIHsgZmxhaXJfdGV4dDogJ1RleHQgMicsIGZsYWlyX2Nzc19jbGFzczogJ2FhJywgZmxhaXJfdGV4dF9lZGl0YWJsZTogZmFsc2UsIGZsYWlyX3RlbXBsYXRlX2lkOiAnKFVVSUQgbm90IHNob3duKScgLi4uIH0sXG4gICogLy8gICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRMaW5rRmxhaXJUZW1wbGF0ZXMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5mZXRjaCgpLmdldCgnc3VicmVkZGl0JykudGhlbihmdW5jdGlvbiAoc3ViKSB7XG4gICAgICByZXR1cm4gc3ViLmdldExpbmtGbGFpclRlbXBsYXRlcyhfdGhpczIubmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgQXNzaWducyBmbGFpciBvbiB0aGlzIFN1Ym1pc3Npb24gKGFzIGEgbW9kZXJhdG9yOyBhbHNvIHNlZSBbc2VsZWN0RmxhaXJde0BsaW5rIFN1Ym1pc3Npb24jc2VsZWN0RmxhaXJ9KVxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGV4dCBUaGUgdGV4dCB0aGF0IHRoaXMgbGluaydzIGZsYWlyIHNob3VsZCBoYXZlXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY3NzQ2xhc3MgVGhlIENTUyBjbGFzcyB0aGF0IHRoZSBsaW5rJ3MgZmxhaXIgc2hvdWxkIGhhdmVcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhpcyBTdWJtaXNzaW9uXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS5hc3NpZ25GbGFpcih7dGV4dDogJ3RoaXMgaXMgYSBmbGFpciB0ZXh0JywgY3NzQ2xhc3M6ICd0aGVzZSBhcmUgY3NzIGNsYXNzZXMnfSlcbiAgKi9cblxuXG4gIGFzc2lnbkZsYWlyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fci5fYXNzaWduRmxhaXIoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgbGluazogdGhpcy5uYW1lLFxuICAgICAgc3VicmVkZGl0TmFtZTogdGhpcy5zdWJyZWRkaXQuZGlzcGxheV9uYW1lXG4gICAgfSkpLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBTZWxlY3RzIGEgZmxhaXIgZm9yIHRoaXMgU3VibWlzc2lvbiAoYXMgdGhlIE9QOyBhbHNvIHNlZSBbYXNzaWduRmxhaXJde0BsaW5rIFN1Ym1pc3Npb24jYXNzaWduRmxhaXJ9KVxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZmxhaXJfdGVtcGxhdGVfaWQgQSBmbGFpciB0ZW1wbGF0ZSBJRCB0byB1c2UgZm9yIHRoaXMgU3VibWlzc2lvbi4gKFRoaXMgc2hvdWxkIGJlIG9idGFpbmVkXG4gIGJlZm9yZWhhbmQgdXNpbmcge0BsaW5rIGdldExpbmtGbGFpclRlbXBsYXRlc30uKVxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXh0XSBUaGUgZmxhaXIgdGV4dCB0byB1c2UgZm9yIHRoZSBzdWJtaXNzaW9uLiAoVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeS91c2VmdWwgaWYgdGhlIGdpdmVuIGZsYWlyXG4gIHRlbXBsYXRlIGhhcyB0aGUgYHRleHRfZWRpdGFibGVgIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAuKVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgb2JqZWN0cyBhZnRlciB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VibWlzc2lvbignMm5wNjk0Jykuc2VsZWN0RmxhaXIoe2ZsYWlyX3RlbXBsYXRlX2lkOiAnZTMzNDBkODAtODE1Mi0xMWU0LWE3NmEtMjIwMDBiYzEwOTZjJ30pXG4gICovXG5cblxuICBzZWxlY3RGbGFpcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3IuX3NlbGVjdEZsYWlyKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGxpbms6IHRoaXMubmFtZSxcbiAgICAgIHN1YnJlZGRpdE5hbWU6IHRoaXMuc3VicmVkZGl0LmRpc3BsYXlfbmFtZVxuICAgIH0pKS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENyb3NzcG9zdHMgdGhpcyBzdWJtaXNzaW9uIHRvIGEgZGlmZmVyZW50IHN1YnJlZGRpdFxuICAgKiBAZGVzYyAqKk5PVEUqKjogVG8gY3JlYXRlIGEgY3Jvc3Nwb3N0LCB0aGUgYXV0aGVudGljYXRlZCBhY2NvdW50IG11c3QgYmUgc3Vic2NyaWJlZCB0byB0aGUgc3VicmVkZGl0IHdoZXJlXG4gICAqIHRoZSBjcm9zc3Bvc3QgaXMgYmVpbmcgc3VibWl0dGVkLCBhbmQgdGhhdCBzdWJyZWRkaXQgYmUgY29uZmlndXJlZCB0byBhbGxvdyBjcm9zc3Bvc3RzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1YnJlZGRpdE5hbWUgVGhlIG5hbWUgb2YgdGhlIHN1YnJlZGRpdCB0aGF0IHRoZSBjcm9zc3Bvc3Qgc2hvdWxkIGJlIHN1Ym1pdHRlZCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSBUaGUgdGl0bGUgb2YgdGhlIGNyb3NzcG9zdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRSZXBsaWVzPXRydWVdIERldGVybWluZXMgd2hldGhlciBpbmJveCByZXBsaWVzIHNob3VsZCBiZSBlbmFibGVkIGZvciB0aGlzIHN1Ym1pc3Npb25cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXN1Ym1pdD10cnVlXSBJZiB0aGlzIGlzIGZhbHNlIGFuZCBzYW1lIGxpbmsgaGFzIGFscmVhZHkgYmVlbiBzdWJtaXR0ZWQgdG8gdGhpcyBzdWJyZWRkaXQgaW5cbiAgIHRoZSBwYXN0LCByZWRkaXQgd2lsbCByZXR1cm4gYW4gZXJyb3IuIFRoaXMgY291bGQgYmUgdXNlZCB0byBhdm9pZCBhY2NpZGVudGFsIHJlcG9zdHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgbmV3bHktY3JlYXRlZCBTdWJtaXNzaW9uIG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBhd2FpdCByLmdldFN1Ym1pc3Npb24oJzZ2dGhzMCcpLnN1Ym1pdENyb3NzcG9zdCh7IHRpdGxlOiAnSSBmb3VuZCBhbiBpbnRlcmVzdGluZyBwb3N0Jywgc3VicmVkZGl0TmFtZTogJ3Nub293cmFwJyB9KVxuICAgKi9cblxuXG4gIHN1Ym1pdENyb3NzcG9zdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Iuc3VibWl0Q3Jvc3Nwb3N0KF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIG9yaWdpbmFsUG9zdDogdGhpc1xuICAgIH0pKTtcbiAgfVxuXG59O1xudmFyIF9kZWZhdWx0ID0gU3VibWlzc2lvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/Submission.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/Subreddit.js":
/*!*********************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/Subreddit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _lodash = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ../Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _stream = __webpack_require__(/*! stream */ \"stream\");\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _errors = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/snoowrap/dist/errors.js\");\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar api_type = 'json';\n/**\n* A class representing a subreddit\n* <style> #Subreddit {display: none} </style>\n* @extends RedditContent\n* @example\n*\n* // Get a subreddit by name\n* r.getSubreddit('AskReddit')\n*/\n\nvar Subreddit = class Subreddit extends _RedditContent.default {\n  get _uri() {\n    return \"r/\".concat(this.display_name, \"/about\");\n  }\n\n  _transformApiResponse(response) {\n    if (!(response instanceof Subreddit)) {\n      throw new TypeError(\"The subreddit /r/\".concat(this.display_name, \" does not exist.\"));\n    }\n\n    return response;\n  }\n\n  _deleteFlairTemplates(_ref) {\n    var flair_type = _ref.flair_type;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/clearflairtemplates\"),\n      form: {\n        api_type,\n        flair_type\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Deletes all of this subreddit's user flair templates\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteAllUserFlairTemplates()\n  */\n\n\n  deleteAllUserFlairTemplates() {\n    return this._deleteFlairTemplates({\n      flair_type: 'USER_FLAIR'\n    });\n  }\n  /**\n  * @summary Deletes all of this subreddit's link flair templates\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteAllLinkFlairTemplates()\n  */\n\n\n  deleteAllLinkFlairTemplates() {\n    return this._deleteFlairTemplates({\n      flair_type: 'LINK_FLAIR'\n    });\n  }\n  /**\n  * @summary Deletes one of this subreddit's flair templates\n  * @param {object} options\n  * @param {string} options.flair_template_id The ID of the template that should be deleted\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteFlairTemplate({flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721'})\n  */\n\n\n  deleteFlairTemplate(_ref2) {\n    var flair_template_id = _ref2.flair_template_id;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/deleteflairtemplate\"),\n      form: {\n        api_type,\n        flair_template_id\n      }\n    }).return(this);\n  }\n\n  _createFlairTemplate(_ref3) {\n    var text = _ref3.text,\n        css_class = _ref3.css_class,\n        _ref3$cssClass = _ref3.cssClass,\n        cssClass = _ref3$cssClass === void 0 ? css_class : _ref3$cssClass,\n        flair_type = _ref3.flair_type,\n        _ref3$text_editable = _ref3.text_editable,\n        text_editable = _ref3$text_editable === void 0 ? false : _ref3$text_editable,\n        _ref3$textEditable = _ref3.textEditable,\n        textEditable = _ref3$textEditable === void 0 ? text_editable : _ref3$textEditable;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/flairtemplate\"),\n      form: {\n        api_type,\n        text,\n        css_class: cssClass,\n        flair_type,\n        text_editable: textEditable\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Creates a new user flair template for this subreddit\n  * @param {object} options\n  * @param {string} options.text The flair text for this template\n  * @param {string} [options.cssClass=''] The CSS class for this template\n  * @param {boolean} [options.textEditable=false] Determines whether users should be able to edit their flair text\n  when it has this template\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').createUserFlairTemplate({text: 'Some Flair Text', cssClass: 'some-css-class'})\n  */\n\n\n  createUserFlairTemplate(options) {\n    return this._createFlairTemplate(_objectSpread({}, options, {\n      flair_type: 'USER_FLAIR'\n    }));\n  }\n  /**\n  * @summary Creates a new link flair template for this subreddit\n  * @param {object} options\n  * @param {string} options.text The flair text for this template\n  * @param {string} [options.cssClass=''] The CSS class for this template\n  * @param {boolean} [options.textEditable=false] Determines whether users should be able to edit the flair text of their\n  links when it has this template\n  * @returns {Promise} A Promise that fulfills with this Subredit when the request is complete.\n  * @example r.getSubreddit('snoowrap').createLinkFlairTemplate({text: 'Some Flair Text', cssClass: 'some-css-class'})\n  */\n\n\n  createLinkFlairTemplate(options) {\n    return this._createFlairTemplate(_objectSpread({}, options, {\n      flair_type: 'LINK_FLAIR'\n    }));\n  }\n\n  _getFlairOptions() {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        name = _ref4.name,\n        link = _ref4.link,\n        is_newlink = _ref4.is_newlink;\n\n    // TODO: Add shortcuts for this on RedditUser and Submission\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/flairselector\"),\n      form: {\n        name,\n        link,\n        is_newlink\n      }\n    });\n  }\n  /**\n  * @summary Gets the flair templates for the subreddit or a given link.\n  * @param {string} [linkId] The link's base36 ID\n  * @returns {Promise} An Array of flair template options\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getLinkFlairTemplates('4fp36y').then(console.log)\n  // => [ { flair_css_class: '',\n  //  flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721',\n  //  flair_text_editable: true,\n  //  flair_position: 'right',\n  //  flair_text: '' },\n  //  { flair_css_class: '',\n  //  flair_template_id: '03821f62-c920-11e5-b608-0e309fbcf863',\n  //  flair_text_editable: true,\n  //  flair_position: 'right',\n  //  flair_text: '' },\n  //  ...\n  // ]\n  */\n\n\n  getLinkFlairTemplates() {\n    var linkId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = linkId ? {\n      link: linkId\n    } : {\n      is_newlink: true\n    };\n    return this._getFlairOptions(options).get('choices');\n  }\n  /**\n  * @summary Gets the list of user flair templates on this subreddit.\n  * @returns {Promise} An Array of user flair templates\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getUserFlairTemplates().then(console.log)\n  // => [ { flair_css_class: '',\n  //  flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721',\n  //  flair_text_editable: true,\n  //  flair_position: 'right',\n  //  flair_text: '' },\n  //  { flair_css_class: '',\n  //  flair_template_id: '03821f62-c920-11e5-b608-0e309fbcf863',\n  //  flair_text_editable: true,\n  //  flair_position: 'right',\n  //  flair_text: '' },\n  //  ...\n  // ]\n  */\n\n\n  getUserFlairTemplates() {\n    return this._getFlairOptions().get('choices');\n  }\n  /**\n  * @summary Clears a user's flair on this subreddit.\n  * @param {string} name The user's name\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteUserFlair('actually_an_aardvark')\n  */\n\n\n  deleteUserFlair(name) {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/deleteflair\"),\n      form: {\n        api_type,\n        name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Gets a user's flair on this subreddit.\n  * @param {string} name The user's name\n  * @returns {Promise} An object representing the user's flair\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getUserFlair('actually_an_aardvark').then(console.log)\n  // => { flair_css_class: '',\n  //  flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721',\n  //  flair_text: '',\n  //  flair_position: 'right'\n  // }\n  */\n\n\n  getUserFlair(name) {\n    return this._getFlairOptions({\n      name\n    }).get('current');\n  }\n  /**\n  * @summary Sets multiple user flairs at the same time\n  * @desc Due to the behavior of the reddit API endpoint that this function uses, if any of the provided user flairs are\n  invalid, reddit will make note of this in its response, but it will still attempt to set the remaining user flairs. If this\n  occurs, the Promise returned by snoowrap will be rejected, and the rejection reason will be an array containing the 'error'\n  responses from reddit.\n  * @param {object[]} flairArray\n  * @param {string} flairArray[].name A user's name\n  * @param {string} flairArray[].text The flair text to assign to this user\n  * @param {string} flairArray[].cssClass The flair CSS class to assign to this user\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example\n  * r.getSubreddit('snoowrap').setMultipleUserFlairs([\n  *   {name: 'actually_an_aardvark', text: \"this is /u/actually_an_aardvark's flair text\", cssClass: 'some-css-class'},\n  *   {name: 'snoowrap_testing', text: \"this is /u/snoowrap_testing's flair text\", cssClass: 'some-css-class'}\n  * ]);\n  * // the above request gets completed successfully\n  *\n  * r.getSubreddit('snoowrap').setMultipleUserFlairs([\n  *   {name: 'actually_an_aardvark', text: 'foo', cssClass: 'valid-css-class'},\n  *   {name: 'snoowrap_testing', text: 'bar', cssClass: \"this isn't a valid css class\"},\n  *   {name: 'not_an_aardvark', text: 'baz', cssClass: \"this also isn't a valid css class\"}\n  * ])\n  * // the Promise from the above request gets rejected, with the following rejection reason:\n  * [\n  *   {\n  *     status: 'skipped',\n  *     errors: { css: 'invalid css class `this isn\\'t a valid css class\\', ignoring' },\n  *     ok: false,\n  *     warnings: {}\n  *   },\n  *   {\n  *     status: 'skipped',\n  *     errors: { css: 'invalid css class `this also isn\\'t a valid css class\\', ignoring' },\n  *     ok: false,\n  *     warnings: {}\n  *   }\n  * ]\n  * // note that /u/actually_an_aardvark's flair still got set by the request, even though the other two flairs caused errors.\n  */\n\n\n  setMultipleUserFlairs(flairArray) {\n    var _this = this;\n\n    var csvLines = flairArray.map(function (item) {\n      // reddit expects to receive valid CSV data, which each line having the form `username,flair_text,css_class`.\n      return [item.name, item.text || item.flairText || item.flair_text || '', item.cssClass || item.css_class || item.flairCssClass || item.flair_css_class || ''].map(function (str) {\n        /* To escape special characters in the lines (e.g. if the flair text itself contains a comma), surround each\n        part of the line with double quotes before joining the parts together with commas (in accordance with how special\n        characters are usually escaped in CSV). If double quotes are themselves part of the flair text, replace them with a\n        pair of consecutive double quotes. */\n        return \"\\\"\".concat(str.replace(/\"/g, '\"\"'), \"\\\"\");\n      }).join(',');\n    });\n    /* Due to an API limitation, this endpoint can only set the flair of 100 users at a time.\n    Send multiple requests if necessary to ensure that all users in the array are accounted for. */\n\n    return _Promise.default.map((0, _lodash.chunk)(csvLines, 100), function (flairChunk) {\n      return _this._post({\n        uri: \"r/\".concat(_this.display_name, \"/api/flaircsv\"),\n        form: {\n          flair_csv: flairChunk.join('\\n')\n        }\n      });\n    }).then(_lodash.flatten).tap(function (results) {\n      var errorRows = results.filter(function (row) {\n        return !row.ok;\n      });\n\n      if (errorRows.length) {\n        throw errorRows;\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Gets a list of all user flairs on this subreddit.\n  * @param {object} options\n  * @param {string} [options.name] A specific username to jump to\n  * @returns {Promise} A Listing containing user flairs\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getUserFlairList().then(console.log)\n  // => Listing [\n  //  { flair_css_class: null,\n  //  user: 'not_an_aardvark',\n  //  flair_text: 'Isn\\'t an aardvark' },\n  //  { flair_css_class: 'some-css-class',\n  //    user: 'actually_an_aardvark',\n  //    flair_text: 'this is /u/actually_an_aardvark\\'s flair text' },\n  //  { flair_css_class: 'some-css-class',\n  //    user: 'snoowrap_testing',\n  //    flair_text: 'this is /u/snoowrap_testing\\'s flair text' }\n  // ]\n  */\n\n\n  getUserFlairList() {\n    var _this2 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/api/flairlist\"),\n      qs: options,\n      _transform: function (response) {\n        /* For unknown reasons, responses from the api/flairlist endpoint are formatted differently than responses from all other\n        Listing endpoints. Most Listing endpoints return an object with a `children` property containing the Listing's children,\n        and `after` and `before` properties corresponding to the `after` and `before` querystring parameters that a client should\n        use in the next request. However, the api/flairlist endpoint returns an objecti with a `users` property containing the\n        Listing's children, and `next` and `prev` properties corresponding to the `after` and `before` querystring parameters. As\n        far as I can tell, there's no actual reason for this difference. >_> */\n        response.after = response.next || null;\n        response.before = response.prev || null;\n        response.children = response.users;\n        return _this2._r._newObject('Listing', response);\n      }\n    });\n  }\n  /**\n  * @summary Configures the flair settings for this subreddit.\n  * @param {object} options\n  * @param {boolean} options.userFlairEnabled Determines whether user flair should be enabled\n  * @param {string} options.userFlairPosition Determines the orientation of user flair relative to a given username. This\n  should be either the string 'left' or the string 'right'.\n  * @param {boolean} options.userFlairSelfAssignEnabled Determines whether users should be able to edit their own flair\n  * @param {string} options.linkFlairPosition Determines the orientation of link flair relative to a link title. This should\n  be either 'left' or 'right'.\n  * @param {boolean} options.linkFlairSelfAssignEnabled Determines whether users should be able to edit the flair of their\n  submissions.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').configure_flair({\n    userFlairEnabled: true,\n    userFlairPosition: 'left',\n    userFlairSelfAssignEnabled: false,\n    linkFlairPosition: 'right',\n    linkFlairSelfAssignEnabled: false\n  * })\n  */\n\n\n  configureFlair(_ref5) {\n    var user_flair_enabled = _ref5.user_flair_enabled,\n        _ref5$userFlairEnable = _ref5.userFlairEnabled,\n        userFlairEnabled = _ref5$userFlairEnable === void 0 ? user_flair_enabled : _ref5$userFlairEnable,\n        user_flair_position = _ref5.user_flair_position,\n        _ref5$userFlairPositi = _ref5.userFlairPosition,\n        userFlairPosition = _ref5$userFlairPositi === void 0 ? user_flair_position : _ref5$userFlairPositi,\n        user_flair_self_assign_enabled = _ref5.user_flair_self_assign_enabled,\n        _ref5$userFlairSelfAs = _ref5.userFlairSelfAssignEnabled,\n        userFlairSelfAssignEnabled = _ref5$userFlairSelfAs === void 0 ? user_flair_self_assign_enabled : _ref5$userFlairSelfAs,\n        link_flair_position = _ref5.link_flair_position,\n        _ref5$linkFlairPositi = _ref5.linkFlairPosition,\n        linkFlairPosition = _ref5$linkFlairPositi === void 0 ? link_flair_position : _ref5$linkFlairPositi,\n        link_flair_self_assign_enabled = _ref5.link_flair_self_assign_enabled,\n        _ref5$linkFlairSelfAs = _ref5.linkFlairSelfAssignEnabled,\n        linkFlairSelfAssignEnabled = _ref5$linkFlairSelfAs === void 0 ? link_flair_self_assign_enabled : _ref5$linkFlairSelfAs;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/flairconfig\"),\n      form: {\n        api_type,\n        flair_enabled: userFlairEnabled,\n        flair_position: userFlairPosition,\n        flair_self_assign_enabled: userFlairSelfAssignEnabled,\n        link_flair_position: linkFlairPosition,\n        link_flair_self_assign_enabled: linkFlairSelfAssignEnabled\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Gets the requester's flair on this subreddit.\n  * @returns {Promise} An object representing the requester's current flair\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getMyFlair().then(console.log)\n  // => { flair_css_class: 'some-css-class',\n  //  flair_template_id: null,\n  //  flair_text: 'this is /u/snoowrap_testing\\'s flair text',\n  //  flair_position: 'right'\n  // }\n  */\n\n\n  getMyFlair() {\n    return this._getFlairOptions().get('current');\n  }\n  /**\n  * @summary Sets the requester's flair on this subreddit.\n  * @param {object} options\n  * @param {string} options.flair_template_id A flair template ID to use. (This should be obtained beforehand using\n  {@link getUserFlairTemplates}.)\n  * @param {string} [options.text] The flair text to use. (This is only necessary/useful if the given flair\n  template has the `text_editable` property set to `true`.)\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').selectMyFlair({flair_template_id: 'fdfd8532-c91e-11e5-b4d4-0e082084d721'})\n  */\n\n\n  selectMyFlair(options) {\n    var _this3 = this;\n\n    /* NOTE: This requires `identity` scope in addition to `flair` scope, since the reddit api needs to be passed a username.\n    I'm not sure if there's a way to do this without requiring additional scope. */\n    return this._r._getMyName().then(function (name) {\n      return _this3._r._selectFlair(_objectSpread({}, options, {\n        subredditName: _this3.display_name,\n        name\n      }));\n    }).return(this);\n  }\n\n  _setMyFlairVisibility(flair_enabled) {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/setflairenabled\"),\n      form: {\n        api_type,\n        flair_enabled\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Makes the requester's flair visible on this subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').showMyFlair()\n  */\n\n\n  showMyFlair() {\n    return this._setMyFlairVisibility(true);\n  }\n  /**\n  * @summary Makes the requester's flair invisible on this subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').hideMyFlair()\n  */\n\n\n  hideMyFlair() {\n    return this._setMyFlairVisibility(false);\n  }\n  /**\n  * @summary Creates a new selfpost on this subreddit.\n  * @param {object} options An object containing details about the submission\n  * @param {string} options.title The title of the submission\n  * @param {string} [options.text] The selftext of the submission\n  * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n  * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n  requires a captcha to submit posts and comments.\n  * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n  * @returns {Promise} The newly-created Submission object\n  * @example\n  *\n  * r.getSubreddit('snoowrap').submitSelfpost({title: 'this is a selfpost', text: \"hi, how's it going?\"}).then(console.log)\n  * // => Submission { name: 't3_4abmsz' }\n  */\n\n\n  submitSelfpost(options) {\n    return this._r.submitSelfpost(_objectSpread({}, options, {\n      subredditName: this.display_name\n    }));\n  }\n  /**\n  * @summary Creates a new link submission on this subreddit.\n  * @param {object} options An object containing details about the submission\n  * @param {string} options.title The title of the submission\n  * @param {string} options.url The url that the link submission should point to\n  * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n  * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n  the past, reddit will return an error. This could be used to avoid accidental reposts.\n  * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n  requires a captcha to submit posts and comments.\n  * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n  * @returns {Promise} The newly-created Submission object\n  * @example\n  *\n  * r.getSubreddit('snoowrap').submitLink({title: 'I found a cool website', url: 'https://google.com'}).then(console.log)\n  * // => Submission { name: 't3_4abmsz' }\n  */\n\n\n  submitLink(options) {\n    return this._r.submitLink(_objectSpread({}, options, {\n      subredditName: this.display_name\n    }));\n  }\n  /**\n   * @summary Creates a new crosspost submission on this subreddit\n   * @desc **NOTE**: To create a crosspost, the authenticated account must be subscribed to the subreddit where\n   * the crosspost is being submitted, and that subreddit be configured to allow crossposts.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.title The title of the crosspost\n   * @param {string|Submission} options.originalPost A Submission object or a post ID for the original post which\n   is being crossposted\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * await r.getSubreddit('snoowrap').submitCrosspost({ title: 'I found an interesting post', originalPost: '6vths0' })\n   * // => Submission { name: 't3_4abmsz' }\n   */\n\n\n  submitCrosspost(options) {\n    return this._r.submitCrosspost(_objectSpread({}, options, {\n      subredditName: this.display_name\n    }));\n  }\n  /**\n  * @summary Gets a Listing of hot posts on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @returns {Promise} A Listing containing the retrieved submissions\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getHot().then(console.log)\n  * // => Listing [\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getHot(options) {\n    return this._r.getHot(this.display_name, options);\n  }\n  /**\n  * @summary Gets a Listing of new posts on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @returns {Promise} A Listing containing the retrieved submissions\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getNew().then(console.log)\n  * // => Listing [\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  *\n  */\n\n\n  getNew(options) {\n    return this._r.getNew(this.display_name, options);\n  }\n  /**\n  * @summary Gets a Listing of new comments on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @returns {Promise} A Listing containing the retrieved comments\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getNewComments().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getNewComments(options) {\n    return this._r.getNewComments(this.display_name, options);\n  }\n  /**\n  * @summary Gets a single random Submission from this subreddit.\n  * @desc **Note**: This function will not work when snoowrap is running in a browser, because the reddit server sends a\n  redirect which cannot be followed by a CORS request.\n  * @returns {Promise} The retrieved Submission object\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getRandomSubmission().then(console.log)\n  * // => Submission { ... }\n  */\n\n\n  getRandomSubmission() {\n    return this._r.getRandomSubmission(this.display_name);\n  }\n  /**\n  * @summary Gets a Listing of top posts on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n  `hour, day, week, month, year, all`\n  * @returns {Promise} A Listing containing the retrieved submissions\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getTop({time: 'all'}).then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getTop(options) {\n    return this._r.getTop(this.display_name, options);\n  }\n  /**\n  * @summary Gets a Listing of controversial posts on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n  `hour, day, week, month, year, all`\n  * @returns {Promise} A Listing containing the retrieved submissions\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getControversial({time: 'week'}).then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getControversial(options) {\n    return this._r.getControversial(this.display_name, options);\n  }\n  /**\n  * @summary Gets a Listing of top posts on this subreddit.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing the retrieved submissions\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getRising().then(console.log)\n  * // => Listing [\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getRising(options) {\n    return this._r.getRising(this.display_name, options);\n  }\n  /**\n  * @summary Gets the moderator mail for this subreddit.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing PrivateMessage objects\n  * @example r.getSubreddit('snoowrap').getModmail().then(console.log)\n  */\n\n\n  getModmail(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/message/moderator\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a list of ModmailConversations from the subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @returns {Promise<Listing<ModmailConversation>>} A Listing containing Subreddits\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getNewModmailConversations({limit: 2}).then(console.log)\n  * // => Listing [\n  * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... },\n  * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... }\n  * // ]\n  */\n\n\n  getNewModmailConversations() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._r.getNewModmailConversations(_objectSpread({}, options, {\n      entity: this.display_name\n    }));\n  }\n  /**\n  * @summary Gets the moderation log for this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string[]} [options.mods] An array of moderator names that the results should be restricted to\n  * @param {string} [options.type] Restricts the results to the specified type. This should be one of `banuser, unbanuser,\n  removelink, approvelink, removecomment, approvecomment, addmoderator, invitemoderator, uninvitemoderator,\n  acceptmoderatorinvite, removemoderator, addcontributor, removecontributor, editsettings, editflair, distinguish, marknsfw,\n  wikibanned, wikicontributor, wikiunbanned, wikipagelisted, removewikicontributor, wikirevise, wikipermlevel,\n  ignorereports, unignorereports, setpermissions, setsuggestedsort, sticky, unsticky, setcontestmode, unsetcontestmode,\n  lock, unlock, muteuser, unmuteuser, createrule, editrule, deleterule, spoiler, unspoiler`\n  * @returns {Promise} A Listing containing moderation actions\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getModerationLog().then(console.log)\n  *\n  * // => Listing [\n  * //  ModAction { description: null, mod: 'snoowrap_testing', action: 'editflair', ... }\n  * //  ModAction { description: null, mod: 'snoowrap_testing', action: 'approvecomment', ... }\n  * //  ModAction { description: null, mod: 'snoowrap_testing', action: 'createrule', ... }\n  * // ]\n  */\n\n\n  getModerationLog() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var parsedOptions = (0, _lodash.omit)(_objectSpread({}, options, {\n      mod: options.mods && options.mods.join(',')\n    }), 'mods');\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/log\"),\n      qs: parsedOptions\n    });\n  }\n  /**\n  * @summary Gets a list of reported items on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n  * @returns {Promise} A Listing containing reported items\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getReports().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getReports() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/reports\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a list of removed items on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n  * @returns {Promise} A Listing containing removed items\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getSpam().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getSpam() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/spam\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a list of items on the modqueue on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n  * @returns {Promise} A Listing containing items on the modqueue\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getModqueue().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getModqueue() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/modqueue\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a list of unmoderated items on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n  * @returns {Promise} A Listing containing unmoderated items\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getUnmoderated().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getUnmoderated() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/unmoderated\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Gets a list of edited items on this subreddit.\n  * @param {object} [options={}] Options for the resulting Listing\n  * @param {string} [options.only] Restricts the Listing to the specified type of item. One of `links, comments`\n  * @returns {Promise} A Listing containing edited items\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getEdited().then(console.log)\n  * // => Listing [\n  * //  Comment { ... },\n  * //  Comment { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getEdited() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/edited\"),\n      qs: options\n    });\n  }\n  /**\n  * @summary Accepts an invite to become a moderator of this subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').acceptModeratorInvite()\n  */\n\n\n  acceptModeratorInvite() {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/accept_moderator_invite\"),\n      form: {\n        api_type\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Abdicates moderator status on this subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').leaveModerator()\n  */\n\n\n  leaveModerator() {\n    var _this4 = this;\n\n    return this.fetch().get('name').then(function (name) {\n      return _this4._post({\n        uri: 'api/leavemoderator',\n        form: {\n          id: name\n        }\n      }).then((0, _helpers.handleJsonErrors)(_this4));\n    });\n  }\n  /**\n  * @summary Abdicates approved submitter status on this subreddit.\n  * @returns {Promise} A Promise that resolves with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').leaveContributor()\n  */\n\n\n  leaveContributor() {\n    var _this5 = this;\n\n    return this.fetch().get('name').then(function (name) {\n      return _this5._post({\n        uri: 'api/leavecontributor',\n        form: {\n          id: name\n        }\n      }).return(_this5);\n    });\n  }\n  /**\n  * @summary Gets a subreddit's CSS stylesheet.\n  * @desc **Note**: This function will not work when snoowrap is running in a browser, because the reddit server sends a\n  redirect which cannot be followed by a CORS request.\n  * @desc **Note**: This method will return a 404 error if the subreddit in question does not have a custom stylesheet.\n  * @returns {Promise} A Promise for a string containing the subreddit's CSS.\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getStylesheet().then(console.log)\n  * // => '.md blockquote,.md del,body{color:#121212}.usertext-body ... '\n  */\n\n\n  getStylesheet() {\n    return this._get({\n      uri: \"r/\".concat(this.display_name, \"/stylesheet\"),\n      json: false\n    });\n  }\n  /**\n  * @summary Conducts a search of reddit submissions, restricted to this subreddit.\n  * @param {object} options Search options. Can also contain options for the resulting Listing.\n  * @param {string} options.query The search query\n  * @param {string} [options.time] Describes the timespan that posts should be retrieved frome. One of\n  `hour, day, week, month, year, all`\n  * @param {string} [options.sort] Determines how the results should be sorted. One of `relevance, hot, top, new, comments`\n  * @param {string} [options.syntax='plain'] Specifies a syntax for the search. One of `cloudsearch, lucene, plain`\n  * @returns {Promise} A Listing containing the search results.\n  * @example\n  *\n  * r.getSubreddit('snoowrap').search({query: 'blah', sort: 'year'}).then(console.log)\n  * // => Listing [\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  search(options) {\n    return this._r.search(_objectSpread({}, options, {\n      subreddit: this,\n      restrictSr: true\n    }));\n  }\n  /**\n  * @summary Gets the list of banned users on this subreddit.\n  * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n  * @param {string} options.name A username on the list to jump to.\n  * @returns {Promise} A Listing of users\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getBannedUsers().then(console.log)\n  * // => Listing [\n  * //  { date: 1461720936, note: '', name: 'actually_an_aardvark', id: 't2_q3519' }\n  * //  ...\n  * // ]\n  *\n  */\n\n\n  getBannedUsers(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/banned\"),\n      qs: (0, _helpers.renameKey)(options, 'name', 'user')\n    });\n  }\n  /**\n  * @summary Gets the list of muted users on this subreddit.\n  * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n  * @param {string} options.name A username on the list to jump to.\n  * @returns {Promise} A Listing of users\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getBannedUsers().then(console.log)\n  * // => Listing [\n  * //  { date: 1461720936, name: 'actually_an_aardvark', id: 't2_q3519' }\n  * //  ...\n  * // ]\n  */\n\n\n  getMutedUsers(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/muted\"),\n      qs: (0, _helpers.renameKey)(options, 'name', 'user')\n    });\n  }\n  /**\n  * @summary Gets the list of users banned from this subreddit's wiki.\n  * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n  * @param {string} options.name A username on the list to jump to.\n  * @returns {Promise} A Listing of users\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getWikibannedUsers().then(console.log)\n  * // => Listing [\n  * //  { date: 1461720936, note: '', name: 'actually_an_aardvark', id: 't2_q3519' }\n  * //  ...\n  * // ]\n  */\n\n\n  getWikibannedUsers(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/wikibanned\"),\n      qs: (0, _helpers.renameKey)(options, 'name', 'user')\n    });\n  }\n  /**\n  * @summary Gets the list of approved submitters on this subreddit.\n  * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n  * @param {string} options.name A username on the list to jump to.\n  * @returns {Promise} A Listing of users\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getContributors().then(console.log)\n  * // => Listing [\n  * //  { date: 1461720936, name: 'actually_an_aardvark', id: 't2_q3519' }\n  * //  ...\n  * // ]\n  */\n\n\n  getContributors(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/contributors\"),\n      qs: (0, _helpers.renameKey)(options, 'name', 'user')\n    });\n  }\n  /**\n  * @summary Gets the list of approved wiki submitters on this subreddit .\n  * @param {object} options Filtering options. Can also contain options for the resulting Listing.\n  * @param {string} options.name A username on the list to jump to.\n  * @returns {Promise} A Listing of users\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getWikiContributors().then(console.log)\n  * // => Listing [\n  * //  { date: 1461720936, name: 'actually_an_aardvark', id: 't2_q3519' }\n  * //  ...\n  * // ]\n  */\n\n\n  getWikiContributors(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/about/wikicontributors\"),\n      qs: (0, _helpers.renameKey)(options, 'name', 'user')\n    });\n  }\n  /**\n  * @summary Gets the list of moderators on this subreddit.\n  * @param {object} options\n  * @param {string} [options.name] The name of a user to find in the list\n  * @returns {Promise} An Array of RedditUsers representing the moderators of this subreddit\n  * @example\n  *\n  * r.getSubreddit('AskReddit').getModerators().then(console.log)\n  * // => [\n  * //  RedditUser { date: 1453862639, mod_permissions: [ 'all' ], name: 'not_an_aardvark', id: 't2_k83md' },\n  * //  ...\n  * // ]\n  *\n  */\n\n\n  getModerators() {\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        name = _ref6.name;\n\n    return this._get({\n      uri: \"r/\".concat(this.display_name, \"/about/moderators\"),\n      qs: {\n        user: name\n      }\n    });\n  }\n  /**\n  * @summary Deletes the banner for this Subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteBanner()\n  */\n\n\n  deleteBanner() {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/delete_sr_banner\"),\n      form: {\n        api_type\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Deletes the header image for this Subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteHeader()\n  */\n\n\n  deleteHeader() {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/delete_sr_header\"),\n      form: {\n        api_type\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Deletes this subreddit's icon.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteIcon()\n  */\n\n\n  deleteIcon() {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/delete_sr_icon\"),\n      form: {\n        api_type\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Deletes an image from this subreddit.\n  * @param {object} options\n  * @param {string} options.imageName The name of the image.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').deleteImage()\n  */\n\n\n  deleteImage(_ref7) {\n    var image_name = _ref7.image_name,\n        _ref7$imageName = _ref7.imageName,\n        imageName = _ref7$imageName === void 0 ? image_name : _ref7$imageName;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/delete_sr_img\"),\n      form: {\n        api_type,\n        img_name: imageName\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Gets this subreddit's current settings.\n  * @returns {Promise} An Object containing this subreddit's current settings.\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getSettings().then(console.log)\n  * // => SubredditSettings { default_set: true, submit_text: '', subreddit_type: 'private', ... }\n  */\n\n\n  getSettings() {\n    return this._get({\n      uri: \"r/\".concat(this.display_name, \"/about/edit\")\n    });\n  }\n  /**\n  * @summary Edits this subreddit's settings.\n  * @param {object} options An Object containing {[option name]: new value} mappings of the options that should be modified.\n  Any omitted option names will simply retain their previous values.\n  * @param {string} options.title The text that should appear in the header of the subreddit\n  * @param {string} options.public_description The text that appears with this Subreddit on the search page, or on the\n  blocked-access page if this subreddit is private. (500 characters max)\n  * @param {string} options.description The sidebar text for the subreddit. (5120 characters max)\n  * @param {string} [options.submit_text=''] The text to show below the submission page (1024 characters max)\n  * @param {boolean} [options.hide_ads=false] Determines whether ads should be hidden on this subreddit. (This is only\n  allowed for gold-only subreddits.)\n  * @param {string} [options.lang='en'] The language of the subreddit (represented as an IETF language tag)\n  * @param {string} [options.type='public'] Determines who should be able to access the subreddit. This should be one of\n  `public, private, restricted, gold_restricted, gold_only, archived, employees_only`.\n  * @param {string} [options.link_type='any'] Determines what types of submissions are allowed on the subreddit. This should\n  be one of `any, link, self`.\n  * @param {string} [options.submit_link_label=undefined] Custom text to display on the button that submits a link. If\n  this is omitted, the default text will be displayed.\n  * @param {string} [options.submit_text_label=undefined] Custom text to display on the button that submits a selfpost. If\n  this is omitted, the default text will be displayed.\n  * @param {string} [options.wikimode='modonly'] Determines who can edit wiki pages on the subreddit. This should be one of\n  `modonly, anyone, disabled`.\n  * @param {number} [options.wiki_edit_karma=0] The minimum amount of subreddit karma needed for someone to edit this\n  subreddit's wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n  * @param {number} [options.wiki_edit_age=0] The minimum account age (in days) needed for someone to edit this subreddit's\n  wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n  * @param {string} [options.spam_links='high'] The spam filter strength for links on this subreddit. This should be one of\n  `low, high, all`.\n  * @param {string} [options.spam_selfposts='high'] The spam filter strength for selfposts on this subreddit. This should be\n  one of `low, high, all`.\n  * @param {string} [options.spam_comments='high'] The spam filter strength for comments on this subreddit. This should be one\n  of `low, high, all`.\n  * @param {boolean} [options.over_18=false] Determines whether this subreddit should be classified as NSFW\n  * @param {boolean} [options.allow_top=true] Determines whether the new subreddit should be able to appear in /r/all and\n  trending subreddits\n  * @param {boolean} [options.show_media=false] Determines whether image thumbnails should be enabled on this subreddit\n  * @param {boolean} [options.show_media_preview=true] Determines whether media previews should be expanded by default on this\n  subreddit\n  * @param {boolean} [options.allow_images=true] Determines whether image uploads and links to image hosting sites should be\n  enabled on this subreddit\n  * @param {boolean} [options.exclude_banned_modqueue=false] Determines whether posts by site-wide banned users should be\n  excluded from the modqueue.\n  * @param {boolean} [options.public_traffic=false] Determines whether the /about/traffic page for this subreddit should be\n  viewable by anyone.\n  * @param {boolean} [options.collapse_deleted_comments=false] Determines whether deleted and removed comments should be\n  collapsed by default\n  * @param {string} [options.suggested_comment_sort=undefined] The suggested comment sort for the subreddit. This should be\n  one of `confidence, top, new, controversial, old, random, qa`.If left blank, there will be no suggested sort,\n  which means that users will see the sort method that is set in their own preferences (usually `confidence`.)\n  * @param {boolean} [options.spoilers_enabled=false] Determines whether users can mark their posts as spoilers\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').editSettings({submit_text: 'Welcome! Please be sure to read the rules.'})\n  */\n\n\n  editSettings(options) {\n    var _this6 = this;\n\n    return _Promise.default.join(this.getSettings(), this.fetch().get('name'), function (currentValues, name) {\n      return _this6._r._createOrEditSubreddit(_objectSpread({}, (0, _helpers.renameKey)(currentValues, 'subreddit_type', 'type'), {}, options, {\n        sr: name\n      }));\n    }).return(this);\n  }\n  /**\n  * @summary Gets a list of recommended other subreddits given this one.\n  * @param {object} [options]\n  * @param {Array} [options.omit=[]] An Array of subreddit names that should be excluded from the listing.\n  * @returns {Promise} An Array of subreddit names\n  * @example\n  *\n  * r.getSubreddit('AskReddit').getRecommendedSubreddits().then(console.log);\n  * // [ 'TheChurchOfRogers', 'Sleepycabin', ... ]\n  */\n\n\n  getRecommendedSubreddits(options) {\n    var toOmit = options.omit && options.omit.join(',');\n    return this._get({\n      uri: \"api/recommend/sr/\".concat(this.display_name),\n      qs: {\n        omit: toOmit\n      }\n    }).then(function (names) {\n      return (0, _lodash.map)(names, 'sr_name');\n    });\n  }\n  /**\n  * @summary Gets the submit text (which displays on the submission form) for this subreddit.\n  * @returns {Promise} The submit text, represented as a string.\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getSubmitText().then(console.log)\n  * // => 'Welcome! Please be sure to read the rules.'\n  */\n\n\n  getSubmitText() {\n    return this._get({\n      uri: \"r/\".concat(this.display_name, \"/api/submit_text\")\n    }).get('submit_text');\n  }\n  /**\n  * @summary Updates this subreddit's stylesheet.\n  * @param {object} options\n  * @param {string} options.css The new contents of the stylesheet\n  * @param {string} [options.reason] The reason for the change (256 characters max)\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').updateStylesheet({css: 'body {color:#00ff00;}', reason: 'yay green'})\n  */\n\n\n  updateStylesheet(_ref8) {\n    var css = _ref8.css,\n        reason = _ref8.reason;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/subreddit_stylesheet\"),\n      form: {\n        api_type,\n        op: 'save',\n        reason,\n        stylesheet_contents: css\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n\n  _setSubscribed(status) {\n    return this._post({\n      uri: 'api/subscribe',\n      form: {\n        action: status ? 'sub' : 'unsub',\n        sr_name: this.display_name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Subscribes to this subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').subscribe()\n  */\n\n\n  subscribe() {\n    return this._setSubscribed(true);\n  }\n  /**\n  * @summary Unsubscribes from this subreddit.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').unsubscribe()\n  */\n\n\n  unsubscribe() {\n    var _this7 = this;\n\n    /* Reddit returns a 404 error if the user attempts to unsubscribe to a subreddit that they weren't subscribed to in the\n    first place. It also (as one would expect) returns a 404 error if the subreddit in question does not exist. snoowrap\n    should swallow the first type of error internally, but it should raise the second type of error. Unfortunately, the errors\n    themselves are indistinguishable. So if a 404 error gets thrown, fetch the current subreddit to check if it exists. If it\n    does exist, then the 404 error was of the first type, so swallow it and return the current Subreddit object as usual. If\n    the subreddit doesn't exist, then the original error was of the second type, so throw it. */\n    return this._setSubscribed(false).catch({\n      statusCode: 404\n    }, function (err) {\n      return _this7.fetch().return(_this7).catchThrow(err);\n    });\n  }\n\n  _uploadSrImg(_ref9) {\n    var _this8 = this;\n\n    var name = _ref9.name,\n        file = _ref9.file,\n        uploadType = _ref9.uploadType,\n        imageType = _ref9.imageType;\n\n    if (typeof file !== 'string' && !(file instanceof _stream.Readable)) {\n      throw new _errors.InvalidMethodCallError('Uploaded image filepath must be a string or a ReadableStream.');\n    }\n\n    var parsedFile = typeof file === 'string' ? (0, _fs.createReadStream)(file) : file;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/upload_sr_img\"),\n      formData: {\n        name,\n        upload_type: uploadType,\n        img_type: imageType,\n        file: parsedFile\n      }\n    }).then(function (result) {\n      if (result.errors.length) {\n        throw result.errors[0];\n      }\n\n      return _this8;\n    });\n  }\n  /**\n  * @summary Uploads an image for use in this subreddit's stylesheet.\n  * @param {object} options\n  * @param {string} options.name The name that the new image should have in the stylesheet\n  * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n  image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) in environments (e.g.\n  browsers) where the filesystem is unavailable.\n  * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').uploadSubredditImage({name: 'the cookie monster', file: './cookie_monster.png'})\n  */\n\n\n  uploadStylesheetImage(_ref10) {\n    var name = _ref10.name,\n        file = _ref10.file,\n        _ref10$image_type = _ref10.image_type,\n        image_type = _ref10$image_type === void 0 ? 'png' : _ref10$image_type,\n        _ref10$imageType = _ref10.imageType,\n        imageType = _ref10$imageType === void 0 ? image_type : _ref10$imageType;\n    return this._uploadSrImg({\n      name,\n      file,\n      imageType,\n      uploadType: 'img'\n    });\n  }\n  /**\n  * @summary Uploads an image to use as this subreddit's header.\n  * @param {object} options\n  * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n  image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) for environments (e.g.\n  browsers) where the filesystem is unavailable.\n  * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').uploadHeaderImage({name: 'the cookie monster', file: './cookie_monster.png'})\n  */\n\n\n  uploadHeaderImage(_ref11) {\n    var file = _ref11.file,\n        _ref11$image_type = _ref11.image_type,\n        image_type = _ref11$image_type === void 0 ? 'png' : _ref11$image_type,\n        _ref11$imageType = _ref11.imageType,\n        imageType = _ref11$imageType === void 0 ? image_type : _ref11$imageType;\n    return this._uploadSrImg({\n      file,\n      imageType,\n      uploadType: 'header'\n    });\n  }\n  /**\n  * @summary Uploads an image to use as this subreddit's mobile icon.\n  * @param {object} options\n  * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n  image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) for environments (e.g.\n  browsers) where the filesystem is unavailable.\n  * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').uploadIcon({name: 'the cookie monster', file: './cookie_monster.png'})\n  */\n\n\n  uploadIcon(_ref12) {\n    var file = _ref12.file,\n        _ref12$image_type = _ref12.image_type,\n        image_type = _ref12$image_type === void 0 ? 'png' : _ref12$image_type,\n        _ref12$imageType = _ref12.imageType,\n        imageType = _ref12$imageType === void 0 ? image_type : _ref12$imageType;\n    return this._uploadSrImg({\n      file,\n      imageType,\n      uploadType: 'icon'\n    });\n  }\n  /**\n  * @summary Uploads an image to use as this subreddit's mobile banner.\n  * @param {object} options\n  * @param {string|stream.Readable} options.file The image file that should get uploaded. This should either be the path to an\n  image file, or a [ReadableStream](https://nodejs.org/api/stream.html#stream_class_stream_readable) for environments (e.g.\n  browsers) where the filesystem is unavailable.\n  * @param {string} [options.imageType='png'] Determines how the uploaded image should be stored. One of `png, jpg`\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete.\n  * @example r.getSubreddit('snoowrap').uploadBannerImage({name: 'the cookie monster', file: './cookie_monster.png'})\n  */\n\n\n  uploadBannerImage(_ref13) {\n    var file = _ref13.file,\n        _ref13$image_type = _ref13.image_type,\n        image_type = _ref13$image_type === void 0 ? 'png' : _ref13$image_type,\n        _ref13$imageType = _ref13.imageType,\n        imageType = _ref13$imageType === void 0 ? image_type : _ref13$imageType;\n    return this._uploadSrImg({\n      file,\n      imageType,\n      upload_type: 'banner'\n    });\n  }\n  /**\n  * @summary Gets information on this subreddit's rules.\n  * @returns {Promise} A Promise that fulfills with information on this subreddit's rules.\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getRules().then(console.log)\n  *\n  * // => {\n  *   rules: [\n  *     {\n  *       kind: 'all',\n  *       short_name: 'Rule 1: No violating rule 1',\n  *       description: 'Breaking this rule is not allowed.',\n  *       ...\n  *     },\n  *     ...\n  *   ],\n  *   site_rules: [\n  *     'Spam',\n  *     'Personal and confidential information'',\n  *     'Threatening, harassing, or inciting violence'\n  *   ]\n  * }\n  */\n\n\n  getRules() {\n    return this._get({\n      uri: \"r/\".concat(this.display_name, \"/about/rules\")\n    });\n  }\n  /**\n  * @summary Gets the stickied post on this subreddit, or throws a 404 error if none exists.\n  * @param {object} [options]\n  * @param {number} [options.num=1] The number of the sticky to get. Should be either `1` (first sticky) or `2` (second sticky).\n  * @returns {Promise} A Submission object representing this subreddit's stickied submission\n  * @example\n  * r.getSubreddit('snoowrap').getSticky({num: 2})\n  * // => Submission { ... }\n  */\n\n\n  getSticky() {\n    var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref14$num = _ref14.num,\n        num = _ref14$num === void 0 ? 1 : _ref14$num;\n\n    return this._get({\n      uri: \"r/\".concat(this.display_name, \"/about/sticky\"),\n      qs: {\n        num\n      }\n    });\n  }\n\n  _friend(options) {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/friend\"),\n      form: _objectSpread({}, options, {\n        api_type\n      })\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n\n  _unfriend(options) {\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/unfriend\"),\n      form: _objectSpread({}, options, {\n        api_type\n      })\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Invites the given user to be a moderator of this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be invited\n  * @param {Array} [options.permissions] The moderator permissions that this user should have. This should be an array\n  containing some combination of `\"wiki\", \"posts\", \"access\", \"mail\", \"config\", \"flair\"`. To add a moderator with full\n  permissions, omit this property entirely.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').inviteModerator({name: 'actually_an_aardvark', permissions: ['posts', 'wiki']})\n  */\n\n\n  inviteModerator(_ref15) {\n    var name = _ref15.name,\n        permissions = _ref15.permissions;\n    return this._friend({\n      name,\n      permissions: (0, _helpers.formatModPermissions)(permissions),\n      type: 'moderator_invite'\n    });\n  }\n  /**\n  * @summary Revokes an invitation for the given user to be a moderator.\n  * @param {object} options\n  * @param {string} options.name The username of the account whose invitation should be revoked\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').revokeModeratorInvite({name: 'actually_an_aardvark'})\n  */\n\n\n  revokeModeratorInvite(_ref16) {\n    var name = _ref16.name;\n    return this._unfriend({\n      name,\n      type: 'moderator_invite'\n    });\n  }\n  /**\n  * @summary Removes the given user's moderator status on this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the account whose moderator status should be removed\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').removeModerator({name: 'actually_an_aardvark'})\n  */\n\n\n  removeModerator(_ref17) {\n    var name = _ref17.name;\n    return this._unfriend({\n      name,\n      type: 'moderator'\n    });\n  }\n  /**\n  * @summary Makes the given user an approved submitter of this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be given this status\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').addContributor({name: 'actually_an_aardvark'})\n  */\n\n\n  addContributor(_ref18) {\n    var name = _ref18.name;\n    return this._friend({\n      name,\n      type: 'contributor'\n    });\n  }\n  /**\n  * @summary Revokes this user's approved submitter status on this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the account whose status should be revoked\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').removeContributor({name: 'actually_an_aardvark'})\n  */\n\n\n  removeContributor(_ref19) {\n    var name = _ref19.name;\n    return this._unfriend({\n      name,\n      type: 'contributor'\n    });\n  }\n  /**\n  * @summary Bans the given user from this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be banned\n  * @param {string} [options.banMessage] The ban message. This will get sent to the user in a private message, alerting them\n  that they have been banned.\n  * @param {string} [options.banReason] A string indicating which rule the banned user broke (100 characters max)\n  * @param {number} [options.duration] The duration of the ban, in days. For a permanent ban, omit this parameter.\n  * @param {string} [options.banNote] A note that appears on the moderation log, usually used to indicate the reason for the\n  ban. This is not visible to the banned user. (300 characters max)\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').banUser({name: 'actually_an_aardvark', banMessage: 'You are now banned LOL'})\n  */\n\n\n  banUser(_ref20) {\n    var name = _ref20.name,\n        ban_message = _ref20.ban_message,\n        _ref20$banMessage = _ref20.banMessage,\n        banMessage = _ref20$banMessage === void 0 ? ban_message : _ref20$banMessage,\n        ban_reason = _ref20.ban_reason,\n        _ref20$banReason = _ref20.banReason,\n        banReason = _ref20$banReason === void 0 ? ban_reason : _ref20$banReason,\n        duration = _ref20.duration,\n        ban_note = _ref20.ban_note,\n        _ref20$banNote = _ref20.banNote,\n        banNote = _ref20$banNote === void 0 ? ban_note : _ref20$banNote;\n    return this._friend({\n      name,\n      ban_message: banMessage,\n      ban_reason: banReason,\n      duration,\n      note: banNote,\n      type: 'banned'\n    });\n  }\n  /**\n  * @summary Unbans the given user from this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be unbanned\n  * @returns {Promise} A Promise that fulfills when the request is complete\n  * @example r.getSubreddit('snoowrap').unbanUser({name: 'actually_an_aardvark'})\n  */\n\n\n  unbanUser(_ref21) {\n    var name = _ref21.name;\n    return this._unfriend({\n      name,\n      type: 'banned'\n    });\n  }\n  /**\n  * @summary Mutes the given user from messaging this subreddit for 72 hours.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be muted\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').muteUser({name: 'actually_an_aardvark'})\n  */\n\n\n  muteUser(_ref22) {\n    var name = _ref22.name;\n    return this._friend({\n      name,\n      type: 'muted'\n    });\n  }\n  /**\n  * @summary Unmutes the given user from messaging this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be muted\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').unmuteUser({name: 'actually_an_aardvark'})\n  */\n\n\n  unmuteUser(_ref23) {\n    var name = _ref23.name;\n    return this._unfriend({\n      name,\n      type: 'muted'\n    });\n  }\n  /**\n  * @summary Bans the given user from editing this subreddit's wiki.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be wikibanned\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').wikibanUser({name: 'actually_an_aardvark'})\n  */\n\n\n  wikibanUser(_ref24) {\n    var name = _ref24.name;\n    return this._friend({\n      name,\n      type: 'wikibanned'\n    });\n  }\n  /**\n  * @summary Unbans the given user from editing this subreddit's wiki.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be unwikibanned\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').unwikibanUser({name: 'actually_an_aardvark'})\n  */\n\n\n  unwikibanUser(_ref25) {\n    var name = _ref25.name;\n    return this._unfriend({\n      name,\n      type: 'wikibanned'\n    });\n  }\n  /**\n  * @summary Adds the given user to this subreddit's list of approved wiki editors.\n  * @param {object} options\n  * @param {string} options.name The username of the account that should be given approved editor status\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').addWikiContributor({name: 'actually_an_aardvark'})\n  */\n\n\n  addWikiContributor(_ref26) {\n    var name = _ref26.name;\n    return this._friend({\n      name,\n      type: 'wikicontributor'\n    });\n  }\n  /**\n  * @summary Removes the given user from this subreddit's list of approved wiki editors.\n  * @param {object} options\n  * @param {string} options.name The username of the account whose approved editor status should be revoked\n  * @returns {Promise} A Promise that fulfills with this Subreddit when the request is complete\n  * @example r.getSubreddit('snoowrap').removeWikiContributor({name: 'actually_an_aardvark'})\n  */\n\n\n  removeWikiContributor(_ref27) {\n    var name = _ref27.name;\n    return this._unfriend({\n      name,\n      type: 'wikicontributor'\n    });\n  }\n  /**\n  * @summary Sets the permissions for a given moderator on this subreddit.\n  * @param {object} options\n  * @param {string} options.name The username of the moderator whose permissions are being changed\n  * @param {Array} [options.permissions] The new moderator permissions that this user should have. This should be an array\n  containing some combination of `\"wiki\", \"posts\", \"access\", \"mail\", \"config\", \"flair\"`. To add a moderator with full\n  permissions, omit this property entirely.\n  * @returns {Promise} A Promise that fulfills with this Subreddit when this request is complete\n  * @example r.getSubreddit('snoowrap').setModeratorPermissions({name: 'actually_an_aardvark', permissions: ['mail']})\n  */\n\n\n  setModeratorPermissions(_ref28) {\n    var name = _ref28.name,\n        permissions = _ref28.permissions;\n    return this._post({\n      uri: \"r/\".concat(this.display_name, \"/api/setpermissions\"),\n      form: {\n        api_type,\n        name,\n        permissions: (0, _helpers.formatModPermissions)(permissions),\n        type: 'moderator'\n      }\n    }).then((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Gets a given wiki page on this subreddit.\n  * @param {string} title The title of the desired wiki page.\n  * @returns {WikiPage} An unfetched WikiPage object corresponding to the desired wiki page\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getWikiPage('index')\n  * // => WikiPage { title: 'index', subreddit: Subreddit { display_name: 'snoowrap' } }\n  */\n\n\n  getWikiPage(title) {\n    return this._r._newObject('WikiPage', {\n      subreddit: this,\n      title\n    });\n  }\n  /**\n  * @summary Gets the list of wiki pages on this subreddit.\n  * @returns {Promise} An Array containing WikiPage objects\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getWikiPages().then(console.log)\n  * // => [\n  * //   WikiPage { title: 'index', subreddit: Subreddit { display_name: 'snoowrap'} }\n  * //   WikiPage { title: 'config/sidebar', subreddit: Subreddit { display_name: 'snoowrap'} }\n  * //   WikiPage { title: 'secret_things', subreddit: Subreddit { display_name: 'snoowrap'} }\n  * //   WikiPage { title: 'config/submit_text', subreddit: Subreddit { display_name: 'snoowrap'} }\n  * // ]\n  */\n\n\n  getWikiPages() {\n    var _this9 = this;\n\n    return this._get({\n      uri: \"r/\".concat(this.display_name, \"/wiki/pages\")\n    }).map(function (title) {\n      return _this9.getWikiPage(title);\n    });\n  }\n  /**\n  * @summary Gets a list of revisions on this subreddit's wiki.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing wiki revisions\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getWikiRevisions().then(console.log)\n  * // => Listing [\n  * //  { page: 'index', reason: 'added cookies', ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getWikiRevisions(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.display_name, \"/wiki/revisions\"),\n      qs: options\n    });\n  }\n\n};\nvar _default = Subreddit;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1N1YnJlZGRpdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTs7QUFFZixjQUFjLG1CQUFPLENBQUMscURBQVE7O0FBRTlCLHNDQUFzQyxtQkFBTyxDQUFDLG9FQUFlOztBQUU3RCxjQUFjLG1CQUFPLENBQUMsc0JBQVE7O0FBRTlCLFVBQVUsbUJBQU8sQ0FBQyxjQUFJOztBQUV0QixlQUFlLG1CQUFPLENBQUMsb0VBQWU7O0FBRXRDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFcEMsNENBQTRDLG1CQUFPLENBQUMsdUZBQW9COztBQUV4RSx1Q0FBdUMsdUNBQXVDOztBQUU5RSwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsOERBQThELGlFQUFpRSxHQUFHLGtDQUFrQzs7QUFFdlUsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSwrQ0FBK0MsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLHlDQUF5QyxtRkFBbUYsT0FBTzs7QUFFdGYsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLHFCQUFxQix1Q0FBdUM7QUFDNUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1Q0FBdUM7QUFDM0Qsb0JBQW9CLGdEQUFnRDtBQUNwRSxvQkFBb0IsK0NBQStDO0FBQ25FLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L29iamVjdHMvU3VicmVkZGl0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2xvZGFzaCA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5cbnZhciBfUHJvbWlzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL1Byb21pc2UuanNcIikpO1xuXG52YXIgX3N0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5cbnZhciBfZnMgPSByZXF1aXJlKFwiZnNcIik7XG5cbnZhciBfaGVscGVycyA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzLmpzXCIpO1xuXG52YXIgX2Vycm9ycyA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIik7XG5cbnZhciBfUmVkZGl0Q29udGVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVkZGl0Q29udGVudC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBhcGlfdHlwZSA9ICdqc29uJztcbi8qKlxuKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHN1YnJlZGRpdFxuKiA8c3R5bGU+ICNTdWJyZWRkaXQge2Rpc3BsYXk6IG5vbmV9IDwvc3R5bGU+XG4qIEBleHRlbmRzIFJlZGRpdENvbnRlbnRcbiogQGV4YW1wbGVcbipcbiogLy8gR2V0IGEgc3VicmVkZGl0IGJ5IG5hbWVcbiogci5nZXRTdWJyZWRkaXQoJ0Fza1JlZGRpdCcpXG4qL1xuXG52YXIgU3VicmVkZGl0ID0gY2xhc3MgU3VicmVkZGl0IGV4dGVuZHMgX1JlZGRpdENvbnRlbnQuZGVmYXVsdCB7XG4gIGdldCBfdXJpKCkge1xuICAgIHJldHVybiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hYm91dFwiKTtcbiAgfVxuXG4gIF90cmFuc2Zvcm1BcGlSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgU3VicmVkZGl0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdWJyZWRkaXQgL3IvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIiBkb2VzIG5vdCBleGlzdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIF9kZWxldGVGbGFpclRlbXBsYXRlcyhfcmVmKSB7XG4gICAgdmFyIGZsYWlyX3R5cGUgPSBfcmVmLmZsYWlyX3R5cGU7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hcGkvY2xlYXJmbGFpcnRlbXBsYXRlc1wiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIGZsYWlyX3R5cGVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRGVsZXRlcyBhbGwgb2YgdGhpcyBzdWJyZWRkaXQncyB1c2VyIGZsYWlyIHRlbXBsYXRlc1xuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5kZWxldGVBbGxVc2VyRmxhaXJUZW1wbGF0ZXMoKVxuICAqL1xuXG5cbiAgZGVsZXRlQWxsVXNlckZsYWlyVGVtcGxhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxldGVGbGFpclRlbXBsYXRlcyh7XG4gICAgICBmbGFpcl90eXBlOiAnVVNFUl9GTEFJUidcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBEZWxldGVzIGFsbCBvZiB0aGlzIHN1YnJlZGRpdCdzIGxpbmsgZmxhaXIgdGVtcGxhdGVzXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmRlbGV0ZUFsbExpbmtGbGFpclRlbXBsYXRlcygpXG4gICovXG5cblxuICBkZWxldGVBbGxMaW5rRmxhaXJUZW1wbGF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGV0ZUZsYWlyVGVtcGxhdGVzKHtcbiAgICAgIGZsYWlyX3R5cGU6ICdMSU5LX0ZMQUlSJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IERlbGV0ZXMgb25lIG9mIHRoaXMgc3VicmVkZGl0J3MgZmxhaXIgdGVtcGxhdGVzXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mbGFpcl90ZW1wbGF0ZV9pZCBUaGUgSUQgb2YgdGhlIHRlbXBsYXRlIHRoYXQgc2hvdWxkIGJlIGRlbGV0ZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZGVsZXRlRmxhaXJUZW1wbGF0ZSh7ZmxhaXJfdGVtcGxhdGVfaWQ6ICdmZGZkODUzMi1jOTFlLTExZTUtYjRkNC0wZTA4MjA4NGQ3MjEnfSlcbiAgKi9cblxuXG4gIGRlbGV0ZUZsYWlyVGVtcGxhdGUoX3JlZjIpIHtcbiAgICB2YXIgZmxhaXJfdGVtcGxhdGVfaWQgPSBfcmVmMi5mbGFpcl90ZW1wbGF0ZV9pZDtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2FwaS9kZWxldGVmbGFpcnRlbXBsYXRlXCIpLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgZmxhaXJfdGVtcGxhdGVfaWRcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cblxuICBfY3JlYXRlRmxhaXJUZW1wbGF0ZShfcmVmMykge1xuICAgIHZhciB0ZXh0ID0gX3JlZjMudGV4dCxcbiAgICAgICAgY3NzX2NsYXNzID0gX3JlZjMuY3NzX2NsYXNzLFxuICAgICAgICBfcmVmMyRjc3NDbGFzcyA9IF9yZWYzLmNzc0NsYXNzLFxuICAgICAgICBjc3NDbGFzcyA9IF9yZWYzJGNzc0NsYXNzID09PSB2b2lkIDAgPyBjc3NfY2xhc3MgOiBfcmVmMyRjc3NDbGFzcyxcbiAgICAgICAgZmxhaXJfdHlwZSA9IF9yZWYzLmZsYWlyX3R5cGUsXG4gICAgICAgIF9yZWYzJHRleHRfZWRpdGFibGUgPSBfcmVmMy50ZXh0X2VkaXRhYmxlLFxuICAgICAgICB0ZXh0X2VkaXRhYmxlID0gX3JlZjMkdGV4dF9lZGl0YWJsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyR0ZXh0X2VkaXRhYmxlLFxuICAgICAgICBfcmVmMyR0ZXh0RWRpdGFibGUgPSBfcmVmMy50ZXh0RWRpdGFibGUsXG4gICAgICAgIHRleHRFZGl0YWJsZSA9IF9yZWYzJHRleHRFZGl0YWJsZSA9PT0gdm9pZCAwID8gdGV4dF9lZGl0YWJsZSA6IF9yZWYzJHRleHRFZGl0YWJsZTtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2FwaS9mbGFpcnRlbXBsYXRlXCIpLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgY3NzX2NsYXNzOiBjc3NDbGFzcyxcbiAgICAgICAgZmxhaXJfdHlwZSxcbiAgICAgICAgdGV4dF9lZGl0YWJsZTogdGV4dEVkaXRhYmxlXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBuZXcgdXNlciBmbGFpciB0ZW1wbGF0ZSBmb3IgdGhpcyBzdWJyZWRkaXRcbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRleHQgVGhlIGZsYWlyIHRleHQgZm9yIHRoaXMgdGVtcGxhdGVcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY3NzQ2xhc3M9JyddIFRoZSBDU1MgY2xhc3MgZm9yIHRoaXMgdGVtcGxhdGVcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHRFZGl0YWJsZT1mYWxzZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHVzZXJzIHNob3VsZCBiZSBhYmxlIHRvIGVkaXQgdGhlaXIgZmxhaXIgdGV4dFxuICB3aGVuIGl0IGhhcyB0aGlzIHRlbXBsYXRlXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZS5cbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5jcmVhdGVVc2VyRmxhaXJUZW1wbGF0ZSh7dGV4dDogJ1NvbWUgRmxhaXIgVGV4dCcsIGNzc0NsYXNzOiAnc29tZS1jc3MtY2xhc3MnfSlcbiAgKi9cblxuXG4gIGNyZWF0ZVVzZXJGbGFpclRlbXBsYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRmxhaXJUZW1wbGF0ZShfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICBmbGFpcl90eXBlOiAnVVNFUl9GTEFJUidcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgQ3JlYXRlcyBhIG5ldyBsaW5rIGZsYWlyIHRlbXBsYXRlIGZvciB0aGlzIHN1YnJlZGRpdFxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGV4dCBUaGUgZmxhaXIgdGV4dCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jc3NDbGFzcz0nJ10gVGhlIENTUyBjbGFzcyBmb3IgdGhpcyB0ZW1wbGF0ZVxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dEVkaXRhYmxlPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdXNlcnMgc2hvdWxkIGJlIGFibGUgdG8gZWRpdCB0aGUgZmxhaXIgdGV4dCBvZiB0aGVpclxuICBsaW5rcyB3aGVuIGl0IGhhcyB0aGlzIHRlbXBsYXRlXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmNyZWF0ZUxpbmtGbGFpclRlbXBsYXRlKHt0ZXh0OiAnU29tZSBGbGFpciBUZXh0JywgY3NzQ2xhc3M6ICdzb21lLWNzcy1jbGFzcyd9KVxuICAqL1xuXG5cbiAgY3JlYXRlTGlua0ZsYWlyVGVtcGxhdGUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVGbGFpclRlbXBsYXRlKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGZsYWlyX3R5cGU6ICdMSU5LX0ZMQUlSJ1xuICAgIH0pKTtcbiAgfVxuXG4gIF9nZXRGbGFpck9wdGlvbnMoKSB7XG4gICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgbmFtZSA9IF9yZWY0Lm5hbWUsXG4gICAgICAgIGxpbmsgPSBfcmVmNC5saW5rLFxuICAgICAgICBpc19uZXdsaW5rID0gX3JlZjQuaXNfbmV3bGluaztcblxuICAgIC8vIFRPRE86IEFkZCBzaG9ydGN1dHMgZm9yIHRoaXMgb24gUmVkZGl0VXNlciBhbmQgU3VibWlzc2lvblxuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL2ZsYWlyc2VsZWN0b3JcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGxpbmssXG4gICAgICAgIGlzX25ld2xpbmtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIHRoZSBmbGFpciB0ZW1wbGF0ZXMgZm9yIHRoZSBzdWJyZWRkaXQgb3IgYSBnaXZlbiBsaW5rLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbbGlua0lkXSBUaGUgbGluaydzIGJhc2UzNiBJRFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBbiBBcnJheSBvZiBmbGFpciB0ZW1wbGF0ZSBvcHRpb25zXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldExpbmtGbGFpclRlbXBsYXRlcygnNGZwMzZ5JykudGhlbihjb25zb2xlLmxvZylcbiAgLy8gPT4gWyB7IGZsYWlyX2Nzc19jbGFzczogJycsXG4gIC8vICBmbGFpcl90ZW1wbGF0ZV9pZDogJ2ZkZmQ4NTMyLWM5MWUtMTFlNS1iNGQ0LTBlMDgyMDg0ZDcyMScsXG4gIC8vICBmbGFpcl90ZXh0X2VkaXRhYmxlOiB0cnVlLFxuICAvLyAgZmxhaXJfcG9zaXRpb246ICdyaWdodCcsXG4gIC8vICBmbGFpcl90ZXh0OiAnJyB9LFxuICAvLyAgeyBmbGFpcl9jc3NfY2xhc3M6ICcnLFxuICAvLyAgZmxhaXJfdGVtcGxhdGVfaWQ6ICcwMzgyMWY2Mi1jOTIwLTExZTUtYjYwOC0wZTMwOWZiY2Y4NjMnLFxuICAvLyAgZmxhaXJfdGV4dF9lZGl0YWJsZTogdHJ1ZSxcbiAgLy8gIGZsYWlyX3Bvc2l0aW9uOiAncmlnaHQnLFxuICAvLyAgZmxhaXJfdGV4dDogJycgfSxcbiAgLy8gIC4uLlxuICAvLyBdXG4gICovXG5cblxuICBnZXRMaW5rRmxhaXJUZW1wbGF0ZXMoKSB7XG4gICAgdmFyIGxpbmtJZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICB2YXIgb3B0aW9ucyA9IGxpbmtJZCA/IHtcbiAgICAgIGxpbms6IGxpbmtJZFxuICAgIH0gOiB7XG4gICAgICBpc19uZXdsaW5rOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0RmxhaXJPcHRpb25zKG9wdGlvbnMpLmdldCgnY2hvaWNlcycpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhlIGxpc3Qgb2YgdXNlciBmbGFpciB0ZW1wbGF0ZXMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEFuIEFycmF5IG9mIHVzZXIgZmxhaXIgdGVtcGxhdGVzXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFVzZXJGbGFpclRlbXBsYXRlcygpLnRoZW4oY29uc29sZS5sb2cpXG4gIC8vID0+IFsgeyBmbGFpcl9jc3NfY2xhc3M6ICcnLFxuICAvLyAgZmxhaXJfdGVtcGxhdGVfaWQ6ICdmZGZkODUzMi1jOTFlLTExZTUtYjRkNC0wZTA4MjA4NGQ3MjEnLFxuICAvLyAgZmxhaXJfdGV4dF9lZGl0YWJsZTogdHJ1ZSxcbiAgLy8gIGZsYWlyX3Bvc2l0aW9uOiAncmlnaHQnLFxuICAvLyAgZmxhaXJfdGV4dDogJycgfSxcbiAgLy8gIHsgZmxhaXJfY3NzX2NsYXNzOiAnJyxcbiAgLy8gIGZsYWlyX3RlbXBsYXRlX2lkOiAnMDM4MjFmNjItYzkyMC0xMWU1LWI2MDgtMGUzMDlmYmNmODYzJyxcbiAgLy8gIGZsYWlyX3RleHRfZWRpdGFibGU6IHRydWUsXG4gIC8vICBmbGFpcl9wb3NpdGlvbjogJ3JpZ2h0JyxcbiAgLy8gIGZsYWlyX3RleHQ6ICcnIH0sXG4gIC8vICAuLi5cbiAgLy8gXVxuICAqL1xuXG5cbiAgZ2V0VXNlckZsYWlyVGVtcGxhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGbGFpck9wdGlvbnMoKS5nZXQoJ2Nob2ljZXMnKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBDbGVhcnMgYSB1c2VyJ3MgZmxhaXIgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHVzZXIncyBuYW1lXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmRlbGV0ZVVzZXJGbGFpcignYWN0dWFsbHlfYW5fYWFyZHZhcmsnKVxuICAqL1xuXG5cbiAgZGVsZXRlVXNlckZsYWlyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2FwaS9kZWxldGVmbGFpclwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIG5hbWVcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIHVzZXIncyBmbGFpciBvbiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgdXNlcidzIG5hbWVcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdXNlcidzIGZsYWlyXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFVzZXJGbGFpcignYWN0dWFsbHlfYW5fYWFyZHZhcmsnKS50aGVuKGNvbnNvbGUubG9nKVxuICAvLyA9PiB7IGZsYWlyX2Nzc19jbGFzczogJycsXG4gIC8vICBmbGFpcl90ZW1wbGF0ZV9pZDogJ2ZkZmQ4NTMyLWM5MWUtMTFlNS1iNGQ0LTBlMDgyMDg0ZDcyMScsXG4gIC8vICBmbGFpcl90ZXh0OiAnJyxcbiAgLy8gIGZsYWlyX3Bvc2l0aW9uOiAncmlnaHQnXG4gIC8vIH1cbiAgKi9cblxuXG4gIGdldFVzZXJGbGFpcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEZsYWlyT3B0aW9ucyh7XG4gICAgICBuYW1lXG4gICAgfSkuZ2V0KCdjdXJyZW50Jyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgU2V0cyBtdWx0aXBsZSB1c2VyIGZsYWlycyBhdCB0aGUgc2FtZSB0aW1lXG4gICogQGRlc2MgRHVlIHRvIHRoZSBiZWhhdmlvciBvZiB0aGUgcmVkZGl0IEFQSSBlbmRwb2ludCB0aGF0IHRoaXMgZnVuY3Rpb24gdXNlcywgaWYgYW55IG9mIHRoZSBwcm92aWRlZCB1c2VyIGZsYWlycyBhcmVcbiAgaW52YWxpZCwgcmVkZGl0IHdpbGwgbWFrZSBub3RlIG9mIHRoaXMgaW4gaXRzIHJlc3BvbnNlLCBidXQgaXQgd2lsbCBzdGlsbCBhdHRlbXB0IHRvIHNldCB0aGUgcmVtYWluaW5nIHVzZXIgZmxhaXJzLiBJZiB0aGlzXG4gIG9jY3VycywgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgc25vb3dyYXAgd2lsbCBiZSByZWplY3RlZCwgYW5kIHRoZSByZWplY3Rpb24gcmVhc29uIHdpbGwgYmUgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgJ2Vycm9yJ1xuICByZXNwb25zZXMgZnJvbSByZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3RbXX0gZmxhaXJBcnJheVxuICAqIEBwYXJhbSB7c3RyaW5nfSBmbGFpckFycmF5W10ubmFtZSBBIHVzZXIncyBuYW1lXG4gICogQHBhcmFtIHtzdHJpbmd9IGZsYWlyQXJyYXlbXS50ZXh0IFRoZSBmbGFpciB0ZXh0IHRvIGFzc2lnbiB0byB0aGlzIHVzZXJcbiAgKiBAcGFyYW0ge3N0cmluZ30gZmxhaXJBcnJheVtdLmNzc0NsYXNzIFRoZSBmbGFpciBDU1MgY2xhc3MgdG8gYXNzaWduIHRvIHRoaXMgdXNlclxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZVxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnNldE11bHRpcGxlVXNlckZsYWlycyhbXG4gICogICB7bmFtZTogJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJywgdGV4dDogXCJ0aGlzIGlzIC91L2FjdHVhbGx5X2FuX2FhcmR2YXJrJ3MgZmxhaXIgdGV4dFwiLCBjc3NDbGFzczogJ3NvbWUtY3NzLWNsYXNzJ30sXG4gICogICB7bmFtZTogJ3Nub293cmFwX3Rlc3RpbmcnLCB0ZXh0OiBcInRoaXMgaXMgL3Uvc25vb3dyYXBfdGVzdGluZydzIGZsYWlyIHRleHRcIiwgY3NzQ2xhc3M6ICdzb21lLWNzcy1jbGFzcyd9XG4gICogXSk7XG4gICogLy8gdGhlIGFib3ZlIHJlcXVlc3QgZ2V0cyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5zZXRNdWx0aXBsZVVzZXJGbGFpcnMoW1xuICAqICAge25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsIHRleHQ6ICdmb28nLCBjc3NDbGFzczogJ3ZhbGlkLWNzcy1jbGFzcyd9LFxuICAqICAge25hbWU6ICdzbm9vd3JhcF90ZXN0aW5nJywgdGV4dDogJ2JhcicsIGNzc0NsYXNzOiBcInRoaXMgaXNuJ3QgYSB2YWxpZCBjc3MgY2xhc3NcIn0sXG4gICogICB7bmFtZTogJ25vdF9hbl9hYXJkdmFyaycsIHRleHQ6ICdiYXonLCBjc3NDbGFzczogXCJ0aGlzIGFsc28gaXNuJ3QgYSB2YWxpZCBjc3MgY2xhc3NcIn1cbiAgKiBdKVxuICAqIC8vIHRoZSBQcm9taXNlIGZyb20gdGhlIGFib3ZlIHJlcXVlc3QgZ2V0cyByZWplY3RlZCwgd2l0aCB0aGUgZm9sbG93aW5nIHJlamVjdGlvbiByZWFzb246XG4gICogW1xuICAqICAge1xuICAqICAgICBzdGF0dXM6ICdza2lwcGVkJyxcbiAgKiAgICAgZXJyb3JzOiB7IGNzczogJ2ludmFsaWQgY3NzIGNsYXNzIGB0aGlzIGlzblxcJ3QgYSB2YWxpZCBjc3MgY2xhc3NcXCcsIGlnbm9yaW5nJyB9LFxuICAqICAgICBvazogZmFsc2UsXG4gICogICAgIHdhcm5pbmdzOiB7fVxuICAqICAgfSxcbiAgKiAgIHtcbiAgKiAgICAgc3RhdHVzOiAnc2tpcHBlZCcsXG4gICogICAgIGVycm9yczogeyBjc3M6ICdpbnZhbGlkIGNzcyBjbGFzcyBgdGhpcyBhbHNvIGlzblxcJ3QgYSB2YWxpZCBjc3MgY2xhc3NcXCcsIGlnbm9yaW5nJyB9LFxuICAqICAgICBvazogZmFsc2UsXG4gICogICAgIHdhcm5pbmdzOiB7fVxuICAqICAgfVxuICAqIF1cbiAgKiAvLyBub3RlIHRoYXQgL3UvYWN0dWFsbHlfYW5fYWFyZHZhcmsncyBmbGFpciBzdGlsbCBnb3Qgc2V0IGJ5IHRoZSByZXF1ZXN0LCBldmVuIHRob3VnaCB0aGUgb3RoZXIgdHdvIGZsYWlycyBjYXVzZWQgZXJyb3JzLlxuICAqL1xuXG5cbiAgc2V0TXVsdGlwbGVVc2VyRmxhaXJzKGZsYWlyQXJyYXkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNzdkxpbmVzID0gZmxhaXJBcnJheS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIC8vIHJlZGRpdCBleHBlY3RzIHRvIHJlY2VpdmUgdmFsaWQgQ1NWIGRhdGEsIHdoaWNoIGVhY2ggbGluZSBoYXZpbmcgdGhlIGZvcm0gYHVzZXJuYW1lLGZsYWlyX3RleHQsY3NzX2NsYXNzYC5cbiAgICAgIHJldHVybiBbaXRlbS5uYW1lLCBpdGVtLnRleHQgfHwgaXRlbS5mbGFpclRleHQgfHwgaXRlbS5mbGFpcl90ZXh0IHx8ICcnLCBpdGVtLmNzc0NsYXNzIHx8IGl0ZW0uY3NzX2NsYXNzIHx8IGl0ZW0uZmxhaXJDc3NDbGFzcyB8fCBpdGVtLmZsYWlyX2Nzc19jbGFzcyB8fCAnJ10ubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLyogVG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgbGluZXMgKGUuZy4gaWYgdGhlIGZsYWlyIHRleHQgaXRzZWxmIGNvbnRhaW5zIGEgY29tbWEpLCBzdXJyb3VuZCBlYWNoXG4gICAgICAgIHBhcnQgb2YgdGhlIGxpbmUgd2l0aCBkb3VibGUgcXVvdGVzIGJlZm9yZSBqb2luaW5nIHRoZSBwYXJ0cyB0b2dldGhlciB3aXRoIGNvbW1hcyAoaW4gYWNjb3JkYW5jZSB3aXRoIGhvdyBzcGVjaWFsXG4gICAgICAgIGNoYXJhY3RlcnMgYXJlIHVzdWFsbHkgZXNjYXBlZCBpbiBDU1YpLiBJZiBkb3VibGUgcXVvdGVzIGFyZSB0aGVtc2VsdmVzIHBhcnQgb2YgdGhlIGZsYWlyIHRleHQsIHJlcGxhY2UgdGhlbSB3aXRoIGFcbiAgICAgICAgcGFpciBvZiBjb25zZWN1dGl2ZSBkb3VibGUgcXVvdGVzLiAqL1xuICAgICAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHN0ci5yZXBsYWNlKC9cIi9nLCAnXCJcIicpLCBcIlxcXCJcIik7XG4gICAgICB9KS5qb2luKCcsJyk7XG4gICAgfSk7XG4gICAgLyogRHVlIHRvIGFuIEFQSSBsaW1pdGF0aW9uLCB0aGlzIGVuZHBvaW50IGNhbiBvbmx5IHNldCB0aGUgZmxhaXIgb2YgMTAwIHVzZXJzIGF0IGEgdGltZS5cbiAgICBTZW5kIG11bHRpcGxlIHJlcXVlc3RzIGlmIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBhbGwgdXNlcnMgaW4gdGhlIGFycmF5IGFyZSBhY2NvdW50ZWQgZm9yLiAqL1xuXG4gICAgcmV0dXJuIF9Qcm9taXNlLmRlZmF1bHQubWFwKCgwLCBfbG9kYXNoLmNodW5rKShjc3ZMaW5lcywgMTAwKSwgZnVuY3Rpb24gKGZsYWlyQ2h1bmspIHtcbiAgICAgIHJldHVybiBfdGhpcy5fcG9zdCh7XG4gICAgICAgIHVyaTogXCJyL1wiLmNvbmNhdChfdGhpcy5kaXNwbGF5X25hbWUsIFwiL2FwaS9mbGFpcmNzdlwiKSxcbiAgICAgICAgZm9ybToge1xuICAgICAgICAgIGZsYWlyX2NzdjogZmxhaXJDaHVuay5qb2luKCdcXG4nKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS50aGVuKF9sb2Rhc2guZmxhdHRlbikudGFwKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICB2YXIgZXJyb3JSb3dzID0gcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gIXJvdy5vaztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXJyb3JSb3dzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvclJvd3M7XG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYSBsaXN0IG9mIGFsbCB1c2VyIGZsYWlycyBvbiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXSBBIHNwZWNpZmljIHVzZXJuYW1lIHRvIGp1bXAgdG9cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgdXNlciBmbGFpcnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0VXNlckZsYWlyTGlzdCgpLnRoZW4oY29uc29sZS5sb2cpXG4gIC8vID0+IExpc3RpbmcgW1xuICAvLyAgeyBmbGFpcl9jc3NfY2xhc3M6IG51bGwsXG4gIC8vICB1c2VyOiAnbm90X2FuX2FhcmR2YXJrJyxcbiAgLy8gIGZsYWlyX3RleHQ6ICdJc25cXCd0IGFuIGFhcmR2YXJrJyB9LFxuICAvLyAgeyBmbGFpcl9jc3NfY2xhc3M6ICdzb21lLWNzcy1jbGFzcycsXG4gIC8vICAgIHVzZXI6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsXG4gIC8vICAgIGZsYWlyX3RleHQ6ICd0aGlzIGlzIC91L2FjdHVhbGx5X2FuX2FhcmR2YXJrXFwncyBmbGFpciB0ZXh0JyB9LFxuICAvLyAgeyBmbGFpcl9jc3NfY2xhc3M6ICdzb21lLWNzcy1jbGFzcycsXG4gIC8vICAgIHVzZXI6ICdzbm9vd3JhcF90ZXN0aW5nJyxcbiAgLy8gICAgZmxhaXJfdGV4dDogJ3RoaXMgaXMgL3Uvc25vb3dyYXBfdGVzdGluZ1xcJ3MgZmxhaXIgdGV4dCcgfVxuICAvLyBdXG4gICovXG5cblxuICBnZXRVc2VyRmxhaXJMaXN0KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL2ZsYWlybGlzdFwiKSxcbiAgICAgIHFzOiBvcHRpb25zLFxuICAgICAgX3RyYW5zZm9ybTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIC8qIEZvciB1bmtub3duIHJlYXNvbnMsIHJlc3BvbnNlcyBmcm9tIHRoZSBhcGkvZmxhaXJsaXN0IGVuZHBvaW50IGFyZSBmb3JtYXR0ZWQgZGlmZmVyZW50bHkgdGhhbiByZXNwb25zZXMgZnJvbSBhbGwgb3RoZXJcbiAgICAgICAgTGlzdGluZyBlbmRwb2ludHMuIE1vc3QgTGlzdGluZyBlbmRwb2ludHMgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgYGNoaWxkcmVuYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSBMaXN0aW5nJ3MgY2hpbGRyZW4sXG4gICAgICAgIGFuZCBgYWZ0ZXJgIGFuZCBgYmVmb3JlYCBwcm9wZXJ0aWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBhZnRlcmAgYW5kIGBiZWZvcmVgIHF1ZXJ5c3RyaW5nIHBhcmFtZXRlcnMgdGhhdCBhIGNsaWVudCBzaG91bGRcbiAgICAgICAgdXNlIGluIHRoZSBuZXh0IHJlcXVlc3QuIEhvd2V2ZXIsIHRoZSBhcGkvZmxhaXJsaXN0IGVuZHBvaW50IHJldHVybnMgYW4gb2JqZWN0aSB3aXRoIGEgYHVzZXJzYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICAgICAgICBMaXN0aW5nJ3MgY2hpbGRyZW4sIGFuZCBgbmV4dGAgYW5kIGBwcmV2YCBwcm9wZXJ0aWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBhZnRlcmAgYW5kIGBiZWZvcmVgIHF1ZXJ5c3RyaW5nIHBhcmFtZXRlcnMuIEFzXG4gICAgICAgIGZhciBhcyBJIGNhbiB0ZWxsLCB0aGVyZSdzIG5vIGFjdHVhbCByZWFzb24gZm9yIHRoaXMgZGlmZmVyZW5jZS4gPl8+ICovXG4gICAgICAgIHJlc3BvbnNlLmFmdGVyID0gcmVzcG9uc2UubmV4dCB8fCBudWxsO1xuICAgICAgICByZXNwb25zZS5iZWZvcmUgPSByZXNwb25zZS5wcmV2IHx8IG51bGw7XG4gICAgICAgIHJlc3BvbnNlLmNoaWxkcmVuID0gcmVzcG9uc2UudXNlcnM7XG4gICAgICAgIHJldHVybiBfdGhpczIuX3IuX25ld09iamVjdCgnTGlzdGluZycsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBDb25maWd1cmVzIHRoZSBmbGFpciBzZXR0aW5ncyBmb3IgdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudXNlckZsYWlyRW5hYmxlZCBEZXRlcm1pbmVzIHdoZXRoZXIgdXNlciBmbGFpciBzaG91bGQgYmUgZW5hYmxlZFxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVzZXJGbGFpclBvc2l0aW9uIERldGVybWluZXMgdGhlIG9yaWVudGF0aW9uIG9mIHVzZXIgZmxhaXIgcmVsYXRpdmUgdG8gYSBnaXZlbiB1c2VybmFtZS4gVGhpc1xuICBzaG91bGQgYmUgZWl0aGVyIHRoZSBzdHJpbmcgJ2xlZnQnIG9yIHRoZSBzdHJpbmcgJ3JpZ2h0Jy5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudXNlckZsYWlyU2VsZkFzc2lnbkVuYWJsZWQgRGV0ZXJtaW5lcyB3aGV0aGVyIHVzZXJzIHNob3VsZCBiZSBhYmxlIHRvIGVkaXQgdGhlaXIgb3duIGZsYWlyXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGlua0ZsYWlyUG9zaXRpb24gRGV0ZXJtaW5lcyB0aGUgb3JpZW50YXRpb24gb2YgbGluayBmbGFpciByZWxhdGl2ZSB0byBhIGxpbmsgdGl0bGUuIFRoaXMgc2hvdWxkXG4gIGJlIGVpdGhlciAnbGVmdCcgb3IgJ3JpZ2h0Jy5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGlua0ZsYWlyU2VsZkFzc2lnbkVuYWJsZWQgRGV0ZXJtaW5lcyB3aGV0aGVyIHVzZXJzIHNob3VsZCBiZSBhYmxlIHRvIGVkaXQgdGhlIGZsYWlyIG9mIHRoZWlyXG4gIHN1Ym1pc3Npb25zLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5jb25maWd1cmVfZmxhaXIoe1xuICAgIHVzZXJGbGFpckVuYWJsZWQ6IHRydWUsXG4gICAgdXNlckZsYWlyUG9zaXRpb246ICdsZWZ0JyxcbiAgICB1c2VyRmxhaXJTZWxmQXNzaWduRW5hYmxlZDogZmFsc2UsXG4gICAgbGlua0ZsYWlyUG9zaXRpb246ICdyaWdodCcsXG4gICAgbGlua0ZsYWlyU2VsZkFzc2lnbkVuYWJsZWQ6IGZhbHNlXG4gICogfSlcbiAgKi9cblxuXG4gIGNvbmZpZ3VyZUZsYWlyKF9yZWY1KSB7XG4gICAgdmFyIHVzZXJfZmxhaXJfZW5hYmxlZCA9IF9yZWY1LnVzZXJfZmxhaXJfZW5hYmxlZCxcbiAgICAgICAgX3JlZjUkdXNlckZsYWlyRW5hYmxlID0gX3JlZjUudXNlckZsYWlyRW5hYmxlZCxcbiAgICAgICAgdXNlckZsYWlyRW5hYmxlZCA9IF9yZWY1JHVzZXJGbGFpckVuYWJsZSA9PT0gdm9pZCAwID8gdXNlcl9mbGFpcl9lbmFibGVkIDogX3JlZjUkdXNlckZsYWlyRW5hYmxlLFxuICAgICAgICB1c2VyX2ZsYWlyX3Bvc2l0aW9uID0gX3JlZjUudXNlcl9mbGFpcl9wb3NpdGlvbixcbiAgICAgICAgX3JlZjUkdXNlckZsYWlyUG9zaXRpID0gX3JlZjUudXNlckZsYWlyUG9zaXRpb24sXG4gICAgICAgIHVzZXJGbGFpclBvc2l0aW9uID0gX3JlZjUkdXNlckZsYWlyUG9zaXRpID09PSB2b2lkIDAgPyB1c2VyX2ZsYWlyX3Bvc2l0aW9uIDogX3JlZjUkdXNlckZsYWlyUG9zaXRpLFxuICAgICAgICB1c2VyX2ZsYWlyX3NlbGZfYXNzaWduX2VuYWJsZWQgPSBfcmVmNS51c2VyX2ZsYWlyX3NlbGZfYXNzaWduX2VuYWJsZWQsXG4gICAgICAgIF9yZWY1JHVzZXJGbGFpclNlbGZBcyA9IF9yZWY1LnVzZXJGbGFpclNlbGZBc3NpZ25FbmFibGVkLFxuICAgICAgICB1c2VyRmxhaXJTZWxmQXNzaWduRW5hYmxlZCA9IF9yZWY1JHVzZXJGbGFpclNlbGZBcyA9PT0gdm9pZCAwID8gdXNlcl9mbGFpcl9zZWxmX2Fzc2lnbl9lbmFibGVkIDogX3JlZjUkdXNlckZsYWlyU2VsZkFzLFxuICAgICAgICBsaW5rX2ZsYWlyX3Bvc2l0aW9uID0gX3JlZjUubGlua19mbGFpcl9wb3NpdGlvbixcbiAgICAgICAgX3JlZjUkbGlua0ZsYWlyUG9zaXRpID0gX3JlZjUubGlua0ZsYWlyUG9zaXRpb24sXG4gICAgICAgIGxpbmtGbGFpclBvc2l0aW9uID0gX3JlZjUkbGlua0ZsYWlyUG9zaXRpID09PSB2b2lkIDAgPyBsaW5rX2ZsYWlyX3Bvc2l0aW9uIDogX3JlZjUkbGlua0ZsYWlyUG9zaXRpLFxuICAgICAgICBsaW5rX2ZsYWlyX3NlbGZfYXNzaWduX2VuYWJsZWQgPSBfcmVmNS5saW5rX2ZsYWlyX3NlbGZfYXNzaWduX2VuYWJsZWQsXG4gICAgICAgIF9yZWY1JGxpbmtGbGFpclNlbGZBcyA9IF9yZWY1LmxpbmtGbGFpclNlbGZBc3NpZ25FbmFibGVkLFxuICAgICAgICBsaW5rRmxhaXJTZWxmQXNzaWduRW5hYmxlZCA9IF9yZWY1JGxpbmtGbGFpclNlbGZBcyA9PT0gdm9pZCAwID8gbGlua19mbGFpcl9zZWxmX2Fzc2lnbl9lbmFibGVkIDogX3JlZjUkbGlua0ZsYWlyU2VsZkFzO1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL2ZsYWlyY29uZmlnXCIpLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgZmxhaXJfZW5hYmxlZDogdXNlckZsYWlyRW5hYmxlZCxcbiAgICAgICAgZmxhaXJfcG9zaXRpb246IHVzZXJGbGFpclBvc2l0aW9uLFxuICAgICAgICBmbGFpcl9zZWxmX2Fzc2lnbl9lbmFibGVkOiB1c2VyRmxhaXJTZWxmQXNzaWduRW5hYmxlZCxcbiAgICAgICAgbGlua19mbGFpcl9wb3NpdGlvbjogbGlua0ZsYWlyUG9zaXRpb24sXG4gICAgICAgIGxpbmtfZmxhaXJfc2VsZl9hc3NpZ25fZW5hYmxlZDogbGlua0ZsYWlyU2VsZkFzc2lnbkVuYWJsZWRcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyB0aGUgcmVxdWVzdGVyJ3MgZmxhaXIgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3RlcidzIGN1cnJlbnQgZmxhaXJcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0TXlGbGFpcigpLnRoZW4oY29uc29sZS5sb2cpXG4gIC8vID0+IHsgZmxhaXJfY3NzX2NsYXNzOiAnc29tZS1jc3MtY2xhc3MnLFxuICAvLyAgZmxhaXJfdGVtcGxhdGVfaWQ6IG51bGwsXG4gIC8vICBmbGFpcl90ZXh0OiAndGhpcyBpcyAvdS9zbm9vd3JhcF90ZXN0aW5nXFwncyBmbGFpciB0ZXh0JyxcbiAgLy8gIGZsYWlyX3Bvc2l0aW9uOiAncmlnaHQnXG4gIC8vIH1cbiAgKi9cblxuXG4gIGdldE15RmxhaXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEZsYWlyT3B0aW9ucygpLmdldCgnY3VycmVudCcpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFNldHMgdGhlIHJlcXVlc3RlcidzIGZsYWlyIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZmxhaXJfdGVtcGxhdGVfaWQgQSBmbGFpciB0ZW1wbGF0ZSBJRCB0byB1c2UuIChUaGlzIHNob3VsZCBiZSBvYnRhaW5lZCBiZWZvcmVoYW5kIHVzaW5nXG4gIHtAbGluayBnZXRVc2VyRmxhaXJUZW1wbGF0ZXN9LilcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGV4dF0gVGhlIGZsYWlyIHRleHQgdG8gdXNlLiAoVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeS91c2VmdWwgaWYgdGhlIGdpdmVuIGZsYWlyXG4gIHRlbXBsYXRlIGhhcyB0aGUgYHRleHRfZWRpdGFibGVgIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAuKVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5zZWxlY3RNeUZsYWlyKHtmbGFpcl90ZW1wbGF0ZV9pZDogJ2ZkZmQ4NTMyLWM5MWUtMTFlNS1iNGQ0LTBlMDgyMDg0ZDcyMSd9KVxuICAqL1xuXG5cbiAgc2VsZWN0TXlGbGFpcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvKiBOT1RFOiBUaGlzIHJlcXVpcmVzIGBpZGVudGl0eWAgc2NvcGUgaW4gYWRkaXRpb24gdG8gYGZsYWlyYCBzY29wZSwgc2luY2UgdGhlIHJlZGRpdCBhcGkgbmVlZHMgdG8gYmUgcGFzc2VkIGEgdXNlcm5hbWUuXG4gICAgSSdtIG5vdCBzdXJlIGlmIHRoZXJlJ3MgYSB3YXkgdG8gZG8gdGhpcyB3aXRob3V0IHJlcXVpcmluZyBhZGRpdGlvbmFsIHNjb3BlLiAqL1xuICAgIHJldHVybiB0aGlzLl9yLl9nZXRNeU5hbWUoKS50aGVuKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLl9yLl9zZWxlY3RGbGFpcihfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHN1YnJlZGRpdE5hbWU6IF90aGlzMy5kaXNwbGF5X25hbWUsXG4gICAgICAgIG5hbWVcbiAgICAgIH0pKTtcbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cblxuICBfc2V0TXlGbGFpclZpc2liaWxpdHkoZmxhaXJfZW5hYmxlZCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL3NldGZsYWlyZW5hYmxlZFwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIGZsYWlyX2VuYWJsZWRcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgTWFrZXMgdGhlIHJlcXVlc3RlcidzIGZsYWlyIHZpc2libGUgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnNob3dNeUZsYWlyKClcbiAgKi9cblxuXG4gIHNob3dNeUZsYWlyKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXRNeUZsYWlyVmlzaWJpbGl0eSh0cnVlKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBNYWtlcyB0aGUgcmVxdWVzdGVyJ3MgZmxhaXIgaW52aXNpYmxlIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5oaWRlTXlGbGFpcigpXG4gICovXG5cblxuICBoaWRlTXlGbGFpcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0TXlGbGFpclZpc2liaWxpdHkoZmFsc2UpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBuZXcgc2VsZnBvc3Qgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgc3VibWlzc2lvblxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSB0aXRsZSBvZiB0aGUgc3VibWlzc2lvblxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZXh0XSBUaGUgc2VsZnRleHQgb2YgdGhlIHN1Ym1pc3Npb25cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRSZXBsaWVzPXRydWVdIERldGVybWluZXMgd2hldGhlciBpbmJveCByZXBsaWVzIHNob3VsZCBiZSBlbmFibGVkIGZvciB0aGlzIHN1Ym1pc3Npb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FwdGNoYUlkZW5dIEEgY2FwdGNoYSBpZGVudGlmaWVyLiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIHRoZSBhdXRoZW50aWNhdGVkIGFjY291bnRcbiAgcmVxdWlyZXMgYSBjYXB0Y2hhIHRvIHN1Ym1pdCBwb3N0cyBhbmQgY29tbWVudHMuXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhcHRjaGFSZXNwb25zZV0gVGhlIHJlc3BvbnNlIHRvIHRoZSBjYXB0Y2hhIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIG5ld2x5LWNyZWF0ZWQgU3VibWlzc2lvbiBvYmplY3RcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuc3VibWl0U2VsZnBvc3Qoe3RpdGxlOiAndGhpcyBpcyBhIHNlbGZwb3N0JywgdGV4dDogXCJoaSwgaG93J3MgaXQgZ29pbmc/XCJ9KS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IFN1Ym1pc3Npb24geyBuYW1lOiAndDNfNGFibXN6JyB9XG4gICovXG5cblxuICBzdWJtaXRTZWxmcG9zdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Iuc3VibWl0U2VsZnBvc3QoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgc3VicmVkZGl0TmFtZTogdGhpcy5kaXNwbGF5X25hbWVcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgQ3JlYXRlcyBhIG5ldyBsaW5rIHN1Ym1pc3Npb24gb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgc3VibWlzc2lvblxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSB0aXRsZSBvZiB0aGUgc3VibWlzc2lvblxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybCBUaGUgdXJsIHRoYXQgdGhlIGxpbmsgc3VibWlzc2lvbiBzaG91bGQgcG9pbnQgdG9cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRSZXBsaWVzPXRydWVdIERldGVybWluZXMgd2hldGhlciBpbmJveCByZXBsaWVzIHNob3VsZCBiZSBlbmFibGVkIGZvciB0aGlzIHN1Ym1pc3Npb25cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3VibWl0PXRydWVdIElmIHRoaXMgaXMgZmFsc2UgYW5kIHNhbWUgbGluayBoYXMgYWxyZWFkeSBiZWVuIHN1Ym1pdHRlZCB0byB0aGlzIHN1YnJlZGRpdCBpblxuICB0aGUgcGFzdCwgcmVkZGl0IHdpbGwgcmV0dXJuIGFuIGVycm9yLiBUaGlzIGNvdWxkIGJlIHVzZWQgdG8gYXZvaWQgYWNjaWRlbnRhbCByZXBvc3RzLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jYXB0Y2hhSWRlbl0gQSBjYXB0Y2hhIGlkZW50aWZpZXIuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgdGhlIGF1dGhlbnRpY2F0ZWQgYWNjb3VudFxuICByZXF1aXJlcyBhIGNhcHRjaGEgdG8gc3VibWl0IHBvc3RzIGFuZCBjb21tZW50cy5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FwdGNoYVJlc3BvbnNlXSBUaGUgcmVzcG9uc2UgdG8gdGhlIGNhcHRjaGEgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgbmV3bHktY3JlYXRlZCBTdWJtaXNzaW9uIG9iamVjdFxuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5zdWJtaXRMaW5rKHt0aXRsZTogJ0kgZm91bmQgYSBjb29sIHdlYnNpdGUnLCB1cmw6ICdodHRwczovL2dvb2dsZS5jb20nfSkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBTdWJtaXNzaW9uIHsgbmFtZTogJ3QzXzRhYm1zeicgfVxuICAqL1xuXG5cbiAgc3VibWl0TGluayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Iuc3VibWl0TGluayhfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICBzdWJyZWRkaXROYW1lOiB0aGlzLmRpc3BsYXlfbmFtZVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIG5ldyBjcm9zc3Bvc3Qgc3VibWlzc2lvbiBvbiB0aGlzIHN1YnJlZGRpdFxuICAgKiBAZGVzYyAqKk5PVEUqKjogVG8gY3JlYXRlIGEgY3Jvc3Nwb3N0LCB0aGUgYXV0aGVudGljYXRlZCBhY2NvdW50IG11c3QgYmUgc3Vic2NyaWJlZCB0byB0aGUgc3VicmVkZGl0IHdoZXJlXG4gICAqIHRoZSBjcm9zc3Bvc3QgaXMgYmVpbmcgc3VibWl0dGVkLCBhbmQgdGhhdCBzdWJyZWRkaXQgYmUgY29uZmlndXJlZCB0byBhbGxvdyBjcm9zc3Bvc3RzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSB0aXRsZSBvZiB0aGUgY3Jvc3Nwb3N0XG4gICAqIEBwYXJhbSB7c3RyaW5nfFN1Ym1pc3Npb259IG9wdGlvbnMub3JpZ2luYWxQb3N0IEEgU3VibWlzc2lvbiBvYmplY3Qgb3IgYSBwb3N0IElEIGZvciB0aGUgb3JpZ2luYWwgcG9zdCB3aGljaFxuICAgaXMgYmVpbmcgY3Jvc3Nwb3N0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kUmVwbGllcz10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgaW5ib3ggcmVwbGllcyBzaG91bGQgYmUgZW5hYmxlZCBmb3IgdGhpcyBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzdWJtaXQ9dHJ1ZV0gSWYgdGhpcyBpcyBmYWxzZSBhbmQgc2FtZSBsaW5rIGhhcyBhbHJlYWR5IGJlZW4gc3VibWl0dGVkIHRvIHRoaXMgc3VicmVkZGl0IGluXG4gICB0aGUgcGFzdCwgcmVkZGl0IHdpbGwgcmV0dXJuIGFuIGVycm9yLiBUaGlzIGNvdWxkIGJlIHVzZWQgdG8gYXZvaWQgYWNjaWRlbnRhbCByZXBvc3RzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIG5ld2x5LWNyZWF0ZWQgU3VibWlzc2lvbiBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYXdhaXQgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuc3VibWl0Q3Jvc3Nwb3N0KHsgdGl0bGU6ICdJIGZvdW5kIGFuIGludGVyZXN0aW5nIHBvc3QnLCBvcmlnaW5hbFBvc3Q6ICc2dnRoczAnIH0pXG4gICAqIC8vID0+IFN1Ym1pc3Npb24geyBuYW1lOiAndDNfNGFibXN6JyB9XG4gICAqL1xuXG5cbiAgc3VibWl0Q3Jvc3Nwb3N0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fci5zdWJtaXRDcm9zc3Bvc3QoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgc3VicmVkZGl0TmFtZTogdGhpcy5kaXNwbGF5X25hbWVcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIExpc3Rpbmcgb2YgaG90IHBvc3RzIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIHRoZSByZXRyaWV2ZWQgc3VibWlzc2lvbnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0SG90KCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldEhvdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3IuZ2V0SG90KHRoaXMuZGlzcGxheV9uYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiBuZXcgcG9zdHMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgdGhlIHJldHJpZXZlZCBzdWJtaXNzaW9uc1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXROZXcoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIFN1Ym1pc3Npb24geyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqXG4gICovXG5cblxuICBnZXROZXcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yLmdldE5ldyh0aGlzLmRpc3BsYXlfbmFtZSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIExpc3Rpbmcgb2YgbmV3IGNvbW1lbnRzIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIHRoZSByZXRyaWV2ZWQgY29tbWVudHNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0TmV3Q29tbWVudHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0TmV3Q29tbWVudHMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yLmdldE5ld0NvbW1lbnRzKHRoaXMuZGlzcGxheV9uYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgc2luZ2xlIHJhbmRvbSBTdWJtaXNzaW9uIGZyb20gdGhpcyBzdWJyZWRkaXQuXG4gICogQGRlc2MgKipOb3RlKio6IFRoaXMgZnVuY3Rpb24gd2lsbCBub3Qgd29yayB3aGVuIHNub293cmFwIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyLCBiZWNhdXNlIHRoZSByZWRkaXQgc2VydmVyIHNlbmRzIGFcbiAgcmVkaXJlY3Qgd2hpY2ggY2Fubm90IGJlIGZvbGxvd2VkIGJ5IGEgQ09SUyByZXF1ZXN0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcmV0cmlldmVkIFN1Ym1pc3Npb24gb2JqZWN0XG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFJhbmRvbVN1Ym1pc3Npb24oKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IFN1Ym1pc3Npb24geyAuLi4gfVxuICAqL1xuXG5cbiAgZ2V0UmFuZG9tU3VibWlzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fci5nZXRSYW5kb21TdWJtaXNzaW9uKHRoaXMuZGlzcGxheV9uYW1lKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiB0b3AgcG9zdHMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGltZV0gRGVzY3JpYmVzIHRoZSB0aW1lc3BhbiB0aGF0IHBvc3RzIHNob3VsZCBiZSByZXRyaWV2ZWQgZnJvbS4gU2hvdWxkIGJlIG9uZSBvZlxuICBgaG91ciwgZGF5LCB3ZWVrLCBtb250aCwgeWVhciwgYWxsYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyB0aGUgcmV0cmlldmVkIHN1Ym1pc3Npb25zXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFRvcCh7dGltZTogJ2FsbCd9KS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0VG9wKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fci5nZXRUb3AodGhpcy5kaXNwbGF5X25hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYSBMaXN0aW5nIG9mIGNvbnRyb3ZlcnNpYWwgcG9zdHMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGltZV0gRGVzY3JpYmVzIHRoZSB0aW1lc3BhbiB0aGF0IHBvc3RzIHNob3VsZCBiZSByZXRyaWV2ZWQgZnJvbS4gU2hvdWxkIGJlIG9uZSBvZlxuICBgaG91ciwgZGF5LCB3ZWVrLCBtb250aCwgeWVhciwgYWxsYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyB0aGUgcmV0cmlldmVkIHN1Ym1pc3Npb25zXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldENvbnRyb3ZlcnNpYWwoe3RpbWU6ICd3ZWVrJ30pLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRDb250cm92ZXJzaWFsKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fci5nZXRDb250cm92ZXJzaWFsKHRoaXMuZGlzcGxheV9uYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiB0b3AgcG9zdHMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgdGhlIHJldHJpZXZlZCBzdWJtaXNzaW9uc1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRSaXNpbmcoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIFN1Ym1pc3Npb24geyAuLi4gfSxcbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0UmlzaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fci5nZXRSaXNpbmcodGhpcy5kaXNwbGF5X25hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhlIG1vZGVyYXRvciBtYWlsIGZvciB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyBQcml2YXRlTWVzc2FnZSBvYmplY3RzXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0TW9kbWFpbCgpLnRoZW4oY29uc29sZS5sb2cpXG4gICovXG5cblxuICBnZXRNb2RtYWlsKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2Fib3V0L21lc3NhZ2UvbW9kZXJhdG9yXCIpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiBNb2RtYWlsQ29udmVyc2F0aW9ucyBmcm9tIHRoZSBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0aW5nPE1vZG1haWxDb252ZXJzYXRpb24+Pn0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VicmVkZGl0c1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXROZXdNb2RtYWlsQ29udmVyc2F0aW9ucyh7bGltaXQ6IDJ9KS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBNb2RtYWlsQ29udmVyc2F0aW9uIHsgbWVzc2FnZXM6IFsuLi5dLCBvYmpJZHM6IFsuLi5dLCBzdWJqZWN0OiAndGVzdCBzdWJqZWN0JywgLi4uIH0sXG4gICogLy8gIE1vZG1haWxDb252ZXJzYXRpb24geyBtZXNzYWdlczogWy4uLl0sIG9iaklkczogWy4uLl0sIHN1YmplY3Q6ICd0ZXN0IHN1YmplY3QnLCAuLi4gfVxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldE5ld01vZG1haWxDb252ZXJzYXRpb25zKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5fci5nZXROZXdNb2RtYWlsQ29udmVyc2F0aW9ucyhfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICBlbnRpdHk6IHRoaXMuZGlzcGxheV9uYW1lXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhlIG1vZGVyYXRpb24gbG9nIGZvciB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zLm1vZHNdIEFuIGFycmF5IG9mIG1vZGVyYXRvciBuYW1lcyB0aGF0IHRoZSByZXN1bHRzIHNob3VsZCBiZSByZXN0cmljdGVkIHRvXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnR5cGVdIFJlc3RyaWN0cyB0aGUgcmVzdWx0cyB0byB0aGUgc3BlY2lmaWVkIHR5cGUuIFRoaXMgc2hvdWxkIGJlIG9uZSBvZiBgYmFudXNlciwgdW5iYW51c2VyLFxuICByZW1vdmVsaW5rLCBhcHByb3ZlbGluaywgcmVtb3ZlY29tbWVudCwgYXBwcm92ZWNvbW1lbnQsIGFkZG1vZGVyYXRvciwgaW52aXRlbW9kZXJhdG9yLCB1bmludml0ZW1vZGVyYXRvcixcbiAgYWNjZXB0bW9kZXJhdG9yaW52aXRlLCByZW1vdmVtb2RlcmF0b3IsIGFkZGNvbnRyaWJ1dG9yLCByZW1vdmVjb250cmlidXRvciwgZWRpdHNldHRpbmdzLCBlZGl0ZmxhaXIsIGRpc3Rpbmd1aXNoLCBtYXJrbnNmdyxcbiAgd2lraWJhbm5lZCwgd2lraWNvbnRyaWJ1dG9yLCB3aWtpdW5iYW5uZWQsIHdpa2lwYWdlbGlzdGVkLCByZW1vdmV3aWtpY29udHJpYnV0b3IsIHdpa2lyZXZpc2UsIHdpa2lwZXJtbGV2ZWwsXG4gIGlnbm9yZXJlcG9ydHMsIHVuaWdub3JlcmVwb3J0cywgc2V0cGVybWlzc2lvbnMsIHNldHN1Z2dlc3RlZHNvcnQsIHN0aWNreSwgdW5zdGlja3ksIHNldGNvbnRlc3Rtb2RlLCB1bnNldGNvbnRlc3Rtb2RlLFxuICBsb2NrLCB1bmxvY2ssIG11dGV1c2VyLCB1bm11dGV1c2VyLCBjcmVhdGVydWxlLCBlZGl0cnVsZSwgZGVsZXRlcnVsZSwgc3BvaWxlciwgdW5zcG9pbGVyYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyBtb2RlcmF0aW9uIGFjdGlvbnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0TW9kZXJhdGlvbkxvZygpLnRoZW4oY29uc29sZS5sb2cpXG4gICpcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgTW9kQWN0aW9uIHsgZGVzY3JpcHRpb246IG51bGwsIG1vZDogJ3Nub293cmFwX3Rlc3RpbmcnLCBhY3Rpb246ICdlZGl0ZmxhaXInLCAuLi4gfVxuICAqIC8vICBNb2RBY3Rpb24geyBkZXNjcmlwdGlvbjogbnVsbCwgbW9kOiAnc25vb3dyYXBfdGVzdGluZycsIGFjdGlvbjogJ2FwcHJvdmVjb21tZW50JywgLi4uIH1cbiAgKiAvLyAgTW9kQWN0aW9uIHsgZGVzY3JpcHRpb246IG51bGwsIG1vZDogJ3Nub293cmFwX3Rlc3RpbmcnLCBhY3Rpb246ICdjcmVhdGVydWxlJywgLi4uIH1cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRNb2RlcmF0aW9uTG9nKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgcGFyc2VkT3B0aW9ucyA9ICgwLCBfbG9kYXNoLm9taXQpKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIG1vZDogb3B0aW9ucy5tb2RzICYmIG9wdGlvbnMubW9kcy5qb2luKCcsJylcbiAgICB9KSwgJ21vZHMnKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2Fib3V0L2xvZ1wiKSxcbiAgICAgIHFzOiBwYXJzZWRPcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgcmVwb3J0ZWQgaXRlbXMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub25seV0gUmVzdHJpY3RzIHRoZSBMaXN0aW5nIHRvIHRoZSBzcGVjaWZpZWQgdHlwZSBvZiBpdGVtLiBPbmUgb2YgYGxpbmtzLCBjb21tZW50c2BcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgcmVwb3J0ZWQgaXRlbXNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0UmVwb3J0cygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgQ29tbWVudCB7IC4uLiB9LFxuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldFJlcG9ydHMoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYWJvdXQvcmVwb3J0c1wiKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgcmVtb3ZlZCBpdGVtcyBvbiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbmx5XSBSZXN0cmljdHMgdGhlIExpc3RpbmcgdG8gdGhlIHNwZWNpZmllZCB0eXBlIG9mIGl0ZW0uIE9uZSBvZiBgbGlua3MsIGNvbW1lbnRzYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyByZW1vdmVkIGl0ZW1zXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFNwYW0oKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRTcGFtKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2Fib3V0L3NwYW1cIiksXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYSBsaXN0IG9mIGl0ZW1zIG9uIHRoZSBtb2RxdWV1ZSBvbiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbmx5XSBSZXN0cmljdHMgdGhlIExpc3RpbmcgdG8gdGhlIHNwZWNpZmllZCB0eXBlIG9mIGl0ZW0uIE9uZSBvZiBgbGlua3MsIGNvbW1lbnRzYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyBpdGVtcyBvbiB0aGUgbW9kcXVldWVcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0TW9kcXVldWUoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRNb2RxdWV1ZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hYm91dC9tb2RxdWV1ZVwiKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgdW5tb2RlcmF0ZWQgaXRlbXMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub25seV0gUmVzdHJpY3RzIHRoZSBMaXN0aW5nIHRvIHRoZSBzcGVjaWZpZWQgdHlwZSBvZiBpdGVtLiBPbmUgb2YgYGxpbmtzLCBjb21tZW50c2BcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgdW5tb2RlcmF0ZWQgaXRlbXNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0VW5tb2RlcmF0ZWQoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRVbm1vZGVyYXRlZCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hYm91dC91bm1vZGVyYXRlZFwiKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgZWRpdGVkIGl0ZW1zIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9ubHldIFJlc3RyaWN0cyB0aGUgTGlzdGluZyB0byB0aGUgc3BlY2lmaWVkIHR5cGUgb2YgaXRlbS4gT25lIG9mIGBsaW5rcywgY29tbWVudHNgXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIGVkaXRlZCBpdGVtc1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRFZGl0ZWQoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICBDb21tZW50IHsgLi4uIH0sXG4gICogLy8gIENvbW1lbnQgeyAuLi4gfSxcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRFZGl0ZWQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYWJvdXQvZWRpdGVkXCIpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBBY2NlcHRzIGFuIGludml0ZSB0byBiZWNvbWUgYSBtb2RlcmF0b3Igb2YgdGhpcyBzdWJyZWRkaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmFjY2VwdE1vZGVyYXRvckludml0ZSgpXG4gICovXG5cblxuICBhY2NlcHRNb2RlcmF0b3JJbnZpdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hcGkvYWNjZXB0X21vZGVyYXRvcl9pbnZpdGVcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlXG4gICAgICB9XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEFiZGljYXRlcyBtb2RlcmF0b3Igc3RhdHVzIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykubGVhdmVNb2RlcmF0b3IoKVxuICAqL1xuXG5cbiAgbGVhdmVNb2RlcmF0b3IoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5mZXRjaCgpLmdldCgnbmFtZScpLnRoZW4oZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfdGhpczQuX3Bvc3Qoe1xuICAgICAgICB1cmk6ICdhcGkvbGVhdmVtb2RlcmF0b3InLFxuICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgaWQ6IG5hbWVcbiAgICAgICAgfVxuICAgICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykoX3RoaXM0KSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgQWJkaWNhdGVzIGFwcHJvdmVkIHN1Ym1pdHRlciBzdGF0dXMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZS5cbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5sZWF2ZUNvbnRyaWJ1dG9yKClcbiAgKi9cblxuXG4gIGxlYXZlQ29udHJpYnV0b3IoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5mZXRjaCgpLmdldCgnbmFtZScpLnRoZW4oZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfdGhpczUuX3Bvc3Qoe1xuICAgICAgICB1cmk6ICdhcGkvbGVhdmVjb250cmlidXRvcicsXG4gICAgICAgIGZvcm06IHtcbiAgICAgICAgICBpZDogbmFtZVxuICAgICAgICB9XG4gICAgICB9KS5yZXR1cm4oX3RoaXM1KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIGEgc3VicmVkZGl0J3MgQ1NTIHN0eWxlc2hlZXQuXG4gICogQGRlc2MgKipOb3RlKio6IFRoaXMgZnVuY3Rpb24gd2lsbCBub3Qgd29yayB3aGVuIHNub293cmFwIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyLCBiZWNhdXNlIHRoZSByZWRkaXQgc2VydmVyIHNlbmRzIGFcbiAgcmVkaXJlY3Qgd2hpY2ggY2Fubm90IGJlIGZvbGxvd2VkIGJ5IGEgQ09SUyByZXF1ZXN0LlxuICAqIEBkZXNjICoqTm90ZSoqOiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhIDQwNCBlcnJvciBpZiB0aGUgc3VicmVkZGl0IGluIHF1ZXN0aW9uIGRvZXMgbm90IGhhdmUgYSBjdXN0b20gc3R5bGVzaGVldC5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIGZvciBhIHN0cmluZyBjb250YWluaW5nIHRoZSBzdWJyZWRkaXQncyBDU1MuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFN0eWxlc2hlZXQoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+ICcubWQgYmxvY2txdW90ZSwubWQgZGVsLGJvZHl7Y29sb3I6IzEyMTIxMn0udXNlcnRleHQtYm9keSAuLi4gJ1xuICAqL1xuXG5cbiAgZ2V0U3R5bGVzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvc3R5bGVzaGVldFwiKSxcbiAgICAgIGpzb246IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgQ29uZHVjdHMgYSBzZWFyY2ggb2YgcmVkZGl0IHN1Ym1pc3Npb25zLCByZXN0cmljdGVkIHRvIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFNlYXJjaCBvcHRpb25zLiBDYW4gYWxzbyBjb250YWluIG9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZy5cbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5xdWVyeSBUaGUgc2VhcmNoIHF1ZXJ5XG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRpbWVdIERlc2NyaWJlcyB0aGUgdGltZXNwYW4gdGhhdCBwb3N0cyBzaG91bGQgYmUgcmV0cmlldmVkIGZyb21lLiBPbmUgb2ZcbiAgYGhvdXIsIGRheSwgd2VlaywgbW9udGgsIHllYXIsIGFsbGBcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc29ydF0gRGV0ZXJtaW5lcyBob3cgdGhlIHJlc3VsdHMgc2hvdWxkIGJlIHNvcnRlZC4gT25lIG9mIGByZWxldmFuY2UsIGhvdCwgdG9wLCBuZXcsIGNvbW1lbnRzYFxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zeW50YXg9J3BsYWluJ10gU3BlY2lmaWVzIGEgc3ludGF4IGZvciB0aGUgc2VhcmNoLiBPbmUgb2YgYGNsb3Vkc2VhcmNoLCBsdWNlbmUsIHBsYWluYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyB0aGUgc2VhcmNoIHJlc3VsdHMuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnNlYXJjaCh7cXVlcnk6ICdibGFoJywgc29ydDogJ3llYXInfSkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIHNlYXJjaChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Iuc2VhcmNoKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIHN1YnJlZGRpdDogdGhpcyxcbiAgICAgIHJlc3RyaWN0U3I6IHRydWVcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyB0aGUgbGlzdCBvZiBiYW5uZWQgdXNlcnMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgRmlsdGVyaW5nIG9wdGlvbnMuIENhbiBhbHNvIGNvbnRhaW4gb3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgQSB1c2VybmFtZSBvbiB0aGUgbGlzdCB0byBqdW1wIHRvLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3Rpbmcgb2YgdXNlcnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0QmFubmVkVXNlcnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICB7IGRhdGU6IDE0NjE3MjA5MzYsIG5vdGU6ICcnLCBuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnLCBpZDogJ3QyX3EzNTE5JyB9XG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKlxuICAqL1xuXG5cbiAgZ2V0QmFubmVkVXNlcnMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYWJvdXQvYmFubmVkXCIpLFxuICAgICAgcXM6ICgwLCBfaGVscGVycy5yZW5hbWVLZXkpKG9wdGlvbnMsICduYW1lJywgJ3VzZXInKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhlIGxpc3Qgb2YgbXV0ZWQgdXNlcnMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgRmlsdGVyaW5nIG9wdGlvbnMuIENhbiBhbHNvIGNvbnRhaW4gb3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgQSB1c2VybmFtZSBvbiB0aGUgbGlzdCB0byBqdW1wIHRvLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3Rpbmcgb2YgdXNlcnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0QmFubmVkVXNlcnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICB7IGRhdGU6IDE0NjE3MjA5MzYsIG5hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsIGlkOiAndDJfcTM1MTknIH1cbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0TXV0ZWRVc2VycyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hYm91dC9tdXRlZFwiKSxcbiAgICAgIHFzOiAoMCwgX2hlbHBlcnMucmVuYW1lS2V5KShvcHRpb25zLCAnbmFtZScsICd1c2VyJylcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIHRoZSBsaXN0IG9mIHVzZXJzIGJhbm5lZCBmcm9tIHRoaXMgc3VicmVkZGl0J3Mgd2lraS5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBGaWx0ZXJpbmcgb3B0aW9ucy4gQ2FuIGFsc28gY29udGFpbiBvcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmcuXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBBIHVzZXJuYW1lIG9uIHRoZSBsaXN0IHRvIGp1bXAgdG8uXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBvZiB1c2Vyc1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRXaWtpYmFubmVkVXNlcnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICB7IGRhdGU6IDE0NjE3MjA5MzYsIG5vdGU6ICcnLCBuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnLCBpZDogJ3QyX3EzNTE5JyB9XG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldFdpa2liYW5uZWRVc2VycyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hYm91dC93aWtpYmFubmVkXCIpLFxuICAgICAgcXM6ICgwLCBfaGVscGVycy5yZW5hbWVLZXkpKG9wdGlvbnMsICduYW1lJywgJ3VzZXInKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhlIGxpc3Qgb2YgYXBwcm92ZWQgc3VibWl0dGVycyBvbiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBGaWx0ZXJpbmcgb3B0aW9ucy4gQ2FuIGFsc28gY29udGFpbiBvcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmcuXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBBIHVzZXJuYW1lIG9uIHRoZSBsaXN0IHRvIGp1bXAgdG8uXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBvZiB1c2Vyc1xuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRDb250cmlidXRvcnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICB7IGRhdGU6IDE0NjE3MjA5MzYsIG5hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsIGlkOiAndDJfcTM1MTknIH1cbiAgKiAvLyAgLi4uXG4gICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0Q29udHJpYnV0b3JzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2Fib3V0L2NvbnRyaWJ1dG9yc1wiKSxcbiAgICAgIHFzOiAoMCwgX2hlbHBlcnMucmVuYW1lS2V5KShvcHRpb25zLCAnbmFtZScsICd1c2VyJylcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIHRoZSBsaXN0IG9mIGFwcHJvdmVkIHdpa2kgc3VibWl0dGVycyBvbiB0aGlzIHN1YnJlZGRpdCAuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgRmlsdGVyaW5nIG9wdGlvbnMuIENhbiBhbHNvIGNvbnRhaW4gb3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgQSB1c2VybmFtZSBvbiB0aGUgbGlzdCB0byBqdW1wIHRvLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3Rpbmcgb2YgdXNlcnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0V2lraUNvbnRyaWJ1dG9ycygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbXG4gICogLy8gIHsgZGF0ZTogMTQ2MTcyMDkzNiwgbmFtZTogJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJywgaWQ6ICd0Ml9xMzUxOScgfVxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRXaWtpQ29udHJpYnV0b3JzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2Fib3V0L3dpa2ljb250cmlidXRvcnNcIiksXG4gICAgICBxczogKDAsIF9oZWxwZXJzLnJlbmFtZUtleSkob3B0aW9ucywgJ25hbWUnLCAndXNlcicpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyB0aGUgbGlzdCBvZiBtb2RlcmF0b3JzIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWVdIFRoZSBuYW1lIG9mIGEgdXNlciB0byBmaW5kIGluIHRoZSBsaXN0XG4gICogQHJldHVybnMge1Byb21pc2V9IEFuIEFycmF5IG9mIFJlZGRpdFVzZXJzIHJlcHJlc2VudGluZyB0aGUgbW9kZXJhdG9ycyBvZiB0aGlzIHN1YnJlZGRpdFxuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnQXNrUmVkZGl0JykuZ2V0TW9kZXJhdG9ycygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gW1xuICAqIC8vICBSZWRkaXRVc2VyIHsgZGF0ZTogMTQ1Mzg2MjYzOSwgbW9kX3Blcm1pc3Npb25zOiBbICdhbGwnIF0sIG5hbWU6ICdub3RfYW5fYWFyZHZhcmsnLCBpZDogJ3QyX2s4M21kJyB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICpcbiAgKi9cblxuXG4gIGdldE1vZGVyYXRvcnMoKSB7XG4gICAgdmFyIF9yZWY2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgbmFtZSA9IF9yZWY2Lm5hbWU7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYWJvdXQvbW9kZXJhdG9yc1wiKSxcbiAgICAgIHFzOiB7XG4gICAgICAgIHVzZXI6IG5hbWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBEZWxldGVzIHRoZSBiYW5uZXIgZm9yIHRoaXMgU3VicmVkZGl0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5kZWxldGVCYW5uZXIoKVxuICAqL1xuXG5cbiAgZGVsZXRlQmFubmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL2RlbGV0ZV9zcl9iYW5uZXJcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlXG4gICAgICB9XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IERlbGV0ZXMgdGhlIGhlYWRlciBpbWFnZSBmb3IgdGhpcyBTdWJyZWRkaXQuXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmRlbGV0ZUhlYWRlcigpXG4gICovXG5cblxuICBkZWxldGVIZWFkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hcGkvZGVsZXRlX3NyX2hlYWRlclwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGVcbiAgICAgIH1cbiAgICB9KS50aGVuKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRGVsZXRlcyB0aGlzIHN1YnJlZGRpdCdzIGljb24uXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmRlbGV0ZUljb24oKVxuICAqL1xuXG5cbiAgZGVsZXRlSWNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2FwaS9kZWxldGVfc3JfaWNvblwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGVcbiAgICAgIH1cbiAgICB9KS50aGVuKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRGVsZXRlcyBhbiBpbWFnZSBmcm9tIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaW1hZ2VOYW1lIFRoZSBuYW1lIG9mIHRoZSBpbWFnZS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZGVsZXRlSW1hZ2UoKVxuICAqL1xuXG5cbiAgZGVsZXRlSW1hZ2UoX3JlZjcpIHtcbiAgICB2YXIgaW1hZ2VfbmFtZSA9IF9yZWY3LmltYWdlX25hbWUsXG4gICAgICAgIF9yZWY3JGltYWdlTmFtZSA9IF9yZWY3LmltYWdlTmFtZSxcbiAgICAgICAgaW1hZ2VOYW1lID0gX3JlZjckaW1hZ2VOYW1lID09PSB2b2lkIDAgPyBpbWFnZV9uYW1lIDogX3JlZjckaW1hZ2VOYW1lO1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL2RlbGV0ZV9zcl9pbWdcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlLFxuICAgICAgICBpbWdfbmFtZTogaW1hZ2VOYW1lXG4gICAgICB9XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhpcyBzdWJyZWRkaXQncyBjdXJyZW50IHNldHRpbmdzLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBbiBPYmplY3QgY29udGFpbmluZyB0aGlzIHN1YnJlZGRpdCdzIGN1cnJlbnQgc2V0dGluZ3MuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFNldHRpbmdzKCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBTdWJyZWRkaXRTZXR0aW5ncyB7IGRlZmF1bHRfc2V0OiB0cnVlLCBzdWJtaXRfdGV4dDogJycsIHN1YnJlZGRpdF90eXBlOiAncHJpdmF0ZScsIC4uLiB9XG4gICovXG5cblxuICBnZXRTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYWJvdXQvZWRpdFwiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEVkaXRzIHRoaXMgc3VicmVkZGl0J3Mgc2V0dGluZ3MuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gT2JqZWN0IGNvbnRhaW5pbmcge1tvcHRpb24gbmFtZV06IG5ldyB2YWx1ZX0gbWFwcGluZ3Mgb2YgdGhlIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gIEFueSBvbWl0dGVkIG9wdGlvbiBuYW1lcyB3aWxsIHNpbXBseSByZXRhaW4gdGhlaXIgcHJldmlvdXMgdmFsdWVzLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGFwcGVhciBpbiB0aGUgaGVhZGVyIG9mIHRoZSBzdWJyZWRkaXRcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5wdWJsaWNfZGVzY3JpcHRpb24gVGhlIHRleHQgdGhhdCBhcHBlYXJzIHdpdGggdGhpcyBTdWJyZWRkaXQgb24gdGhlIHNlYXJjaCBwYWdlLCBvciBvbiB0aGVcbiAgYmxvY2tlZC1hY2Nlc3MgcGFnZSBpZiB0aGlzIHN1YnJlZGRpdCBpcyBwcml2YXRlLiAoNTAwIGNoYXJhY3RlcnMgbWF4KVxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRlc2NyaXB0aW9uIFRoZSBzaWRlYmFyIHRleHQgZm9yIHRoZSBzdWJyZWRkaXQuICg1MTIwIGNoYXJhY3RlcnMgbWF4KVxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdWJtaXRfdGV4dD0nJ10gVGhlIHRleHQgdG8gc2hvdyBiZWxvdyB0aGUgc3VibWlzc2lvbiBwYWdlICgxMDI0IGNoYXJhY3RlcnMgbWF4KVxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGlkZV9hZHM9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciBhZHMgc2hvdWxkIGJlIGhpZGRlbiBvbiB0aGlzIHN1YnJlZGRpdC4gKFRoaXMgaXMgb25seVxuICBhbGxvd2VkIGZvciBnb2xkLW9ubHkgc3VicmVkZGl0cy4pXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmc9J2VuJ10gVGhlIGxhbmd1YWdlIG9mIHRoZSBzdWJyZWRkaXQgKHJlcHJlc2VudGVkIGFzIGFuIElFVEYgbGFuZ3VhZ2UgdGFnKVxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50eXBlPSdwdWJsaWMnXSBEZXRlcm1pbmVzIHdobyBzaG91bGQgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIHN1YnJlZGRpdC4gVGhpcyBzaG91bGQgYmUgb25lIG9mXG4gIGBwdWJsaWMsIHByaXZhdGUsIHJlc3RyaWN0ZWQsIGdvbGRfcmVzdHJpY3RlZCwgZ29sZF9vbmx5LCBhcmNoaXZlZCwgZW1wbG95ZWVzX29ubHlgLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5saW5rX3R5cGU9J2FueSddIERldGVybWluZXMgd2hhdCB0eXBlcyBvZiBzdWJtaXNzaW9ucyBhcmUgYWxsb3dlZCBvbiB0aGUgc3VicmVkZGl0LiBUaGlzIHNob3VsZFxuICBiZSBvbmUgb2YgYGFueSwgbGluaywgc2VsZmAuXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN1Ym1pdF9saW5rX2xhYmVsPXVuZGVmaW5lZF0gQ3VzdG9tIHRleHQgdG8gZGlzcGxheSBvbiB0aGUgYnV0dG9uIHRoYXQgc3VibWl0cyBhIGxpbmsuIElmXG4gIHRoaXMgaXMgb21pdHRlZCwgdGhlIGRlZmF1bHQgdGV4dCB3aWxsIGJlIGRpc3BsYXllZC5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3VibWl0X3RleHRfbGFiZWw9dW5kZWZpbmVkXSBDdXN0b20gdGV4dCB0byBkaXNwbGF5IG9uIHRoZSBidXR0b24gdGhhdCBzdWJtaXRzIGEgc2VsZnBvc3QuIElmXG4gIHRoaXMgaXMgb21pdHRlZCwgdGhlIGRlZmF1bHQgdGV4dCB3aWxsIGJlIGRpc3BsYXllZC5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud2lraW1vZGU9J21vZG9ubHknXSBEZXRlcm1pbmVzIHdobyBjYW4gZWRpdCB3aWtpIHBhZ2VzIG9uIHRoZSBzdWJyZWRkaXQuIFRoaXMgc2hvdWxkIGJlIG9uZSBvZlxuICBgbW9kb25seSwgYW55b25lLCBkaXNhYmxlZGAuXG4gICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpa2lfZWRpdF9rYXJtYT0wXSBUaGUgbWluaW11bSBhbW91bnQgb2Ygc3VicmVkZGl0IGthcm1hIG5lZWRlZCBmb3Igc29tZW9uZSB0byBlZGl0IHRoaXNcbiAgc3VicmVkZGl0J3Mgd2lraS4gKFRoaXMgaXMgb25seSByZWxldmFudCBpZiBgb3B0aW9ucy53aWtpbW9kZWAgaXMgc2V0IHRvIGBhbnlvbmVgLilcbiAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lraV9lZGl0X2FnZT0wXSBUaGUgbWluaW11bSBhY2NvdW50IGFnZSAoaW4gZGF5cykgbmVlZGVkIGZvciBzb21lb25lIHRvIGVkaXQgdGhpcyBzdWJyZWRkaXQnc1xuICB3aWtpLiAoVGhpcyBpcyBvbmx5IHJlbGV2YW50IGlmIGBvcHRpb25zLndpa2ltb2RlYCBpcyBzZXQgdG8gYGFueW9uZWAuKVxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcGFtX2xpbmtzPSdoaWdoJ10gVGhlIHNwYW0gZmlsdGVyIHN0cmVuZ3RoIGZvciBsaW5rcyBvbiB0aGlzIHN1YnJlZGRpdC4gVGhpcyBzaG91bGQgYmUgb25lIG9mXG4gIGBsb3csIGhpZ2gsIGFsbGAuXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNwYW1fc2VsZnBvc3RzPSdoaWdoJ10gVGhlIHNwYW0gZmlsdGVyIHN0cmVuZ3RoIGZvciBzZWxmcG9zdHMgb24gdGhpcyBzdWJyZWRkaXQuIFRoaXMgc2hvdWxkIGJlXG4gIG9uZSBvZiBgbG93LCBoaWdoLCBhbGxgLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcGFtX2NvbW1lbnRzPSdoaWdoJ10gVGhlIHNwYW0gZmlsdGVyIHN0cmVuZ3RoIGZvciBjb21tZW50cyBvbiB0aGlzIHN1YnJlZGRpdC4gVGhpcyBzaG91bGQgYmUgb25lXG4gIG9mIGBsb3csIGhpZ2gsIGFsbGAuXG4gICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vdmVyXzE4PWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBzdWJyZWRkaXQgc2hvdWxkIGJlIGNsYXNzaWZpZWQgYXMgTlNGV1xuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dfdG9wPXRydWVdIERldGVybWluZXMgd2hldGhlciB0aGUgbmV3IHN1YnJlZGRpdCBzaG91bGQgYmUgYWJsZSB0byBhcHBlYXIgaW4gL3IvYWxsIGFuZFxuICB0cmVuZGluZyBzdWJyZWRkaXRzXG4gICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zaG93X21lZGlhPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgaW1hZ2UgdGh1bWJuYWlscyBzaG91bGQgYmUgZW5hYmxlZCBvbiB0aGlzIHN1YnJlZGRpdFxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2hvd19tZWRpYV9wcmV2aWV3PXRydWVdIERldGVybWluZXMgd2hldGhlciBtZWRpYSBwcmV2aWV3cyBzaG91bGQgYmUgZXhwYW5kZWQgYnkgZGVmYXVsdCBvbiB0aGlzXG4gIHN1YnJlZGRpdFxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dfaW1hZ2VzPXRydWVdIERldGVybWluZXMgd2hldGhlciBpbWFnZSB1cGxvYWRzIGFuZCBsaW5rcyB0byBpbWFnZSBob3N0aW5nIHNpdGVzIHNob3VsZCBiZVxuICBlbmFibGVkIG9uIHRoaXMgc3VicmVkZGl0XG4gICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5leGNsdWRlX2Jhbm5lZF9tb2RxdWV1ZT1mYWxzZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHBvc3RzIGJ5IHNpdGUtd2lkZSBiYW5uZWQgdXNlcnMgc2hvdWxkIGJlXG4gIGV4Y2x1ZGVkIGZyb20gdGhlIG1vZHF1ZXVlLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHVibGljX3RyYWZmaWM9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciB0aGUgL2Fib3V0L3RyYWZmaWMgcGFnZSBmb3IgdGhpcyBzdWJyZWRkaXQgc2hvdWxkIGJlXG4gIHZpZXdhYmxlIGJ5IGFueW9uZS5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbGxhcHNlX2RlbGV0ZWRfY29tbWVudHM9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciBkZWxldGVkIGFuZCByZW1vdmVkIGNvbW1lbnRzIHNob3VsZCBiZVxuICBjb2xsYXBzZWQgYnkgZGVmYXVsdFxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdWdnZXN0ZWRfY29tbWVudF9zb3J0PXVuZGVmaW5lZF0gVGhlIHN1Z2dlc3RlZCBjb21tZW50IHNvcnQgZm9yIHRoZSBzdWJyZWRkaXQuIFRoaXMgc2hvdWxkIGJlXG4gIG9uZSBvZiBgY29uZmlkZW5jZSwgdG9wLCBuZXcsIGNvbnRyb3ZlcnNpYWwsIG9sZCwgcmFuZG9tLCBxYWAuSWYgbGVmdCBibGFuaywgdGhlcmUgd2lsbCBiZSBubyBzdWdnZXN0ZWQgc29ydCxcbiAgd2hpY2ggbWVhbnMgdGhhdCB1c2VycyB3aWxsIHNlZSB0aGUgc29ydCBtZXRob2QgdGhhdCBpcyBzZXQgaW4gdGhlaXIgb3duIHByZWZlcmVuY2VzICh1c3VhbGx5IGBjb25maWRlbmNlYC4pXG4gICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zcG9pbGVyc19lbmFibGVkPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdXNlcnMgY2FuIG1hcmsgdGhlaXIgcG9zdHMgYXMgc3BvaWxlcnNcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmVkaXRTZXR0aW5ncyh7c3VibWl0X3RleHQ6ICdXZWxjb21lISBQbGVhc2UgYmUgc3VyZSB0byByZWFkIHRoZSBydWxlcy4nfSlcbiAgKi9cblxuXG4gIGVkaXRTZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5qb2luKHRoaXMuZ2V0U2V0dGluZ3MoKSwgdGhpcy5mZXRjaCgpLmdldCgnbmFtZScpLCBmdW5jdGlvbiAoY3VycmVudFZhbHVlcywgbmFtZSkge1xuICAgICAgcmV0dXJuIF90aGlzNi5fci5fY3JlYXRlT3JFZGl0U3VicmVkZGl0KF9vYmplY3RTcHJlYWQoe30sICgwLCBfaGVscGVycy5yZW5hbWVLZXkpKGN1cnJlbnRWYWx1ZXMsICdzdWJyZWRkaXRfdHlwZScsICd0eXBlJyksIHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHNyOiBuYW1lXG4gICAgICB9KSk7XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYSBsaXN0IG9mIHJlY29tbWVuZGVkIG90aGVyIHN1YnJlZGRpdHMgZ2l2ZW4gdGhpcyBvbmUuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9taXQ9W11dIEFuIEFycmF5IG9mIHN1YnJlZGRpdCBuYW1lcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIHRoZSBsaXN0aW5nLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBbiBBcnJheSBvZiBzdWJyZWRkaXQgbmFtZXNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ0Fza1JlZGRpdCcpLmdldFJlY29tbWVuZGVkU3VicmVkZGl0cygpLnRoZW4oY29uc29sZS5sb2cpO1xuICAqIC8vIFsgJ1RoZUNodXJjaE9mUm9nZXJzJywgJ1NsZWVweWNhYmluJywgLi4uIF1cbiAgKi9cblxuXG4gIGdldFJlY29tbWVuZGVkU3VicmVkZGl0cyhvcHRpb25zKSB7XG4gICAgdmFyIHRvT21pdCA9IG9wdGlvbnMub21pdCAmJiBvcHRpb25zLm9taXQuam9pbignLCcpO1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiBcImFwaS9yZWNvbW1lbmQvc3IvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lKSxcbiAgICAgIHFzOiB7XG4gICAgICAgIG9taXQ6IHRvT21pdFxuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICByZXR1cm4gKDAsIF9sb2Rhc2gubWFwKShuYW1lcywgJ3NyX25hbWUnKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIHRoZSBzdWJtaXQgdGV4dCAod2hpY2ggZGlzcGxheXMgb24gdGhlIHN1Ym1pc3Npb24gZm9ybSkgZm9yIHRoaXMgc3VicmVkZGl0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgc3VibWl0IHRleHQsIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRTdWJtaXRUZXh0KCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiAnV2VsY29tZSEgUGxlYXNlIGJlIHN1cmUgdG8gcmVhZCB0aGUgcnVsZXMuJ1xuICAqL1xuXG5cbiAgZ2V0U3VibWl0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL3N1Ym1pdF90ZXh0XCIpXG4gICAgfSkuZ2V0KCdzdWJtaXRfdGV4dCcpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVwZGF0ZXMgdGhpcyBzdWJyZWRkaXQncyBzdHlsZXNoZWV0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY3NzIFRoZSBuZXcgY29udGVudHMgb2YgdGhlIHN0eWxlc2hlZXRcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVhc29uXSBUaGUgcmVhc29uIGZvciB0aGUgY2hhbmdlICgyNTYgY2hhcmFjdGVycyBtYXgpXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnVwZGF0ZVN0eWxlc2hlZXQoe2NzczogJ2JvZHkge2NvbG9yOiMwMGZmMDA7fScsIHJlYXNvbjogJ3lheSBncmVlbid9KVxuICAqL1xuXG5cbiAgdXBkYXRlU3R5bGVzaGVldChfcmVmOCkge1xuICAgIHZhciBjc3MgPSBfcmVmOC5jc3MsXG4gICAgICAgIHJlYXNvbiA9IF9yZWY4LnJlYXNvbjtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2FwaS9zdWJyZWRkaXRfc3R5bGVzaGVldFwiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIG9wOiAnc2F2ZScsXG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgc3R5bGVzaGVldF9jb250ZW50czogY3NzXG4gICAgICB9XG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpO1xuICB9XG5cbiAgX3NldFN1YnNjcmliZWQoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3N1YnNjcmliZScsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFjdGlvbjogc3RhdHVzID8gJ3N1YicgOiAndW5zdWInLFxuICAgICAgICBzcl9uYW1lOiB0aGlzLmRpc3BsYXlfbmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBTdWJzY3JpYmVzIHRvIHRoaXMgc3VicmVkZGl0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5zdWJzY3JpYmUoKVxuICAqL1xuXG5cbiAgc3Vic2NyaWJlKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXRTdWJzY3JpYmVkKHRydWUpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVuc3Vic2NyaWJlcyBmcm9tIHRoaXMgc3VicmVkZGl0LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS51bnN1YnNjcmliZSgpXG4gICovXG5cblxuICB1bnN1YnNjcmliZSgpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIC8qIFJlZGRpdCByZXR1cm5zIGEgNDA0IGVycm9yIGlmIHRoZSB1c2VyIGF0dGVtcHRzIHRvIHVuc3Vic2NyaWJlIHRvIGEgc3VicmVkZGl0IHRoYXQgdGhleSB3ZXJlbid0IHN1YnNjcmliZWQgdG8gaW4gdGhlXG4gICAgZmlyc3QgcGxhY2UuIEl0IGFsc28gKGFzIG9uZSB3b3VsZCBleHBlY3QpIHJldHVybnMgYSA0MDQgZXJyb3IgaWYgdGhlIHN1YnJlZGRpdCBpbiBxdWVzdGlvbiBkb2VzIG5vdCBleGlzdC4gc25vb3dyYXBcbiAgICBzaG91bGQgc3dhbGxvdyB0aGUgZmlyc3QgdHlwZSBvZiBlcnJvciBpbnRlcm5hbGx5LCBidXQgaXQgc2hvdWxkIHJhaXNlIHRoZSBzZWNvbmQgdHlwZSBvZiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhlIGVycm9yc1xuICAgIHRoZW1zZWx2ZXMgYXJlIGluZGlzdGluZ3Vpc2hhYmxlLiBTbyBpZiBhIDQwNCBlcnJvciBnZXRzIHRocm93biwgZmV0Y2ggdGhlIGN1cnJlbnQgc3VicmVkZGl0IHRvIGNoZWNrIGlmIGl0IGV4aXN0cy4gSWYgaXRcbiAgICBkb2VzIGV4aXN0LCB0aGVuIHRoZSA0MDQgZXJyb3Igd2FzIG9mIHRoZSBmaXJzdCB0eXBlLCBzbyBzd2FsbG93IGl0IGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgU3VicmVkZGl0IG9iamVjdCBhcyB1c3VhbC4gSWZcbiAgICB0aGUgc3VicmVkZGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4gdGhlIG9yaWdpbmFsIGVycm9yIHdhcyBvZiB0aGUgc2Vjb25kIHR5cGUsIHNvIHRocm93IGl0LiAqL1xuICAgIHJldHVybiB0aGlzLl9zZXRTdWJzY3JpYmVkKGZhbHNlKS5jYXRjaCh7XG4gICAgICBzdGF0dXNDb2RlOiA0MDRcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gX3RoaXM3LmZldGNoKCkucmV0dXJuKF90aGlzNykuY2F0Y2hUaHJvdyhlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgX3VwbG9hZFNySW1nKF9yZWY5KSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICB2YXIgbmFtZSA9IF9yZWY5Lm5hbWUsXG4gICAgICAgIGZpbGUgPSBfcmVmOS5maWxlLFxuICAgICAgICB1cGxvYWRUeXBlID0gX3JlZjkudXBsb2FkVHlwZSxcbiAgICAgICAgaW1hZ2VUeXBlID0gX3JlZjkuaW1hZ2VUeXBlO1xuXG4gICAgaWYgKHR5cGVvZiBmaWxlICE9PSAnc3RyaW5nJyAmJiAhKGZpbGUgaW5zdGFuY2VvZiBfc3RyZWFtLlJlYWRhYmxlKSkge1xuICAgICAgdGhyb3cgbmV3IF9lcnJvcnMuSW52YWxpZE1ldGhvZENhbGxFcnJvcignVXBsb2FkZWQgaW1hZ2UgZmlsZXBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhIFJlYWRhYmxlU3RyZWFtLicpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRGaWxlID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gKDAsIF9mcy5jcmVhdGVSZWFkU3RyZWFtKShmaWxlKSA6IGZpbGU7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hcGkvdXBsb2FkX3NyX2ltZ1wiKSxcbiAgICAgIGZvcm1EYXRhOiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHVwbG9hZF90eXBlOiB1cGxvYWRUeXBlLFxuICAgICAgICBpbWdfdHlwZTogaW1hZ2VUeXBlLFxuICAgICAgICBmaWxlOiBwYXJzZWRGaWxlXG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yc1swXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzODtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBVcGxvYWRzIGFuIGltYWdlIGZvciB1c2UgaW4gdGhpcyBzdWJyZWRkaXQncyBzdHlsZXNoZWV0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBuZXcgaW1hZ2Ugc2hvdWxkIGhhdmUgaW4gdGhlIHN0eWxlc2hlZXRcbiAgKiBAcGFyYW0ge3N0cmluZ3xzdHJlYW0uUmVhZGFibGV9IG9wdGlvbnMuZmlsZSBUaGUgaW1hZ2UgZmlsZSB0aGF0IHNob3VsZCBnZXQgdXBsb2FkZWQuIFRoaXMgc2hvdWxkIGVpdGhlciBiZSB0aGUgcGF0aCB0byBhblxuICBpbWFnZSBmaWxlLCBvciBhIFtSZWFkYWJsZVN0cmVhbV0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fY2xhc3Nfc3RyZWFtX3JlYWRhYmxlKSBpbiBlbnZpcm9ubWVudHMgKGUuZy5cbiAgYnJvd3NlcnMpIHdoZXJlIHRoZSBmaWxlc3lzdGVtIGlzIHVuYXZhaWxhYmxlLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbWFnZVR5cGU9J3BuZyddIERldGVybWluZXMgaG93IHRoZSB1cGxvYWRlZCBpbWFnZSBzaG91bGQgYmUgc3RvcmVkLiBPbmUgb2YgYHBuZywganBnYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykudXBsb2FkU3VicmVkZGl0SW1hZ2Uoe25hbWU6ICd0aGUgY29va2llIG1vbnN0ZXInLCBmaWxlOiAnLi9jb29raWVfbW9uc3Rlci5wbmcnfSlcbiAgKi9cblxuXG4gIHVwbG9hZFN0eWxlc2hlZXRJbWFnZShfcmVmMTApIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYxMC5uYW1lLFxuICAgICAgICBmaWxlID0gX3JlZjEwLmZpbGUsXG4gICAgICAgIF9yZWYxMCRpbWFnZV90eXBlID0gX3JlZjEwLmltYWdlX3R5cGUsXG4gICAgICAgIGltYWdlX3R5cGUgPSBfcmVmMTAkaW1hZ2VfdHlwZSA9PT0gdm9pZCAwID8gJ3BuZycgOiBfcmVmMTAkaW1hZ2VfdHlwZSxcbiAgICAgICAgX3JlZjEwJGltYWdlVHlwZSA9IF9yZWYxMC5pbWFnZVR5cGUsXG4gICAgICAgIGltYWdlVHlwZSA9IF9yZWYxMCRpbWFnZVR5cGUgPT09IHZvaWQgMCA/IGltYWdlX3R5cGUgOiBfcmVmMTAkaW1hZ2VUeXBlO1xuICAgIHJldHVybiB0aGlzLl91cGxvYWRTckltZyh7XG4gICAgICBuYW1lLFxuICAgICAgZmlsZSxcbiAgICAgIGltYWdlVHlwZSxcbiAgICAgIHVwbG9hZFR5cGU6ICdpbWcnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgVXBsb2FkcyBhbiBpbWFnZSB0byB1c2UgYXMgdGhpcyBzdWJyZWRkaXQncyBoZWFkZXIuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ3xzdHJlYW0uUmVhZGFibGV9IG9wdGlvbnMuZmlsZSBUaGUgaW1hZ2UgZmlsZSB0aGF0IHNob3VsZCBnZXQgdXBsb2FkZWQuIFRoaXMgc2hvdWxkIGVpdGhlciBiZSB0aGUgcGF0aCB0byBhblxuICBpbWFnZSBmaWxlLCBvciBhIFtSZWFkYWJsZVN0cmVhbV0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fY2xhc3Nfc3RyZWFtX3JlYWRhYmxlKSBmb3IgZW52aXJvbm1lbnRzIChlLmcuXG4gIGJyb3dzZXJzKSB3aGVyZSB0aGUgZmlsZXN5c3RlbSBpcyB1bmF2YWlsYWJsZS5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW1hZ2VUeXBlPSdwbmcnXSBEZXRlcm1pbmVzIGhvdyB0aGUgdXBsb2FkZWQgaW1hZ2Ugc2hvdWxkIGJlIHN0b3JlZC4gT25lIG9mIGBwbmcsIGpwZ2BcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnVwbG9hZEhlYWRlckltYWdlKHtuYW1lOiAndGhlIGNvb2tpZSBtb25zdGVyJywgZmlsZTogJy4vY29va2llX21vbnN0ZXIucG5nJ30pXG4gICovXG5cblxuICB1cGxvYWRIZWFkZXJJbWFnZShfcmVmMTEpIHtcbiAgICB2YXIgZmlsZSA9IF9yZWYxMS5maWxlLFxuICAgICAgICBfcmVmMTEkaW1hZ2VfdHlwZSA9IF9yZWYxMS5pbWFnZV90eXBlLFxuICAgICAgICBpbWFnZV90eXBlID0gX3JlZjExJGltYWdlX3R5cGUgPT09IHZvaWQgMCA/ICdwbmcnIDogX3JlZjExJGltYWdlX3R5cGUsXG4gICAgICAgIF9yZWYxMSRpbWFnZVR5cGUgPSBfcmVmMTEuaW1hZ2VUeXBlLFxuICAgICAgICBpbWFnZVR5cGUgPSBfcmVmMTEkaW1hZ2VUeXBlID09PSB2b2lkIDAgPyBpbWFnZV90eXBlIDogX3JlZjExJGltYWdlVHlwZTtcbiAgICByZXR1cm4gdGhpcy5fdXBsb2FkU3JJbWcoe1xuICAgICAgZmlsZSxcbiAgICAgIGltYWdlVHlwZSxcbiAgICAgIHVwbG9hZFR5cGU6ICdoZWFkZXInXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgVXBsb2FkcyBhbiBpbWFnZSB0byB1c2UgYXMgdGhpcyBzdWJyZWRkaXQncyBtb2JpbGUgaWNvbi5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfHN0cmVhbS5SZWFkYWJsZX0gb3B0aW9ucy5maWxlIFRoZSBpbWFnZSBmaWxlIHRoYXQgc2hvdWxkIGdldCB1cGxvYWRlZC4gVGhpcyBzaG91bGQgZWl0aGVyIGJlIHRoZSBwYXRoIHRvIGFuXG4gIGltYWdlIGZpbGUsIG9yIGEgW1JlYWRhYmxlU3RyZWFtXShodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9jbGFzc19zdHJlYW1fcmVhZGFibGUpIGZvciBlbnZpcm9ubWVudHMgKGUuZy5cbiAgYnJvd3NlcnMpIHdoZXJlIHRoZSBmaWxlc3lzdGVtIGlzIHVuYXZhaWxhYmxlLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbWFnZVR5cGU9J3BuZyddIERldGVybWluZXMgaG93IHRoZSB1cGxvYWRlZCBpbWFnZSBzaG91bGQgYmUgc3RvcmVkLiBPbmUgb2YgYHBuZywganBnYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykudXBsb2FkSWNvbih7bmFtZTogJ3RoZSBjb29raWUgbW9uc3RlcicsIGZpbGU6ICcuL2Nvb2tpZV9tb25zdGVyLnBuZyd9KVxuICAqL1xuXG5cbiAgdXBsb2FkSWNvbihfcmVmMTIpIHtcbiAgICB2YXIgZmlsZSA9IF9yZWYxMi5maWxlLFxuICAgICAgICBfcmVmMTIkaW1hZ2VfdHlwZSA9IF9yZWYxMi5pbWFnZV90eXBlLFxuICAgICAgICBpbWFnZV90eXBlID0gX3JlZjEyJGltYWdlX3R5cGUgPT09IHZvaWQgMCA/ICdwbmcnIDogX3JlZjEyJGltYWdlX3R5cGUsXG4gICAgICAgIF9yZWYxMiRpbWFnZVR5cGUgPSBfcmVmMTIuaW1hZ2VUeXBlLFxuICAgICAgICBpbWFnZVR5cGUgPSBfcmVmMTIkaW1hZ2VUeXBlID09PSB2b2lkIDAgPyBpbWFnZV90eXBlIDogX3JlZjEyJGltYWdlVHlwZTtcbiAgICByZXR1cm4gdGhpcy5fdXBsb2FkU3JJbWcoe1xuICAgICAgZmlsZSxcbiAgICAgIGltYWdlVHlwZSxcbiAgICAgIHVwbG9hZFR5cGU6ICdpY29uJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVwbG9hZHMgYW4gaW1hZ2UgdG8gdXNlIGFzIHRoaXMgc3VicmVkZGl0J3MgbW9iaWxlIGJhbm5lci5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfHN0cmVhbS5SZWFkYWJsZX0gb3B0aW9ucy5maWxlIFRoZSBpbWFnZSBmaWxlIHRoYXQgc2hvdWxkIGdldCB1cGxvYWRlZC4gVGhpcyBzaG91bGQgZWl0aGVyIGJlIHRoZSBwYXRoIHRvIGFuXG4gIGltYWdlIGZpbGUsIG9yIGEgW1JlYWRhYmxlU3RyZWFtXShodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9jbGFzc19zdHJlYW1fcmVhZGFibGUpIGZvciBlbnZpcm9ubWVudHMgKGUuZy5cbiAgYnJvd3NlcnMpIHdoZXJlIHRoZSBmaWxlc3lzdGVtIGlzIHVuYXZhaWxhYmxlLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbWFnZVR5cGU9J3BuZyddIERldGVybWluZXMgaG93IHRoZSB1cGxvYWRlZCBpbWFnZSBzaG91bGQgYmUgc3RvcmVkLiBPbmUgb2YgYHBuZywganBnYFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykudXBsb2FkQmFubmVySW1hZ2Uoe25hbWU6ICd0aGUgY29va2llIG1vbnN0ZXInLCBmaWxlOiAnLi9jb29raWVfbW9uc3Rlci5wbmcnfSlcbiAgKi9cblxuXG4gIHVwbG9hZEJhbm5lckltYWdlKF9yZWYxMykge1xuICAgIHZhciBmaWxlID0gX3JlZjEzLmZpbGUsXG4gICAgICAgIF9yZWYxMyRpbWFnZV90eXBlID0gX3JlZjEzLmltYWdlX3R5cGUsXG4gICAgICAgIGltYWdlX3R5cGUgPSBfcmVmMTMkaW1hZ2VfdHlwZSA9PT0gdm9pZCAwID8gJ3BuZycgOiBfcmVmMTMkaW1hZ2VfdHlwZSxcbiAgICAgICAgX3JlZjEzJGltYWdlVHlwZSA9IF9yZWYxMy5pbWFnZVR5cGUsXG4gICAgICAgIGltYWdlVHlwZSA9IF9yZWYxMyRpbWFnZVR5cGUgPT09IHZvaWQgMCA/IGltYWdlX3R5cGUgOiBfcmVmMTMkaW1hZ2VUeXBlO1xuICAgIHJldHVybiB0aGlzLl91cGxvYWRTckltZyh7XG4gICAgICBmaWxlLFxuICAgICAgaW1hZ2VUeXBlLFxuICAgICAgdXBsb2FkX3R5cGU6ICdiYW5uZXInXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBpbmZvcm1hdGlvbiBvbiB0aGlzIHN1YnJlZGRpdCdzIHJ1bGVzLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIGluZm9ybWF0aW9uIG9uIHRoaXMgc3VicmVkZGl0J3MgcnVsZXMuXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFJ1bGVzKCkudGhlbihjb25zb2xlLmxvZylcbiAgKlxuICAqIC8vID0+IHtcbiAgKiAgIHJ1bGVzOiBbXG4gICogICAgIHtcbiAgKiAgICAgICBraW5kOiAnYWxsJyxcbiAgKiAgICAgICBzaG9ydF9uYW1lOiAnUnVsZSAxOiBObyB2aW9sYXRpbmcgcnVsZSAxJyxcbiAgKiAgICAgICBkZXNjcmlwdGlvbjogJ0JyZWFraW5nIHRoaXMgcnVsZSBpcyBub3QgYWxsb3dlZC4nLFxuICAqICAgICAgIC4uLlxuICAqICAgICB9LFxuICAqICAgICAuLi5cbiAgKiAgIF0sXG4gICogICBzaXRlX3J1bGVzOiBbXG4gICogICAgICdTcGFtJyxcbiAgKiAgICAgJ1BlcnNvbmFsIGFuZCBjb25maWRlbnRpYWwgaW5mb3JtYXRpb24nJyxcbiAgKiAgICAgJ1RocmVhdGVuaW5nLCBoYXJhc3NpbmcsIG9yIGluY2l0aW5nIHZpb2xlbmNlJ1xuICAqICAgXVxuICAqIH1cbiAgKi9cblxuXG4gIGdldFJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hYm91dC9ydWxlc1wiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhlIHN0aWNraWVkIHBvc3Qgb24gdGhpcyBzdWJyZWRkaXQsIG9yIHRocm93cyBhIDQwNCBlcnJvciBpZiBub25lIGV4aXN0cy5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm51bT0xXSBUaGUgbnVtYmVyIG9mIHRoZSBzdGlja3kgdG8gZ2V0LiBTaG91bGQgYmUgZWl0aGVyIGAxYCAoZmlyc3Qgc3RpY2t5KSBvciBgMmAgKHNlY29uZCBzdGlja3kpLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFN1Ym1pc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIHN1YnJlZGRpdCdzIHN0aWNraWVkIHN1Ym1pc3Npb25cbiAgKiBAZXhhbXBsZVxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFN0aWNreSh7bnVtOiAyfSlcbiAgKiAvLyA9PiBTdWJtaXNzaW9uIHsgLi4uIH1cbiAgKi9cblxuXG4gIGdldFN0aWNreSgpIHtcbiAgICB2YXIgX3JlZjE0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZjE0JG51bSA9IF9yZWYxNC5udW0sXG4gICAgICAgIG51bSA9IF9yZWYxNCRudW0gPT09IHZvaWQgMCA/IDEgOiBfcmVmMTQkbnVtO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2Fib3V0L3N0aWNreVwiKSxcbiAgICAgIHFzOiB7XG4gICAgICAgIG51bVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2ZyaWVuZChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuZGlzcGxheV9uYW1lLCBcIi9hcGkvZnJpZW5kXCIpLFxuICAgICAgZm9ybTogX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBhcGlfdHlwZVxuICAgICAgfSlcbiAgICB9KS50aGVuKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSk7XG4gIH1cblxuICBfdW5mcmllbmQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvYXBpL3VuZnJpZW5kXCIpLFxuICAgICAgZm9ybTogX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBhcGlfdHlwZVxuICAgICAgfSlcbiAgICB9KS50aGVuKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgSW52aXRlcyB0aGUgZ2l2ZW4gdXNlciB0byBiZSBhIG1vZGVyYXRvciBvZiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIHVzZXJuYW1lIG9mIHRoZSBhY2NvdW50IHRoYXQgc2hvdWxkIGJlIGludml0ZWRcbiAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wZXJtaXNzaW9uc10gVGhlIG1vZGVyYXRvciBwZXJtaXNzaW9ucyB0aGF0IHRoaXMgdXNlciBzaG91bGQgaGF2ZS4gVGhpcyBzaG91bGQgYmUgYW4gYXJyYXlcbiAgY29udGFpbmluZyBzb21lIGNvbWJpbmF0aW9uIG9mIGBcIndpa2lcIiwgXCJwb3N0c1wiLCBcImFjY2Vzc1wiLCBcIm1haWxcIiwgXCJjb25maWdcIiwgXCJmbGFpclwiYC4gVG8gYWRkIGEgbW9kZXJhdG9yIHdpdGggZnVsbFxuICBwZXJtaXNzaW9ucywgb21pdCB0aGlzIHByb3BlcnR5IGVudGlyZWx5LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5pbnZpdGVNb2RlcmF0b3Ioe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsIHBlcm1pc3Npb25zOiBbJ3Bvc3RzJywgJ3dpa2knXX0pXG4gICovXG5cblxuICBpbnZpdGVNb2RlcmF0b3IoX3JlZjE1KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMTUubmFtZSxcbiAgICAgICAgcGVybWlzc2lvbnMgPSBfcmVmMTUucGVybWlzc2lvbnM7XG4gICAgcmV0dXJuIHRoaXMuX2ZyaWVuZCh7XG4gICAgICBuYW1lLFxuICAgICAgcGVybWlzc2lvbnM6ICgwLCBfaGVscGVycy5mb3JtYXRNb2RQZXJtaXNzaW9ucykocGVybWlzc2lvbnMpLFxuICAgICAgdHlwZTogJ21vZGVyYXRvcl9pbnZpdGUnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgUmV2b2tlcyBhbiBpbnZpdGF0aW9uIGZvciB0aGUgZ2l2ZW4gdXNlciB0byBiZSBhIG1vZGVyYXRvci5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIHVzZXJuYW1lIG9mIHRoZSBhY2NvdW50IHdob3NlIGludml0YXRpb24gc2hvdWxkIGJlIHJldm9rZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykucmV2b2tlTW9kZXJhdG9ySW52aXRlKHtuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnfSlcbiAgKi9cblxuXG4gIHJldm9rZU1vZGVyYXRvckludml0ZShfcmVmMTYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYxNi5uYW1lO1xuICAgIHJldHVybiB0aGlzLl91bmZyaWVuZCh7XG4gICAgICBuYW1lLFxuICAgICAgdHlwZTogJ21vZGVyYXRvcl9pbnZpdGUnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgUmVtb3ZlcyB0aGUgZ2l2ZW4gdXNlcidzIG1vZGVyYXRvciBzdGF0dXMgb24gdGhpcyBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uYW1lIFRoZSB1c2VybmFtZSBvZiB0aGUgYWNjb3VudCB3aG9zZSBtb2RlcmF0b3Igc3RhdHVzIHNob3VsZCBiZSByZW1vdmVkXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnJlbW92ZU1vZGVyYXRvcih7bmFtZTogJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJ30pXG4gICovXG5cblxuICByZW1vdmVNb2RlcmF0b3IoX3JlZjE3KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMTcubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fdW5mcmllbmQoe1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGU6ICdtb2RlcmF0b3InXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgTWFrZXMgdGhlIGdpdmVuIHVzZXIgYW4gYXBwcm92ZWQgc3VibWl0dGVyIG9mIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgdXNlcm5hbWUgb2YgdGhlIGFjY291bnQgdGhhdCBzaG91bGQgYmUgZ2l2ZW4gdGhpcyBzdGF0dXNcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuYWRkQ29udHJpYnV0b3Ioe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyayd9KVxuICAqL1xuXG5cbiAgYWRkQ29udHJpYnV0b3IoX3JlZjE4KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMTgubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fZnJpZW5kKHtcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlOiAnY29udHJpYnV0b3InXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgUmV2b2tlcyB0aGlzIHVzZXIncyBhcHByb3ZlZCBzdWJtaXR0ZXIgc3RhdHVzIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgdXNlcm5hbWUgb2YgdGhlIGFjY291bnQgd2hvc2Ugc3RhdHVzIHNob3VsZCBiZSByZXZva2VkXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnJlbW92ZUNvbnRyaWJ1dG9yKHtuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnfSlcbiAgKi9cblxuXG4gIHJlbW92ZUNvbnRyaWJ1dG9yKF9yZWYxOSkge1xuICAgIHZhciBuYW1lID0gX3JlZjE5Lm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3VuZnJpZW5kKHtcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlOiAnY29udHJpYnV0b3InXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgQmFucyB0aGUgZ2l2ZW4gdXNlciBmcm9tIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgdXNlcm5hbWUgb2YgdGhlIGFjY291bnQgdGhhdCBzaG91bGQgYmUgYmFubmVkXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJhbk1lc3NhZ2VdIFRoZSBiYW4gbWVzc2FnZS4gVGhpcyB3aWxsIGdldCBzZW50IHRvIHRoZSB1c2VyIGluIGEgcHJpdmF0ZSBtZXNzYWdlLCBhbGVydGluZyB0aGVtXG4gIHRoYXQgdGhleSBoYXZlIGJlZW4gYmFubmVkLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5iYW5SZWFzb25dIEEgc3RyaW5nIGluZGljYXRpbmcgd2hpY2ggcnVsZSB0aGUgYmFubmVkIHVzZXIgYnJva2UgKDEwMCBjaGFyYWN0ZXJzIG1heClcbiAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYmFuLCBpbiBkYXlzLiBGb3IgYSBwZXJtYW5lbnQgYmFuLCBvbWl0IHRoaXMgcGFyYW1ldGVyLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5iYW5Ob3RlXSBBIG5vdGUgdGhhdCBhcHBlYXJzIG9uIHRoZSBtb2RlcmF0aW9uIGxvZywgdXN1YWxseSB1c2VkIHRvIGluZGljYXRlIHRoZSByZWFzb24gZm9yIHRoZVxuICBiYW4uIFRoaXMgaXMgbm90IHZpc2libGUgdG8gdGhlIGJhbm5lZCB1c2VyLiAoMzAwIGNoYXJhY3RlcnMgbWF4KVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5iYW5Vc2VyKHtuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnLCBiYW5NZXNzYWdlOiAnWW91IGFyZSBub3cgYmFubmVkIExPTCd9KVxuICAqL1xuXG5cbiAgYmFuVXNlcihfcmVmMjApIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyMC5uYW1lLFxuICAgICAgICBiYW5fbWVzc2FnZSA9IF9yZWYyMC5iYW5fbWVzc2FnZSxcbiAgICAgICAgX3JlZjIwJGJhbk1lc3NhZ2UgPSBfcmVmMjAuYmFuTWVzc2FnZSxcbiAgICAgICAgYmFuTWVzc2FnZSA9IF9yZWYyMCRiYW5NZXNzYWdlID09PSB2b2lkIDAgPyBiYW5fbWVzc2FnZSA6IF9yZWYyMCRiYW5NZXNzYWdlLFxuICAgICAgICBiYW5fcmVhc29uID0gX3JlZjIwLmJhbl9yZWFzb24sXG4gICAgICAgIF9yZWYyMCRiYW5SZWFzb24gPSBfcmVmMjAuYmFuUmVhc29uLFxuICAgICAgICBiYW5SZWFzb24gPSBfcmVmMjAkYmFuUmVhc29uID09PSB2b2lkIDAgPyBiYW5fcmVhc29uIDogX3JlZjIwJGJhblJlYXNvbixcbiAgICAgICAgZHVyYXRpb24gPSBfcmVmMjAuZHVyYXRpb24sXG4gICAgICAgIGJhbl9ub3RlID0gX3JlZjIwLmJhbl9ub3RlLFxuICAgICAgICBfcmVmMjAkYmFuTm90ZSA9IF9yZWYyMC5iYW5Ob3RlLFxuICAgICAgICBiYW5Ob3RlID0gX3JlZjIwJGJhbk5vdGUgPT09IHZvaWQgMCA/IGJhbl9ub3RlIDogX3JlZjIwJGJhbk5vdGU7XG4gICAgcmV0dXJuIHRoaXMuX2ZyaWVuZCh7XG4gICAgICBuYW1lLFxuICAgICAgYmFuX21lc3NhZ2U6IGJhbk1lc3NhZ2UsXG4gICAgICBiYW5fcmVhc29uOiBiYW5SZWFzb24sXG4gICAgICBkdXJhdGlvbixcbiAgICAgIG5vdGU6IGJhbk5vdGUsXG4gICAgICB0eXBlOiAnYmFubmVkJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVuYmFucyB0aGUgZ2l2ZW4gdXNlciBmcm9tIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgdXNlcm5hbWUgb2YgdGhlIGFjY291bnQgdGhhdCBzaG91bGQgYmUgdW5iYW5uZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnVuYmFuVXNlcih7bmFtZTogJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJ30pXG4gICovXG5cblxuICB1bmJhblVzZXIoX3JlZjIxKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjEubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fdW5mcmllbmQoe1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGU6ICdiYW5uZWQnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgTXV0ZXMgdGhlIGdpdmVuIHVzZXIgZnJvbSBtZXNzYWdpbmcgdGhpcyBzdWJyZWRkaXQgZm9yIDcyIGhvdXJzLlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgdXNlcm5hbWUgb2YgdGhlIGFjY291bnQgdGhhdCBzaG91bGQgYmUgbXV0ZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykubXV0ZVVzZXIoe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyayd9KVxuICAqL1xuXG5cbiAgbXV0ZVVzZXIoX3JlZjIyKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjIubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fZnJpZW5kKHtcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlOiAnbXV0ZWQnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgVW5tdXRlcyB0aGUgZ2l2ZW4gdXNlciBmcm9tIG1lc3NhZ2luZyB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIHVzZXJuYW1lIG9mIHRoZSBhY2NvdW50IHRoYXQgc2hvdWxkIGJlIG11dGVkXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnVubXV0ZVVzZXIoe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyayd9KVxuICAqL1xuXG5cbiAgdW5tdXRlVXNlcihfcmVmMjMpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyMy5uYW1lO1xuICAgIHJldHVybiB0aGlzLl91bmZyaWVuZCh7XG4gICAgICBuYW1lLFxuICAgICAgdHlwZTogJ211dGVkJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEJhbnMgdGhlIGdpdmVuIHVzZXIgZnJvbSBlZGl0aW5nIHRoaXMgc3VicmVkZGl0J3Mgd2lraS5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIHVzZXJuYW1lIG9mIHRoZSBhY2NvdW50IHRoYXQgc2hvdWxkIGJlIHdpa2liYW5uZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykud2lraWJhblVzZXIoe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyayd9KVxuICAqL1xuXG5cbiAgd2lraWJhblVzZXIoX3JlZjI0KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjQubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fZnJpZW5kKHtcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlOiAnd2lraWJhbm5lZCdcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBVbmJhbnMgdGhlIGdpdmVuIHVzZXIgZnJvbSBlZGl0aW5nIHRoaXMgc3VicmVkZGl0J3Mgd2lraS5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIHVzZXJuYW1lIG9mIHRoZSBhY2NvdW50IHRoYXQgc2hvdWxkIGJlIHVud2lraWJhbm5lZFxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS51bndpa2liYW5Vc2VyKHtuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnfSlcbiAgKi9cblxuXG4gIHVud2lraWJhblVzZXIoX3JlZjI1KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjUubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fdW5mcmllbmQoe1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGU6ICd3aWtpYmFubmVkJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEFkZHMgdGhlIGdpdmVuIHVzZXIgdG8gdGhpcyBzdWJyZWRkaXQncyBsaXN0IG9mIGFwcHJvdmVkIHdpa2kgZWRpdG9ycy5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIHVzZXJuYW1lIG9mIHRoZSBhY2NvdW50IHRoYXQgc2hvdWxkIGJlIGdpdmVuIGFwcHJvdmVkIGVkaXRvciBzdGF0dXNcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFN1YnJlZGRpdCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuYWRkV2lraUNvbnRyaWJ1dG9yKHtuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnfSlcbiAgKi9cblxuXG4gIGFkZFdpa2lDb250cmlidXRvcihfcmVmMjYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyNi5uYW1lO1xuICAgIHJldHVybiB0aGlzLl9mcmllbmQoe1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGU6ICd3aWtpY29udHJpYnV0b3InXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgUmVtb3ZlcyB0aGUgZ2l2ZW4gdXNlciBmcm9tIHRoaXMgc3VicmVkZGl0J3MgbGlzdCBvZiBhcHByb3ZlZCB3aWtpIGVkaXRvcnMuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uYW1lIFRoZSB1c2VybmFtZSBvZiB0aGUgYWNjb3VudCB3aG9zZSBhcHByb3ZlZCBlZGl0b3Igc3RhdHVzIHNob3VsZCBiZSByZXZva2VkXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBTdWJyZWRkaXQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLnJlbW92ZVdpa2lDb250cmlidXRvcih7bmFtZTogJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJ30pXG4gICovXG5cblxuICByZW1vdmVXaWtpQ29udHJpYnV0b3IoX3JlZjI3KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjcubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fdW5mcmllbmQoe1xuICAgICAgbmFtZSxcbiAgICAgIHR5cGU6ICd3aWtpY29udHJpYnV0b3InXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgU2V0cyB0aGUgcGVybWlzc2lvbnMgZm9yIGEgZ2l2ZW4gbW9kZXJhdG9yIG9uIHRoaXMgc3VicmVkZGl0LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgdXNlcm5hbWUgb2YgdGhlIG1vZGVyYXRvciB3aG9zZSBwZXJtaXNzaW9ucyBhcmUgYmVpbmcgY2hhbmdlZFxuICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBlcm1pc3Npb25zXSBUaGUgbmV3IG1vZGVyYXRvciBwZXJtaXNzaW9ucyB0aGF0IHRoaXMgdXNlciBzaG91bGQgaGF2ZS4gVGhpcyBzaG91bGQgYmUgYW4gYXJyYXlcbiAgY29udGFpbmluZyBzb21lIGNvbWJpbmF0aW9uIG9mIGBcIndpa2lcIiwgXCJwb3N0c1wiLCBcImFjY2Vzc1wiLCBcIm1haWxcIiwgXCJjb25maWdcIiwgXCJmbGFpclwiYC4gVG8gYWRkIGEgbW9kZXJhdG9yIHdpdGggZnVsbFxuICBwZXJtaXNzaW9ucywgb21pdCB0aGlzIHByb3BlcnR5IGVudGlyZWx5LlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgU3VicmVkZGl0IHdoZW4gdGhpcyByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuc2V0TW9kZXJhdG9yUGVybWlzc2lvbnMoe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyaycsIHBlcm1pc3Npb25zOiBbJ21haWwnXX0pXG4gICovXG5cblxuICBzZXRNb2RlcmF0b3JQZXJtaXNzaW9ucyhfcmVmMjgpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyOC5uYW1lLFxuICAgICAgICBwZXJtaXNzaW9ucyA9IF9yZWYyOC5wZXJtaXNzaW9ucztcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL2FwaS9zZXRwZXJtaXNzaW9uc1wiKSxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHBlcm1pc3Npb25zOiAoMCwgX2hlbHBlcnMuZm9ybWF0TW9kUGVybWlzc2lvbnMpKHBlcm1pc3Npb25zKSxcbiAgICAgICAgdHlwZTogJ21vZGVyYXRvcidcbiAgICAgIH1cbiAgICB9KS50aGVuKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGdpdmVuIHdpa2kgcGFnZSBvbiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgVGhlIHRpdGxlIG9mIHRoZSBkZXNpcmVkIHdpa2kgcGFnZS5cbiAgKiBAcmV0dXJucyB7V2lraVBhZ2V9IEFuIHVuZmV0Y2hlZCBXaWtpUGFnZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZGVzaXJlZCB3aWtpIHBhZ2VcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0V2lraVBhZ2UoJ2luZGV4JylcbiAgKiAvLyA9PiBXaWtpUGFnZSB7IHRpdGxlOiAnaW5kZXgnLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3Nub293cmFwJyB9IH1cbiAgKi9cblxuXG4gIGdldFdpa2lQYWdlKHRpdGxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3IuX25ld09iamVjdCgnV2lraVBhZ2UnLCB7XG4gICAgICBzdWJyZWRkaXQ6IHRoaXMsXG4gICAgICB0aXRsZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgdGhlIGxpc3Qgb2Ygd2lraSBwYWdlcyBvbiB0aGlzIHN1YnJlZGRpdC5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQW4gQXJyYXkgY29udGFpbmluZyBXaWtpUGFnZSBvYmplY3RzXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFdpa2lQYWdlcygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gW1xuICAqIC8vICAgV2lraVBhZ2UgeyB0aXRsZTogJ2luZGV4Jywgc3VicmVkZGl0OiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdzbm9vd3JhcCd9IH1cbiAgKiAvLyAgIFdpa2lQYWdlIHsgdGl0bGU6ICdjb25maWcvc2lkZWJhcicsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAnc25vb3dyYXAnfSB9XG4gICogLy8gICBXaWtpUGFnZSB7IHRpdGxlOiAnc2VjcmV0X3RoaW5ncycsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAnc25vb3dyYXAnfSB9XG4gICogLy8gICBXaWtpUGFnZSB7IHRpdGxlOiAnY29uZmlnL3N1Ym1pdF90ZXh0Jywgc3VicmVkZGl0OiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdzbm9vd3JhcCd9IH1cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRXaWtpUGFnZXMoKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLmRpc3BsYXlfbmFtZSwgXCIvd2lraS9wYWdlc1wiKVxuICAgIH0pLm1hcChmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgIHJldHVybiBfdGhpczkuZ2V0V2lraVBhZ2UodGl0bGUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEdldHMgYSBsaXN0IG9mIHJldmlzaW9ucyBvbiB0aGlzIHN1YnJlZGRpdCdzIHdpa2kuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgd2lraSByZXZpc2lvbnNcbiAgKiBAZXhhbXBsZVxuICAqXG4gICogci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0V2lraVJldmlzaW9ucygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gTGlzdGluZyBbXG4gICogLy8gIHsgcGFnZTogJ2luZGV4JywgcmVhc29uOiAnYWRkZWQgY29va2llcycsIC4uLiB9LFxuICAqIC8vICAuLi5cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRXaWtpUmV2aXNpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5kaXNwbGF5X25hbWUsIFwiL3dpa2kvcmV2aXNpb25zXCIpLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG59O1xudmFyIF9kZWZhdWx0ID0gU3VicmVkZGl0O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/Subreddit.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/UserList.js":
/*!********************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/UserList.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nclass UserList {\n  constructor(options, _r) {\n    return options.children.map(function (user) {\n      return _r._newObject('RedditUser', user);\n    });\n  }\n\n}\n\nexports[\"default\"] = UserList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1VzZXJMaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL2Rpc3Qvb2JqZWN0cy9Vc2VyTGlzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuY2xhc3MgVXNlckxpc3Qge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBfcikge1xuICAgIHJldHVybiBvcHRpb25zLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIF9yLl9uZXdPYmplY3QoJ1JlZGRpdFVzZXInLCB1c2VyKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFVzZXJMaXN0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/UserList.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/VoteableContent.js":
/*!***************************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/VoteableContent.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ../Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _helpers = __webpack_require__(/*! ../helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _ReplyableContent = _interopRequireDefault(__webpack_require__(/*! ./ReplyableContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/ReplyableContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar api_type = 'json';\n/**\n* A set of mixin functions that apply to Submissions and Comments.\n* <style> #VoteableContent {display: none} </style>\n* @extends ReplyableContent\n*/\n\nvar VoteableContent = class VoteableContent extends _ReplyableContent.default {\n  /**\n  * @summary Casts a vote on this Comment or Submission.\n  * @private\n  * @param {number} direction The direction of the vote. (1 for an upvote, -1 for a downvote, 0 to remove a vote)\n  * @returns {Promise} A Promise that fulfills when the request is complete.\n  */\n  _vote(direction) {\n    return this._post({\n      uri: 'api/vote',\n      form: {\n        dir: direction,\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Upvotes this Comment or Submission.\n  * @returns {Promise} A Promise that fulfills with this Comment/Submission when the request is complete\n  * @desc **Note: votes must be cast by humans.** That is, API clients proxying a human's action one-for-one are OK,\n  but bots deciding how to vote on content or amplifying a human's vote are not. See the\n  [reddit rules](https://reddit.com/rules) for more details on what constitutes vote cheating. (This guideline is quoted from\n  [the official reddit API documentation page](https://www.reddit.com/dev/api#POST_api_vote).)\n  * @example r.getSubmission('4e62ml').upvote()\n  */\n\n\n  upvote() {\n    return this._vote(1);\n  }\n  /**\n  * @summary Downvotes this Comment or Submission.\n  * @returns {Promise} A Promise that fulfills with this Comment/Submission when the request is complete.\n  * @desc **Note: votes must be cast by humans.** That is, API clients proxying a human's action one-for-one are OK, but\n  bots deciding how to vote on content or amplifying a human's vote are not. See the [reddit rules](https://reddit.com/rules)\n  for more details on what constitutes vote cheating. (This guideline is quoted from\n  [the official reddit API documentation page](https://www.reddit.com/dev/api#POST_api_vote).)\n  * @example r.getSubmission('4e62ml').downvote()\n  */\n\n\n  downvote() {\n    return this._vote(-1);\n  }\n  /**\n  * @summary Removes any existing vote on this Comment or Submission.\n  * @returns {Promise} A Promise that fulfills with this Comment/Submission when the request is complete.\n  * @desc **Note: votes must be cast by humans.** That is, API clients proxying a human's action one-for-one are OK, but\n  bots deciding how to vote on content or amplifying a human's vote are not. See the [reddit rules](https://reddit.com/rules)\n  for more details on what constitutes vote cheating. (This guideline is quoted from\n  [the official reddit API documentation page](https://www.reddit.com/dev/api#POST_api_vote).)\n  * @example r.getSubmission('4e62ml').unvote()\n  */\n\n\n  unvote() {\n    return this._vote(0);\n  }\n  /**\n  * @summary Saves this Comment or Submission (i.e. adds it to the list at reddit.com/saved)\n  * @returns {Promise} A Promise that fulfills when the request is complete\n  * @example r.getSubmission('4e62ml').save()\n  */\n\n\n  save() {\n    return this._post({\n      uri: 'api/save',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Unsaves this item\n  * @returns {Promise} A Promise that fulfills when the request is complete\n  * @example r.getSubmission('4e62ml').unsave()\n  */\n\n\n  unsave() {\n    return this._post({\n      uri: 'api/unsave',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Distinguishes this Comment or Submission with a sigil.\n  * @desc **Note:** This function will only work if the requester is the author of this Comment/Submission.\n  * @param {object} options\n  * @param {boolean|string} [options.status=true] Determines how the item should be distinguished.\n  `true` (default) signifies that the item should be moderator-distinguished, and\n  `false` signifies that the item should not be distinguished. Passing a string (e.g.\n  `admin`) will cause the item to get distinguished with that string, if possible.\n  * @param {boolean} [options.sticky=false] Determines whether this item should be stickied in addition to being\n  distinguished. (This only applies to comments; to sticky a submission, use {@link Submission#sticky} instead.)\n  * @returns {Promise} A Promise that fulfills when the request is complete.\n  * @example r.getComment('d1xclfo').distinguish({status: true, sticky: true})\n  */\n\n\n  distinguish() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$status = _ref.status,\n        status = _ref$status === void 0 ? true : _ref$status,\n        _ref$sticky = _ref.sticky,\n        sticky = _ref$sticky === void 0 ? false : _ref$sticky;\n\n    return this._post({\n      uri: 'api/distinguish',\n      form: {\n        api_type,\n        how: status === true ? 'yes' : status === false ? 'no' : status,\n        sticky,\n        id: this.name\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Undistinguishes this Comment or Submission. Alias for distinguish({status: false})\n  * @returns {Promise} A Promise that fulfills when the request is complete.\n  * @example r.getSubmission('4e62ml').undistinguish()\n  */\n\n\n  undistinguish() {\n    return this.distinguish({\n      status: false,\n      sticky: false\n    }).return(this);\n  }\n  /**\n  * @summary Edits this Comment or Submission.\n  * @param {string} updatedText The updated markdown text to use\n  * @returns {Promise} A Promise that fulfills when this request is complete.\n  * @example r.getComment('coip909').edit('Blah blah blah this is new updated text')\n  */\n\n\n  edit(updatedText) {\n    return this._post({\n      uri: 'api/editusertext',\n      form: {\n        api_type,\n        text: updatedText,\n        thing_id: this.name\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this));\n  }\n  /**\n  * @summary Gives reddit gold to the author of this Comment or Submission.\n  * @returns {Promise} A Promise that fullfills with this Comment/Submission when this request is complete\n  * @example r.getComment('coip909').gild()\n  */\n\n\n  gild() {\n    return this._post({\n      uri: \"api/v1/gold/gild/\".concat(this.name)\n    }).return(this);\n  }\n\n  _setInboxRepliesEnabled(state) {\n    return this._post({\n      uri: 'api/sendreplies',\n      form: {\n        state,\n        id: this.name\n      }\n    });\n  }\n  /**\n  * @summary Enables inbox replies on this Comment or Submission\n  * @returns {Promise} A Promise that fulfills with this content when the request is complete\n  * @example r.getComment('coip909').enableInboxReplies()\n  */\n\n\n  enableInboxReplies() {\n    return this._setInboxRepliesEnabled(true).return(this);\n  }\n  /**\n  * @summary Disables inbox replies on this Comment or Submission\n  * @returns {Promise} A Promise that fulfills with this content when the request is complete\n  * @example r.getComment('coip909').disableInboxReplies()\n  */\n\n\n  disableInboxReplies() {\n    return this._setInboxRepliesEnabled(false).return(this);\n  }\n\n  _mutateAndExpandReplies(_ref2) {\n    var _this = this;\n\n    var limit = _ref2.limit,\n        depth = _ref2.depth;\n\n    if (depth <= 0) {\n      return _Promise.default.resolve(this);\n    }\n\n    var repliesKey = this.constructor._name === 'Submission' ? 'comments' : 'replies';\n    return this[repliesKey].fetchMore({\n      amount: limit - this[repliesKey].length\n    }).tap(function (replies) {\n      _this[repliesKey] = replies;\n    }).then(function (replies) {\n      return replies.slice(0, limit);\n    }).map(function (reply) {\n      return reply._mutateAndExpandReplies({\n        limit,\n        depth: depth - 1\n      });\n    }).return(this);\n  }\n  /**\n  * @summary Expands the reply Listings on this Comment/Submission.\n  * @desc This is useful in cases where one wants to enumerate all comments on a\n  thread, even the ones that are initially hidden when viewing it (e.g. long comment chains).\n  *\n  * This function accepts two optional parameters `options.limit` and `options.depth`. `options.limit` sets an upper bound\n  for the branching factor of the resulting replies tree, i.e. the number of comments that are fetched in reply to any given\n  item. `options.depth` sets an upper bound for the depth of the resulting replies tree (where a depth of 0 signifies that no\n  replies should be fetched at all).\n  *\n  * Note that regardless of the `limit` and `depth` parameters used, any reply that appeared in the original reply tree will\n  appear in the expanded reply tree. In certain cases, the depth of the resulting tree may also be larger than `options.depth`,\n  if the reddit API returns more of a comment tree than needed.\n  *\n  * These parameters should primarily be used to keep the request count low; if a precise limit and depth are needed, it is\n  recommended to manually verify the comments in the tree afterwards.\n  *\n  * Both parameters default to `Infinity` if omitted, i.e. the resulting tree contains every single comment available. It should\n  be noted that depending on the size and depth of the thread, fetching every single comment can use up a significant number\n  of ratelimited requests. (To give an intuitive estimate, consider how many clicks would be needed to view all the\n  comments on the thread using the HTML site.)\n  * @param {object} [options={}]\n  * @param {number} [options.limit=Infinity] An upper-bound for the branching factor of the resulting tree of replies\n  * @param {number} [options.depth=Infinity] An upper-bound for the depth of the resulting tree of replies\n  * @returns {Promise} A Promise that fulfills with a new version of this object that has an expanded reply tree. The original\n  object is not modified\n  * @example r.getSubmission('4fuq26').expandReplies().then(console.log)\n  * // => (a very large comment tree containing every viewable comment on this thread)\n  */\n\n\n  expandReplies() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$limit = _ref3.limit,\n        limit = _ref3$limit === void 0 ? Infinity : _ref3$limit,\n        _ref3$depth = _ref3.depth,\n        depth = _ref3$depth === void 0 ? Infinity : _ref3$depth;\n\n    return this._r._promiseWrap(this.fetch().then(function (result) {\n      return result._clone({\n        deep: true\n      })._mutateAndExpandReplies({\n        limit,\n        depth\n      });\n    }));\n  }\n\n}; // VoteableContent#delete is not in the class body since Safari 9 can't parse the `delete` function name in class bodies.\n\n/**\n* @function\n* @name delete\n* @summary Deletes this Comment or Submission\n* @returns {Promise} A Promise that fulfills with this Comment/Submission when this request is complete\n* @example r.getComment('coip909').delete()\n* @memberof VoteableContent\n* @instance\n*/\n\nObject.defineProperty(VoteableContent.prototype, 'delete', {\n  value() {\n    return this._post({\n      uri: 'api/del',\n      form: {\n        id: this.name\n      }\n    }).return(this);\n  },\n\n  configurable: true,\n  writable: true\n});\nvar _default = VoteableContent;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1ZvdGVhYmxlQ29udGVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTs7QUFFZixzQ0FBc0MsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFN0QsZUFBZSxtQkFBTyxDQUFDLG9FQUFlOztBQUV0QywrQ0FBK0MsbUJBQU8sQ0FBQyw2RkFBdUI7O0FBRTlFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixpREFBaUQsNkJBQTZCLHlCQUF5QjtBQUN2RyxjQUFjLFNBQVM7QUFDdkIsa0RBQWtELDJCQUEyQjtBQUM3RTs7O0FBR0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUYsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsV0FBVztBQUMvQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1ZvdGVhYmxlQ29udGVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9Qcm9taXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vUHJvbWlzZS5qc1wiKSk7XG5cbnZhciBfaGVscGVycyA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzLmpzXCIpO1xuXG52YXIgX1JlcGx5YWJsZUNvbnRlbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlcGx5YWJsZUNvbnRlbnQuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgYXBpX3R5cGUgPSAnanNvbic7XG4vKipcbiogQSBzZXQgb2YgbWl4aW4gZnVuY3Rpb25zIHRoYXQgYXBwbHkgdG8gU3VibWlzc2lvbnMgYW5kIENvbW1lbnRzLlxuKiA8c3R5bGU+ICNWb3RlYWJsZUNvbnRlbnQge2Rpc3BsYXk6IG5vbmV9IDwvc3R5bGU+XG4qIEBleHRlbmRzIFJlcGx5YWJsZUNvbnRlbnRcbiovXG5cbnZhciBWb3RlYWJsZUNvbnRlbnQgPSBjbGFzcyBWb3RlYWJsZUNvbnRlbnQgZXh0ZW5kcyBfUmVwbHlhYmxlQ29udGVudC5kZWZhdWx0IHtcbiAgLyoqXG4gICogQHN1bW1hcnkgQ2FzdHMgYSB2b3RlIG9uIHRoaXMgQ29tbWVudCBvciBTdWJtaXNzaW9uLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIG9mIHRoZSB2b3RlLiAoMSBmb3IgYW4gdXB2b3RlLCAtMSBmb3IgYSBkb3dudm90ZSwgMCB0byByZW1vdmUgYSB2b3RlKVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAqL1xuICBfdm90ZShkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvdm90ZScsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGRpcjogZGlyZWN0aW9uLFxuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVwdm90ZXMgdGhpcyBDb21tZW50IG9yIFN1Ym1pc3Npb24uXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBDb21tZW50L1N1Ym1pc3Npb24gd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBkZXNjICoqTm90ZTogdm90ZXMgbXVzdCBiZSBjYXN0IGJ5IGh1bWFucy4qKiBUaGF0IGlzLCBBUEkgY2xpZW50cyBwcm94eWluZyBhIGh1bWFuJ3MgYWN0aW9uIG9uZS1mb3Itb25lIGFyZSBPSyxcbiAgYnV0IGJvdHMgZGVjaWRpbmcgaG93IHRvIHZvdGUgb24gY29udGVudCBvciBhbXBsaWZ5aW5nIGEgaHVtYW4ncyB2b3RlIGFyZSBub3QuIFNlZSB0aGVcbiAgW3JlZGRpdCBydWxlc10oaHR0cHM6Ly9yZWRkaXQuY29tL3J1bGVzKSBmb3IgbW9yZSBkZXRhaWxzIG9uIHdoYXQgY29uc3RpdHV0ZXMgdm90ZSBjaGVhdGluZy4gKFRoaXMgZ3VpZGVsaW5lIGlzIHF1b3RlZCBmcm9tXG4gIFt0aGUgb2ZmaWNpYWwgcmVkZGl0IEFQSSBkb2N1bWVudGF0aW9uIHBhZ2VdKGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vZGV2L2FwaSNQT1NUX2FwaV92b3RlKS4pXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCc0ZTYybWwnKS51cHZvdGUoKVxuICAqL1xuXG5cbiAgdXB2b3RlKCkge1xuICAgIHJldHVybiB0aGlzLl92b3RlKDEpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IERvd252b3RlcyB0aGlzIENvbW1lbnQgb3IgU3VibWlzc2lvbi5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIENvbW1lbnQvU3VibWlzc2lvbiB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAqIEBkZXNjICoqTm90ZTogdm90ZXMgbXVzdCBiZSBjYXN0IGJ5IGh1bWFucy4qKiBUaGF0IGlzLCBBUEkgY2xpZW50cyBwcm94eWluZyBhIGh1bWFuJ3MgYWN0aW9uIG9uZS1mb3Itb25lIGFyZSBPSywgYnV0XG4gIGJvdHMgZGVjaWRpbmcgaG93IHRvIHZvdGUgb24gY29udGVudCBvciBhbXBsaWZ5aW5nIGEgaHVtYW4ncyB2b3RlIGFyZSBub3QuIFNlZSB0aGUgW3JlZGRpdCBydWxlc10oaHR0cHM6Ly9yZWRkaXQuY29tL3J1bGVzKVxuICBmb3IgbW9yZSBkZXRhaWxzIG9uIHdoYXQgY29uc3RpdHV0ZXMgdm90ZSBjaGVhdGluZy4gKFRoaXMgZ3VpZGVsaW5lIGlzIHF1b3RlZCBmcm9tXG4gIFt0aGUgb2ZmaWNpYWwgcmVkZGl0IEFQSSBkb2N1bWVudGF0aW9uIHBhZ2VdKGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vZGV2L2FwaSNQT1NUX2FwaV92b3RlKS4pXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCc0ZTYybWwnKS5kb3dudm90ZSgpXG4gICovXG5cblxuICBkb3dudm90ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdm90ZSgtMSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgUmVtb3ZlcyBhbnkgZXhpc3Rpbmcgdm90ZSBvbiB0aGlzIENvbW1lbnQgb3IgU3VibWlzc2lvbi5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIENvbW1lbnQvU3VibWlzc2lvbiB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAqIEBkZXNjICoqTm90ZTogdm90ZXMgbXVzdCBiZSBjYXN0IGJ5IGh1bWFucy4qKiBUaGF0IGlzLCBBUEkgY2xpZW50cyBwcm94eWluZyBhIGh1bWFuJ3MgYWN0aW9uIG9uZS1mb3Itb25lIGFyZSBPSywgYnV0XG4gIGJvdHMgZGVjaWRpbmcgaG93IHRvIHZvdGUgb24gY29udGVudCBvciBhbXBsaWZ5aW5nIGEgaHVtYW4ncyB2b3RlIGFyZSBub3QuIFNlZSB0aGUgW3JlZGRpdCBydWxlc10oaHR0cHM6Ly9yZWRkaXQuY29tL3J1bGVzKVxuICBmb3IgbW9yZSBkZXRhaWxzIG9uIHdoYXQgY29uc3RpdHV0ZXMgdm90ZSBjaGVhdGluZy4gKFRoaXMgZ3VpZGVsaW5lIGlzIHF1b3RlZCBmcm9tXG4gIFt0aGUgb2ZmaWNpYWwgcmVkZGl0IEFQSSBkb2N1bWVudGF0aW9uIHBhZ2VdKGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vZGV2L2FwaSNQT1NUX2FwaV92b3RlKS4pXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCc0ZTYybWwnKS51bnZvdGUoKVxuICAqL1xuXG5cbiAgdW52b3RlKCkge1xuICAgIHJldHVybiB0aGlzLl92b3RlKDApO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFNhdmVzIHRoaXMgQ29tbWVudCBvciBTdWJtaXNzaW9uIChpLmUuIGFkZHMgaXQgdG8gdGhlIGxpc3QgYXQgcmVkZGl0LmNvbS9zYXZlZClcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VibWlzc2lvbignNGU2Mm1sJykuc2F2ZSgpXG4gICovXG5cblxuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9zYXZlJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgaWQ6IHRoaXMubmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBVbnNhdmVzIHRoaXMgaXRlbVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJtaXNzaW9uKCc0ZTYybWwnKS51bnNhdmUoKVxuICAqL1xuXG5cbiAgdW5zYXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS91bnNhdmUnLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IERpc3Rpbmd1aXNoZXMgdGhpcyBDb21tZW50IG9yIFN1Ym1pc3Npb24gd2l0aCBhIHNpZ2lsLlxuICAqIEBkZXNjICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIHdpbGwgb25seSB3b3JrIGlmIHRoZSByZXF1ZXN0ZXIgaXMgdGhlIGF1dGhvciBvZiB0aGlzIENvbW1lbnQvU3VibWlzc2lvbi5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtvcHRpb25zLnN0YXR1cz10cnVlXSBEZXRlcm1pbmVzIGhvdyB0aGUgaXRlbSBzaG91bGQgYmUgZGlzdGluZ3Vpc2hlZC5cbiAgYHRydWVgIChkZWZhdWx0KSBzaWduaWZpZXMgdGhhdCB0aGUgaXRlbSBzaG91bGQgYmUgbW9kZXJhdG9yLWRpc3Rpbmd1aXNoZWQsIGFuZFxuICBgZmFsc2VgIHNpZ25pZmllcyB0aGF0IHRoZSBpdGVtIHNob3VsZCBub3QgYmUgZGlzdGluZ3Vpc2hlZC4gUGFzc2luZyBhIHN0cmluZyAoZS5nLlxuICBgYWRtaW5gKSB3aWxsIGNhdXNlIHRoZSBpdGVtIHRvIGdldCBkaXN0aW5ndWlzaGVkIHdpdGggdGhhdCBzdHJpbmcsIGlmIHBvc3NpYmxlLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3RpY2t5PWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBpdGVtIHNob3VsZCBiZSBzdGlja2llZCBpbiBhZGRpdGlvbiB0byBiZWluZ1xuICBkaXN0aW5ndWlzaGVkLiAoVGhpcyBvbmx5IGFwcGxpZXMgdG8gY29tbWVudHM7IHRvIHN0aWNreSBhIHN1Ym1pc3Npb24sIHVzZSB7QGxpbmsgU3VibWlzc2lvbiNzdGlja3l9IGluc3RlYWQuKVxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAqIEBleGFtcGxlIHIuZ2V0Q29tbWVudCgnZDF4Y2xmbycpLmRpc3Rpbmd1aXNoKHtzdGF0dXM6IHRydWUsIHN0aWNreTogdHJ1ZX0pXG4gICovXG5cblxuICBkaXN0aW5ndWlzaCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkc3RhdHVzID0gX3JlZi5zdGF0dXMsXG4gICAgICAgIHN0YXR1cyA9IF9yZWYkc3RhdHVzID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRzdGF0dXMsXG4gICAgICAgIF9yZWYkc3RpY2t5ID0gX3JlZi5zdGlja3ksXG4gICAgICAgIHN0aWNreSA9IF9yZWYkc3RpY2t5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkc3RpY2t5O1xuXG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL2Rpc3Rpbmd1aXNoJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIGhvdzogc3RhdHVzID09PSB0cnVlID8gJ3llcycgOiBzdGF0dXMgPT09IGZhbHNlID8gJ25vJyA6IHN0YXR1cyxcbiAgICAgICAgc3RpY2t5LFxuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFVuZGlzdGluZ3Vpc2hlcyB0aGlzIENvbW1lbnQgb3IgU3VibWlzc2lvbi4gQWxpYXMgZm9yIGRpc3Rpbmd1aXNoKHtzdGF0dXM6IGZhbHNlfSlcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZS5cbiAgKiBAZXhhbXBsZSByLmdldFN1Ym1pc3Npb24oJzRlNjJtbCcpLnVuZGlzdGluZ3Vpc2goKVxuICAqL1xuXG5cbiAgdW5kaXN0aW5ndWlzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0aW5ndWlzaCh7XG4gICAgICBzdGF0dXM6IGZhbHNlLFxuICAgICAgc3RpY2t5OiBmYWxzZVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBFZGl0cyB0aGlzIENvbW1lbnQgb3IgU3VibWlzc2lvbi5cbiAgKiBAcGFyYW0ge3N0cmluZ30gdXBkYXRlZFRleHQgVGhlIHVwZGF0ZWQgbWFya2Rvd24gdGV4dCB0byB1c2VcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGlzIHJlcXVlc3QgaXMgY29tcGxldGUuXG4gICogQGV4YW1wbGUgci5nZXRDb21tZW50KCdjb2lwOTA5JykuZWRpdCgnQmxhaCBibGFoIGJsYWggdGhpcyBpcyBuZXcgdXBkYXRlZCB0ZXh0JylcbiAgKi9cblxuXG4gIGVkaXQodXBkYXRlZFRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvZWRpdHVzZXJ0ZXh0JyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIHRleHQ6IHVwZGF0ZWRUZXh0LFxuICAgICAgICB0aGluZ19pZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSkudGFwKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2l2ZXMgcmVkZGl0IGdvbGQgdG8gdGhlIGF1dGhvciBvZiB0aGlzIENvbW1lbnQgb3IgU3VibWlzc2lvbi5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsbGZpbGxzIHdpdGggdGhpcyBDb21tZW50L1N1Ym1pc3Npb24gd2hlbiB0aGlzIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldENvbW1lbnQoJ2NvaXA5MDknKS5naWxkKClcbiAgKi9cblxuXG4gIGdpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcImFwaS92MS9nb2xkL2dpbGQvXCIuY29uY2F0KHRoaXMubmFtZSlcbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cblxuICBfc2V0SW5ib3hSZXBsaWVzRW5hYmxlZChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9zZW5kcmVwbGllcycsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpZDogdGhpcy5uYW1lXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgRW5hYmxlcyBpbmJveCByZXBsaWVzIG9uIHRoaXMgQ29tbWVudCBvciBTdWJtaXNzaW9uXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBjb250ZW50IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldENvbW1lbnQoJ2NvaXA5MDknKS5lbmFibGVJbmJveFJlcGxpZXMoKVxuICAqL1xuXG5cbiAgZW5hYmxlSW5ib3hSZXBsaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXRJbmJveFJlcGxpZXNFbmFibGVkKHRydWUpLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBEaXNhYmxlcyBpbmJveCByZXBsaWVzIG9uIHRoaXMgQ29tbWVudCBvciBTdWJtaXNzaW9uXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBjb250ZW50IHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldENvbW1lbnQoJ2NvaXA5MDknKS5kaXNhYmxlSW5ib3hSZXBsaWVzKClcbiAgKi9cblxuXG4gIGRpc2FibGVJbmJveFJlcGxpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldEluYm94UmVwbGllc0VuYWJsZWQoZmFsc2UpLnJldHVybih0aGlzKTtcbiAgfVxuXG4gIF9tdXRhdGVBbmRFeHBhbmRSZXBsaWVzKF9yZWYyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBsaW1pdCA9IF9yZWYyLmxpbWl0LFxuICAgICAgICBkZXB0aCA9IF9yZWYyLmRlcHRoO1xuXG4gICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgIHJldHVybiBfUHJvbWlzZS5kZWZhdWx0LnJlc29sdmUodGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIHJlcGxpZXNLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLl9uYW1lID09PSAnU3VibWlzc2lvbicgPyAnY29tbWVudHMnIDogJ3JlcGxpZXMnO1xuICAgIHJldHVybiB0aGlzW3JlcGxpZXNLZXldLmZldGNoTW9yZSh7XG4gICAgICBhbW91bnQ6IGxpbWl0IC0gdGhpc1tyZXBsaWVzS2V5XS5sZW5ndGhcbiAgICB9KS50YXAoZnVuY3Rpb24gKHJlcGxpZXMpIHtcbiAgICAgIF90aGlzW3JlcGxpZXNLZXldID0gcmVwbGllcztcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXBsaWVzKSB7XG4gICAgICByZXR1cm4gcmVwbGllcy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChyZXBseSkge1xuICAgICAgcmV0dXJuIHJlcGx5Ll9tdXRhdGVBbmRFeHBhbmRSZXBsaWVzKHtcbiAgICAgICAgbGltaXQsXG4gICAgICAgIGRlcHRoOiBkZXB0aCAtIDFcbiAgICAgIH0pO1xuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBFeHBhbmRzIHRoZSByZXBseSBMaXN0aW5ncyBvbiB0aGlzIENvbW1lbnQvU3VibWlzc2lvbi5cbiAgKiBAZGVzYyBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlcyB3aGVyZSBvbmUgd2FudHMgdG8gZW51bWVyYXRlIGFsbCBjb21tZW50cyBvbiBhXG4gIHRocmVhZCwgZXZlbiB0aGUgb25lcyB0aGF0IGFyZSBpbml0aWFsbHkgaGlkZGVuIHdoZW4gdmlld2luZyBpdCAoZS5nLiBsb25nIGNvbW1lbnQgY2hhaW5zKS5cbiAgKlxuICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0d28gb3B0aW9uYWwgcGFyYW1ldGVycyBgb3B0aW9ucy5saW1pdGAgYW5kIGBvcHRpb25zLmRlcHRoYC4gYG9wdGlvbnMubGltaXRgIHNldHMgYW4gdXBwZXIgYm91bmRcbiAgZm9yIHRoZSBicmFuY2hpbmcgZmFjdG9yIG9mIHRoZSByZXN1bHRpbmcgcmVwbGllcyB0cmVlLCBpLmUuIHRoZSBudW1iZXIgb2YgY29tbWVudHMgdGhhdCBhcmUgZmV0Y2hlZCBpbiByZXBseSB0byBhbnkgZ2l2ZW5cbiAgaXRlbS4gYG9wdGlvbnMuZGVwdGhgIHNldHMgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBkZXB0aCBvZiB0aGUgcmVzdWx0aW5nIHJlcGxpZXMgdHJlZSAod2hlcmUgYSBkZXB0aCBvZiAwIHNpZ25pZmllcyB0aGF0IG5vXG4gIHJlcGxpZXMgc2hvdWxkIGJlIGZldGNoZWQgYXQgYWxsKS5cbiAgKlxuICAqIE5vdGUgdGhhdCByZWdhcmRsZXNzIG9mIHRoZSBgbGltaXRgIGFuZCBgZGVwdGhgIHBhcmFtZXRlcnMgdXNlZCwgYW55IHJlcGx5IHRoYXQgYXBwZWFyZWQgaW4gdGhlIG9yaWdpbmFsIHJlcGx5IHRyZWUgd2lsbFxuICBhcHBlYXIgaW4gdGhlIGV4cGFuZGVkIHJlcGx5IHRyZWUuIEluIGNlcnRhaW4gY2FzZXMsIHRoZSBkZXB0aCBvZiB0aGUgcmVzdWx0aW5nIHRyZWUgbWF5IGFsc28gYmUgbGFyZ2VyIHRoYW4gYG9wdGlvbnMuZGVwdGhgLFxuICBpZiB0aGUgcmVkZGl0IEFQSSByZXR1cm5zIG1vcmUgb2YgYSBjb21tZW50IHRyZWUgdGhhbiBuZWVkZWQuXG4gICpcbiAgKiBUaGVzZSBwYXJhbWV0ZXJzIHNob3VsZCBwcmltYXJpbHkgYmUgdXNlZCB0byBrZWVwIHRoZSByZXF1ZXN0IGNvdW50IGxvdzsgaWYgYSBwcmVjaXNlIGxpbWl0IGFuZCBkZXB0aCBhcmUgbmVlZGVkLCBpdCBpc1xuICByZWNvbW1lbmRlZCB0byBtYW51YWxseSB2ZXJpZnkgdGhlIGNvbW1lbnRzIGluIHRoZSB0cmVlIGFmdGVyd2FyZHMuXG4gICpcbiAgKiBCb3RoIHBhcmFtZXRlcnMgZGVmYXVsdCB0byBgSW5maW5pdHlgIGlmIG9taXR0ZWQsIGkuZS4gdGhlIHJlc3VsdGluZyB0cmVlIGNvbnRhaW5zIGV2ZXJ5IHNpbmdsZSBjb21tZW50IGF2YWlsYWJsZS4gSXQgc2hvdWxkXG4gIGJlIG5vdGVkIHRoYXQgZGVwZW5kaW5nIG9uIHRoZSBzaXplIGFuZCBkZXB0aCBvZiB0aGUgdGhyZWFkLCBmZXRjaGluZyBldmVyeSBzaW5nbGUgY29tbWVudCBjYW4gdXNlIHVwIGEgc2lnbmlmaWNhbnQgbnVtYmVyXG4gIG9mIHJhdGVsaW1pdGVkIHJlcXVlc3RzLiAoVG8gZ2l2ZSBhbiBpbnR1aXRpdmUgZXN0aW1hdGUsIGNvbnNpZGVyIGhvdyBtYW55IGNsaWNrcyB3b3VsZCBiZSBuZWVkZWQgdG8gdmlldyBhbGwgdGhlXG4gIGNvbW1lbnRzIG9uIHRoZSB0aHJlYWQgdXNpbmcgdGhlIEhUTUwgc2l0ZS4pXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XVxuICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW1pdD1JbmZpbml0eV0gQW4gdXBwZXItYm91bmQgZm9yIHRoZSBicmFuY2hpbmcgZmFjdG9yIG9mIHRoZSByZXN1bHRpbmcgdHJlZSBvZiByZXBsaWVzXG4gICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlcHRoPUluZmluaXR5XSBBbiB1cHBlci1ib3VuZCBmb3IgdGhlIGRlcHRoIG9mIHRoZSByZXN1bHRpbmcgdHJlZSBvZiByZXBsaWVzXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggYSBuZXcgdmVyc2lvbiBvZiB0aGlzIG9iamVjdCB0aGF0IGhhcyBhbiBleHBhbmRlZCByZXBseSB0cmVlLiBUaGUgb3JpZ2luYWxcbiAgb2JqZWN0IGlzIG5vdCBtb2RpZmllZFxuICAqIEBleGFtcGxlIHIuZ2V0U3VibWlzc2lvbignNGZ1cTI2JykuZXhwYW5kUmVwbGllcygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gKGEgdmVyeSBsYXJnZSBjb21tZW50IHRyZWUgY29udGFpbmluZyBldmVyeSB2aWV3YWJsZSBjb21tZW50IG9uIHRoaXMgdGhyZWFkKVxuICAqL1xuXG5cbiAgZXhwYW5kUmVwbGllcygpIHtcbiAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmMyRsaW1pdCA9IF9yZWYzLmxpbWl0LFxuICAgICAgICBsaW1pdCA9IF9yZWYzJGxpbWl0ID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9yZWYzJGxpbWl0LFxuICAgICAgICBfcmVmMyRkZXB0aCA9IF9yZWYzLmRlcHRoLFxuICAgICAgICBkZXB0aCA9IF9yZWYzJGRlcHRoID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9yZWYzJGRlcHRoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3IuX3Byb21pc2VXcmFwKHRoaXMuZmV0Y2goKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuX2Nsb25lKHtcbiAgICAgICAgZGVlcDogdHJ1ZVxuICAgICAgfSkuX211dGF0ZUFuZEV4cGFuZFJlcGxpZXMoe1xuICAgICAgICBsaW1pdCxcbiAgICAgICAgZGVwdGhcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuXG59OyAvLyBWb3RlYWJsZUNvbnRlbnQjZGVsZXRlIGlzIG5vdCBpbiB0aGUgY2xhc3MgYm9keSBzaW5jZSBTYWZhcmkgOSBjYW4ndCBwYXJzZSB0aGUgYGRlbGV0ZWAgZnVuY3Rpb24gbmFtZSBpbiBjbGFzcyBib2RpZXMuXG5cbi8qKlxuKiBAZnVuY3Rpb25cbiogQG5hbWUgZGVsZXRlXG4qIEBzdW1tYXJ5IERlbGV0ZXMgdGhpcyBDb21tZW50IG9yIFN1Ym1pc3Npb25cbiogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBDb21tZW50L1N1Ym1pc3Npb24gd2hlbiB0aGlzIHJlcXVlc3QgaXMgY29tcGxldGVcbiogQGV4YW1wbGUgci5nZXRDb21tZW50KCdjb2lwOTA5JykuZGVsZXRlKClcbiogQG1lbWJlcm9mIFZvdGVhYmxlQ29udGVudFxuKiBAaW5zdGFuY2VcbiovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWb3RlYWJsZUNvbnRlbnQucHJvdG90eXBlLCAnZGVsZXRlJywge1xuICB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvZGVsJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgaWQ6IHRoaXMubmFtZVxuICAgICAgfVxuICAgIH0pLnJldHVybih0aGlzKTtcbiAgfSxcblxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcbnZhciBfZGVmYXVsdCA9IFZvdGVhYmxlQ29udGVudDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/VoteableContent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/WikiPage.js":
/*!********************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/WikiPage.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* A class representing a wiki page on a subreddit.\n*\n* **Note:** Due to a bug in reddit's CORS settings, it is not possible to fetch the contents of a wiki page on a private\nsubreddit while running snoowrap in a browser. (This issue does not apply when running snoowrap in Node.js.)\n*\n* <style> #WikiPage {display: none} </style>\n* @extends RedditContent\n* @example\n*\n* // Get a wiki page on a given subreddit by name\n* r.getSubreddit('AskReddit').getWikiPage('rules')\n*/\nvar WikiPage = class WikiPage extends _RedditContent.default {\n  get _uri() {\n    return \"r/\".concat(this.subreddit.display_name, \"/wiki/\").concat(this.title);\n  }\n  /**\n  * @summary Gets the current settings for this wiki page.\n  * @returns {Promise} An Object representing the settings for this page\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getWikiPage('index').getSettings().then(console.log)\n  * // => WikiPageSettings { permlevel: 0, editors: [], listed: true }\n  */\n\n\n  getSettings() {\n    return this._get({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/wiki/settings/\").concat(this.title)\n    });\n  }\n  /**\n  * @summary Edits the settings for this wiki page.\n  * @param {object} options\n  * @param {boolean} options.listed Determines whether this wiki page should appear on the public list of pages for this\n  subreddit.\n  * @param {number} options.permissionLevel Determines who should be allowed to access and edit this page `0` indicates that\n  this subreddit's default wiki settings should get used, `1` indicates that only approved wiki contributors on this subreddit\n  should be able to edit this page, and `2` indicates that only mods should be able to view and edit this page.\n  * @returns {Promise} A Promise that fulfills with this WikiPage when the request is complete\n  * @example r.getSubreddit('snoowrap').getWikiPage('index').editSettings({listed: false, permission_level: 1})\n  */\n\n\n  editSettings(_ref) {\n    var listed = _ref.listed,\n        permission_level = _ref.permission_level,\n        _ref$permissionLevel = _ref.permissionLevel,\n        permissionLevel = _ref$permissionLevel === void 0 ? permission_level : _ref$permissionLevel;\n    return this._post({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/wiki/settings/\").concat(this.title),\n      form: {\n        listed,\n        permlevel: permissionLevel\n      }\n    }).return(this);\n  }\n\n  _modifyEditor(_ref2) {\n    var name = _ref2.name,\n        action = _ref2.action;\n    return this._post({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/api/wiki/alloweditor/\").concat(action),\n      form: {\n        page: this.title,\n        username: name\n      }\n    });\n  }\n  /**\n  * @summary Makes the given user an approved editor of this wiki page.\n  * @param {object} options\n  * @param {string} options.name The name of the user to be added\n  * @returns {Promise} A Promise that fulfills with this WikiPage when the request is complete\n  * @example r.getSubreddit('snoowrap').getWikiPage('index').addEditor({name: 'actually_an_aardvark'})\n  */\n\n\n  addEditor(_ref3) {\n    var name = _ref3.name;\n    return this._modifyEditor({\n      name,\n      action: 'add'\n    }).return(this);\n  }\n  /**\n  * @summary Revokes this user's approved editor status for this wiki page\n  * @param {object} options\n  * @param {string} options.name The name of the user to be removed\n  * @returns {Promise} A Promise that fulfills with this WikiPage when the request is complete\n  * @example r.getSubreddit('snoowrap').getWikiPage('index').removeEditor({name: 'actually_an_aardvark'})\n  */\n\n\n  removeEditor(_ref4) {\n    var name = _ref4.name;\n    return this._modifyEditor({\n      name,\n      action: 'del'\n    }).return(this);\n  }\n  /**\n  * @summary Edits this wiki page, or creates it if it does not exist yet.\n  * @param {object} options\n  * @param {string} options.text The new content of the page, in markdown.\n  * @param {string} [options.reason] The edit reason that will appear in this page's revision history. 256 characters max\n  * @param {string} [options.previousRevision] Determines which revision this edit should be added to. If this parameter is\n  omitted, this edit is simply added to the most recent revision.\n  * @returns {Promise} A Promise that fulfills with this WikiPage when the request is complete\n  * @example r.getSubreddit('snoowrap').getWikiPage('index').edit({text: 'Welcome', reason: 'Added a welcome message'})\n  */\n\n\n  edit(_ref5) {\n    var text = _ref5.text,\n        reason = _ref5.reason,\n        previous_revision = _ref5.previous_revision,\n        _ref5$previousRevisio = _ref5.previousRevision,\n        previousRevision = _ref5$previousRevisio === void 0 ? previous_revision : _ref5$previousRevisio;\n    return this._post({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/api/wiki/edit\"),\n      form: {\n        content: text,\n        page: this.title,\n        previous: previousRevision,\n        reason\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Gets a list of revisions for this wiki page.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing revisions of this page\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getRevisions({limit: 1}).then(console.log)\n  * // => Listing [\n  * //  {\n  * //    timestamp: 1460973194,\n  * //    reason: 'Added a welcome message',\n  * //    author: RedditUser { name: 'not_an_aardvark', id: 'k83md', ... },\n  * //    page: 'index',\n  * //    id: '506370b4-0508-11e6-b550-0e69f29e0c4d'\n  * //  }\n  * // ]\n  */\n\n\n  getRevisions(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/wiki/revisions/\").concat(this.title),\n      qs: options\n    });\n  }\n  /**\n  * @summary Hides the given revision from this page's public revision history.\n  * @param {object} options\n  * @param {string} options.id The revision's id\n  * @returns {Promise} A Promise that fulfills with this WikiPage when the request is complete\n  * @example r.getSubreddit('snoowrap').getWikiPage('index').hideRevision({id: '506370b4-0508-11e6-b550-0e69f29e0c4d'})\n  */\n\n\n  hideRevision(_ref6) {\n    var id = _ref6.id;\n    return this._post({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/api/wiki/hide\"),\n      qs: {\n        page: this.title,\n        revision: id\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Reverts this wiki page to the given point.\n  * @param {object} options\n  * @param {string} options.id The id of the revision that this page should be reverted to\n  * @returns {Promise} A Promise that fulfills with this WikiPage when the request is complete\n  * @example r.getSubreddit('snoowrap').getWikiPage('index').revert({id: '506370b4-0508-11e6-b550-0e69f29e0c4d'})\n  */\n\n\n  revert(_ref7) {\n    var id = _ref7.id;\n    return this._post({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/api/wiki/revert\"),\n      qs: {\n        page: this.title,\n        revision: id\n      }\n    }).return(this);\n  }\n  /**\n  * @summary Gets a list of discussions about this wiki page.\n  * @param {object} [options] Options for the resulting Listing\n  * @returns {Promise} A Listing containing discussions about this page\n  * @example\n  *\n  * r.getSubreddit('snoowrap').getWikiPage('index').getDiscussions().then(console.log)\n  * // => Listing [\n  * //  Submission { ... },\n  * //  Submission { ... },\n  * //  ...\n  * // ]\n  */\n\n\n  getDiscussions(options) {\n    return this._getListing({\n      uri: \"r/\".concat(this.subreddit.display_name, \"/wiki/discussions/\").concat(this.title),\n      qs: options\n    });\n  }\n\n};\nvar _default = WikiPage;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1dpa2lQYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlOztBQUVmLDRDQUE0QyxtQkFBTyxDQUFDLHVGQUFvQjs7QUFFeEUsdUNBQXVDLHVDQUF1Qzs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QiwyRUFBMkUsbUNBQW1DO0FBQzlHOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2Qix3RUFBd0UsNkJBQTZCO0FBQ3JHOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCLDJFQUEyRSw2QkFBNkI7QUFDeEc7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLG1FQUFtRSxtREFBbUQ7QUFDdEg7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCLDJFQUEyRSwyQ0FBMkM7QUFDdEg7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkIscUVBQXFFLDJDQUEyQztBQUNoSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUIscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL1dpa2lQYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX1JlZGRpdENvbnRlbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlZGRpdENvbnRlbnQuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiogQSBjbGFzcyByZXByZXNlbnRpbmcgYSB3aWtpIHBhZ2Ugb24gYSBzdWJyZWRkaXQuXG4qXG4qICoqTm90ZToqKiBEdWUgdG8gYSBidWcgaW4gcmVkZGl0J3MgQ09SUyBzZXR0aW5ncywgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGZldGNoIHRoZSBjb250ZW50cyBvZiBhIHdpa2kgcGFnZSBvbiBhIHByaXZhdGVcbnN1YnJlZGRpdCB3aGlsZSBydW5uaW5nIHNub293cmFwIGluIGEgYnJvd3Nlci4gKFRoaXMgaXNzdWUgZG9lcyBub3QgYXBwbHkgd2hlbiBydW5uaW5nIHNub293cmFwIGluIE5vZGUuanMuKVxuKlxuKiA8c3R5bGU+ICNXaWtpUGFnZSB7ZGlzcGxheTogbm9uZX0gPC9zdHlsZT5cbiogQGV4dGVuZHMgUmVkZGl0Q29udGVudFxuKiBAZXhhbXBsZVxuKlxuKiAvLyBHZXQgYSB3aWtpIHBhZ2Ugb24gYSBnaXZlbiBzdWJyZWRkaXQgYnkgbmFtZVxuKiByLmdldFN1YnJlZGRpdCgnQXNrUmVkZGl0JykuZ2V0V2lraVBhZ2UoJ3J1bGVzJylcbiovXG52YXIgV2lraVBhZ2UgPSBjbGFzcyBXaWtpUGFnZSBleHRlbmRzIF9SZWRkaXRDb250ZW50LmRlZmF1bHQge1xuICBnZXQgX3VyaSgpIHtcbiAgICByZXR1cm4gXCJyL1wiLmNvbmNhdCh0aGlzLnN1YnJlZGRpdC5kaXNwbGF5X25hbWUsIFwiL3dpa2kvXCIpLmNvbmNhdCh0aGlzLnRpdGxlKTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBHZXRzIHRoZSBjdXJyZW50IHNldHRpbmdzIGZvciB0aGlzIHdpa2kgcGFnZS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQW4gT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2V0dGluZ3MgZm9yIHRoaXMgcGFnZVxuICAqIEBleGFtcGxlXG4gICpcbiAgKiByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRXaWtpUGFnZSgnaW5kZXgnKS5nZXRTZXR0aW5ncygpLnRoZW4oY29uc29sZS5sb2cpXG4gICogLy8gPT4gV2lraVBhZ2VTZXR0aW5ncyB7IHBlcm1sZXZlbDogMCwgZWRpdG9yczogW10sIGxpc3RlZDogdHJ1ZSB9XG4gICovXG5cblxuICBnZXRTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLnN1YnJlZGRpdC5kaXNwbGF5X25hbWUsIFwiL3dpa2kvc2V0dGluZ3MvXCIpLmNvbmNhdCh0aGlzLnRpdGxlKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEVkaXRzIHRoZSBzZXR0aW5ncyBmb3IgdGhpcyB3aWtpIHBhZ2UuXG4gICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGlzdGVkIERldGVybWluZXMgd2hldGhlciB0aGlzIHdpa2kgcGFnZSBzaG91bGQgYXBwZWFyIG9uIHRoZSBwdWJsaWMgbGlzdCBvZiBwYWdlcyBmb3IgdGhpc1xuICBzdWJyZWRkaXQuXG4gICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucGVybWlzc2lvbkxldmVsIERldGVybWluZXMgd2hvIHNob3VsZCBiZSBhbGxvd2VkIHRvIGFjY2VzcyBhbmQgZWRpdCB0aGlzIHBhZ2UgYDBgIGluZGljYXRlcyB0aGF0XG4gIHRoaXMgc3VicmVkZGl0J3MgZGVmYXVsdCB3aWtpIHNldHRpbmdzIHNob3VsZCBnZXQgdXNlZCwgYDFgIGluZGljYXRlcyB0aGF0IG9ubHkgYXBwcm92ZWQgd2lraSBjb250cmlidXRvcnMgb24gdGhpcyBzdWJyZWRkaXRcbiAgc2hvdWxkIGJlIGFibGUgdG8gZWRpdCB0aGlzIHBhZ2UsIGFuZCBgMmAgaW5kaWNhdGVzIHRoYXQgb25seSBtb2RzIHNob3VsZCBiZSBhYmxlIHRvIHZpZXcgYW5kIGVkaXQgdGhpcyBwYWdlLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoaXMgV2lraVBhZ2Ugd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAqIEBleGFtcGxlIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFdpa2lQYWdlKCdpbmRleCcpLmVkaXRTZXR0aW5ncyh7bGlzdGVkOiBmYWxzZSwgcGVybWlzc2lvbl9sZXZlbDogMX0pXG4gICovXG5cblxuICBlZGl0U2V0dGluZ3MoX3JlZikge1xuICAgIHZhciBsaXN0ZWQgPSBfcmVmLmxpc3RlZCxcbiAgICAgICAgcGVybWlzc2lvbl9sZXZlbCA9IF9yZWYucGVybWlzc2lvbl9sZXZlbCxcbiAgICAgICAgX3JlZiRwZXJtaXNzaW9uTGV2ZWwgPSBfcmVmLnBlcm1pc3Npb25MZXZlbCxcbiAgICAgICAgcGVybWlzc2lvbkxldmVsID0gX3JlZiRwZXJtaXNzaW9uTGV2ZWwgPT09IHZvaWQgMCA/IHBlcm1pc3Npb25fbGV2ZWwgOiBfcmVmJHBlcm1pc3Npb25MZXZlbDtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5zdWJyZWRkaXQuZGlzcGxheV9uYW1lLCBcIi93aWtpL3NldHRpbmdzL1wiKS5jb25jYXQodGhpcy50aXRsZSksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGxpc3RlZCxcbiAgICAgICAgcGVybWxldmVsOiBwZXJtaXNzaW9uTGV2ZWxcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cblxuICBfbW9kaWZ5RWRpdG9yKF9yZWYyKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lLFxuICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb247XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHRoaXMuc3VicmVkZGl0LmRpc3BsYXlfbmFtZSwgXCIvYXBpL3dpa2kvYWxsb3dlZGl0b3IvXCIpLmNvbmNhdChhY3Rpb24pLFxuICAgICAgZm9ybToge1xuICAgICAgICBwYWdlOiB0aGlzLnRpdGxlLFxuICAgICAgICB1c2VybmFtZTogbmFtZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IE1ha2VzIHRoZSBnaXZlbiB1c2VyIGFuIGFwcHJvdmVkIGVkaXRvciBvZiB0aGlzIHdpa2kgcGFnZS5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIG5hbWUgb2YgdGhlIHVzZXIgdG8gYmUgYWRkZWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFdpa2lQYWdlIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRXaWtpUGFnZSgnaW5kZXgnKS5hZGRFZGl0b3Ioe25hbWU6ICdhY3R1YWxseV9hbl9hYXJkdmFyayd9KVxuICAqL1xuXG5cbiAgYWRkRWRpdG9yKF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lO1xuICAgIHJldHVybiB0aGlzLl9tb2RpZnlFZGl0b3Ioe1xuICAgICAgbmFtZSxcbiAgICAgIGFjdGlvbjogJ2FkZCdcbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgUmV2b2tlcyB0aGlzIHVzZXIncyBhcHByb3ZlZCBlZGl0b3Igc3RhdHVzIGZvciB0aGlzIHdpa2kgcGFnZVxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgbmFtZSBvZiB0aGUgdXNlciB0byBiZSByZW1vdmVkXG4gICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdGhpcyBXaWtpUGFnZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICogQGV4YW1wbGUgci5nZXRTdWJyZWRkaXQoJ3Nub293cmFwJykuZ2V0V2lraVBhZ2UoJ2luZGV4JykucmVtb3ZlRWRpdG9yKHtuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnfSlcbiAgKi9cblxuXG4gIHJlbW92ZUVkaXRvcihfcmVmNCkge1xuICAgIHZhciBuYW1lID0gX3JlZjQubmFtZTtcbiAgICByZXR1cm4gdGhpcy5fbW9kaWZ5RWRpdG9yKHtcbiAgICAgIG5hbWUsXG4gICAgICBhY3Rpb246ICdkZWwnXG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEVkaXRzIHRoaXMgd2lraSBwYWdlLCBvciBjcmVhdGVzIGl0IGlmIGl0IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRleHQgVGhlIG5ldyBjb250ZW50IG9mIHRoZSBwYWdlLCBpbiBtYXJrZG93bi5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVhc29uXSBUaGUgZWRpdCByZWFzb24gdGhhdCB3aWxsIGFwcGVhciBpbiB0aGlzIHBhZ2UncyByZXZpc2lvbiBoaXN0b3J5LiAyNTYgY2hhcmFjdGVycyBtYXhcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJldmlvdXNSZXZpc2lvbl0gRGV0ZXJtaW5lcyB3aGljaCByZXZpc2lvbiB0aGlzIGVkaXQgc2hvdWxkIGJlIGFkZGVkIHRvLiBJZiB0aGlzIHBhcmFtZXRlciBpc1xuICBvbWl0dGVkLCB0aGlzIGVkaXQgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBtb3N0IHJlY2VudCByZXZpc2lvbi5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFdpa2lQYWdlIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRXaWtpUGFnZSgnaW5kZXgnKS5lZGl0KHt0ZXh0OiAnV2VsY29tZScsIHJlYXNvbjogJ0FkZGVkIGEgd2VsY29tZSBtZXNzYWdlJ30pXG4gICovXG5cblxuICBlZGl0KF9yZWY1KSB7XG4gICAgdmFyIHRleHQgPSBfcmVmNS50ZXh0LFxuICAgICAgICByZWFzb24gPSBfcmVmNS5yZWFzb24sXG4gICAgICAgIHByZXZpb3VzX3JldmlzaW9uID0gX3JlZjUucHJldmlvdXNfcmV2aXNpb24sXG4gICAgICAgIF9yZWY1JHByZXZpb3VzUmV2aXNpbyA9IF9yZWY1LnByZXZpb3VzUmV2aXNpb24sXG4gICAgICAgIHByZXZpb3VzUmV2aXNpb24gPSBfcmVmNSRwcmV2aW91c1JldmlzaW8gPT09IHZvaWQgMCA/IHByZXZpb3VzX3JldmlzaW9uIDogX3JlZjUkcHJldmlvdXNSZXZpc2lvO1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLnN1YnJlZGRpdC5kaXNwbGF5X25hbWUsIFwiL2FwaS93aWtpL2VkaXRcIiksXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICAgIHBhZ2U6IHRoaXMudGl0bGUsXG4gICAgICAgIHByZXZpb3VzOiBwcmV2aW91c1JldmlzaW9uLFxuICAgICAgICByZWFzb25cbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgcmV2aXNpb25zIGZvciB0aGlzIHdpa2kgcGFnZS5cbiAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyByZXZpc2lvbnMgb2YgdGhpcyBwYWdlXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFJldmlzaW9ucyh7bGltaXQ6IDF9KS50aGVuKGNvbnNvbGUubG9nKVxuICAqIC8vID0+IExpc3RpbmcgW1xuICAqIC8vICB7XG4gICogLy8gICAgdGltZXN0YW1wOiAxNDYwOTczMTk0LFxuICAqIC8vICAgIHJlYXNvbjogJ0FkZGVkIGEgd2VsY29tZSBtZXNzYWdlJyxcbiAgKiAvLyAgICBhdXRob3I6IFJlZGRpdFVzZXIgeyBuYW1lOiAnbm90X2FuX2FhcmR2YXJrJywgaWQ6ICdrODNtZCcsIC4uLiB9LFxuICAqIC8vICAgIHBhZ2U6ICdpbmRleCcsXG4gICogLy8gICAgaWQ6ICc1MDYzNzBiNC0wNTA4LTExZTYtYjU1MC0wZTY5ZjI5ZTBjNGQnXG4gICogLy8gIH1cbiAgKiAvLyBdXG4gICovXG5cblxuICBnZXRSZXZpc2lvbnMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogXCJyL1wiLmNvbmNhdCh0aGlzLnN1YnJlZGRpdC5kaXNwbGF5X25hbWUsIFwiL3dpa2kvcmV2aXNpb25zL1wiKS5jb25jYXQodGhpcy50aXRsZSksXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IEhpZGVzIHRoZSBnaXZlbiByZXZpc2lvbiBmcm9tIHRoaXMgcGFnZSdzIHB1YmxpYyByZXZpc2lvbiBoaXN0b3J5LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWQgVGhlIHJldmlzaW9uJ3MgaWRcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFdpa2lQYWdlIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRXaWtpUGFnZSgnaW5kZXgnKS5oaWRlUmV2aXNpb24oe2lkOiAnNTA2MzcwYjQtMDUwOC0xMWU2LWI1NTAtMGU2OWYyOWUwYzRkJ30pXG4gICovXG5cblxuICBoaWRlUmV2aXNpb24oX3JlZjYpIHtcbiAgICB2YXIgaWQgPSBfcmVmNi5pZDtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5zdWJyZWRkaXQuZGlzcGxheV9uYW1lLCBcIi9hcGkvd2lraS9oaWRlXCIpLFxuICAgICAgcXM6IHtcbiAgICAgICAgcGFnZTogdGhpcy50aXRsZSxcbiAgICAgICAgcmV2aXNpb246IGlkXG4gICAgICB9XG4gICAgfSkucmV0dXJuKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIEBzdW1tYXJ5IFJldmVydHMgdGhpcyB3aWtpIHBhZ2UgdG8gdGhlIGdpdmVuIHBvaW50LlxuICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWQgVGhlIGlkIG9mIHRoZSByZXZpc2lvbiB0aGF0IHRoaXMgcGFnZSBzaG91bGQgYmUgcmV2ZXJ0ZWQgdG9cbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB0aGlzIFdpa2lQYWdlIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgKiBAZXhhbXBsZSByLmdldFN1YnJlZGRpdCgnc25vb3dyYXAnKS5nZXRXaWtpUGFnZSgnaW5kZXgnKS5yZXZlcnQoe2lkOiAnNTA2MzcwYjQtMDUwOC0xMWU2LWI1NTAtMGU2OWYyOWUwYzRkJ30pXG4gICovXG5cblxuICByZXZlcnQoX3JlZjcpIHtcbiAgICB2YXIgaWQgPSBfcmVmNy5pZDtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5zdWJyZWRkaXQuZGlzcGxheV9uYW1lLCBcIi9hcGkvd2lraS9yZXZlcnRcIiksXG4gICAgICBxczoge1xuICAgICAgICBwYWdlOiB0aGlzLnRpdGxlLFxuICAgICAgICByZXZpc2lvbjogaWRcbiAgICAgIH1cbiAgICB9KS5yZXR1cm4odGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgZGlzY3Vzc2lvbnMgYWJvdXQgdGhpcyB3aWtpIHBhZ2UuXG4gICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgZGlzY3Vzc2lvbnMgYWJvdXQgdGhpcyBwYWdlXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHIuZ2V0U3VicmVkZGl0KCdzbm9vd3JhcCcpLmdldFdpa2lQYWdlKCdpbmRleCcpLmdldERpc2N1c3Npb25zKCkudGhlbihjb25zb2xlLmxvZylcbiAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgKiAvLyAgU3VibWlzc2lvbiB7IC4uLiB9LFxuICAqIC8vICBTdWJtaXNzaW9uIHsgLi4uIH0sXG4gICogLy8gIC4uLlxuICAqIC8vIF1cbiAgKi9cblxuXG4gIGdldERpc2N1c3Npb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwici9cIi5jb25jYXQodGhpcy5zdWJyZWRkaXQuZGlzcGxheV9uYW1lLCBcIi93aWtpL2Rpc2N1c3Npb25zL1wiKS5jb25jYXQodGhpcy50aXRsZSksXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbn07XG52YXIgX2RlZmF1bHQgPSBXaWtpUGFnZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/WikiPage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/objects/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/snoowrap/dist/objects/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"RedditContent\", ({\n  enumerable: true,\n  get: function () {\n    return _RedditContent.default;\n  }\n}));\nObject.defineProperty(exports, \"ReplyableContent\", ({\n  enumerable: true,\n  get: function () {\n    return _ReplyableContent.default;\n  }\n}));\nObject.defineProperty(exports, \"VoteableContent\", ({\n  enumerable: true,\n  get: function () {\n    return _VoteableContent.default;\n  }\n}));\nObject.defineProperty(exports, \"Comment\", ({\n  enumerable: true,\n  get: function () {\n    return _Comment.default;\n  }\n}));\nObject.defineProperty(exports, \"RedditUser\", ({\n  enumerable: true,\n  get: function () {\n    return _RedditUser.default;\n  }\n}));\nObject.defineProperty(exports, \"Submission\", ({\n  enumerable: true,\n  get: function () {\n    return _Submission.default;\n  }\n}));\nObject.defineProperty(exports, \"LiveThread\", ({\n  enumerable: true,\n  get: function () {\n    return _LiveThread.default;\n  }\n}));\nObject.defineProperty(exports, \"PrivateMessage\", ({\n  enumerable: true,\n  get: function () {\n    return _PrivateMessage.default;\n  }\n}));\nObject.defineProperty(exports, \"Subreddit\", ({\n  enumerable: true,\n  get: function () {\n    return _Subreddit.default;\n  }\n}));\nObject.defineProperty(exports, \"MultiReddit\", ({\n  enumerable: true,\n  get: function () {\n    return _MultiReddit.default;\n  }\n}));\nObject.defineProperty(exports, \"WikiPage\", ({\n  enumerable: true,\n  get: function () {\n    return _WikiPage.default;\n  }\n}));\nObject.defineProperty(exports, \"Listing\", ({\n  enumerable: true,\n  get: function () {\n    return _Listing.default;\n  }\n}));\nObject.defineProperty(exports, \"More\", ({\n  enumerable: true,\n  get: function () {\n    return _More.default;\n  }\n}));\nObject.defineProperty(exports, \"UserList\", ({\n  enumerable: true,\n  get: function () {\n    return _UserList.default;\n  }\n}));\nObject.defineProperty(exports, \"ModmailConversation\", ({\n  enumerable: true,\n  get: function () {\n    return _ModmailConversation.default;\n  }\n}));\n\nvar _RedditContent = _interopRequireDefault(__webpack_require__(/*! ./RedditContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditContent.js\"));\n\nvar _ReplyableContent = _interopRequireDefault(__webpack_require__(/*! ./ReplyableContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/ReplyableContent.js\"));\n\nvar _VoteableContent = _interopRequireDefault(__webpack_require__(/*! ./VoteableContent.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/VoteableContent.js\"));\n\nvar _Comment = _interopRequireDefault(__webpack_require__(/*! ./Comment.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/Comment.js\"));\n\nvar _RedditUser = _interopRequireDefault(__webpack_require__(/*! ./RedditUser.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/RedditUser.js\"));\n\nvar _Submission = _interopRequireDefault(__webpack_require__(/*! ./Submission.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/Submission.js\"));\n\nvar _LiveThread = _interopRequireDefault(__webpack_require__(/*! ./LiveThread.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/LiveThread.js\"));\n\nvar _PrivateMessage = _interopRequireDefault(__webpack_require__(/*! ./PrivateMessage.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/PrivateMessage.js\"));\n\nvar _Subreddit = _interopRequireDefault(__webpack_require__(/*! ./Subreddit.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/Subreddit.js\"));\n\nvar _MultiReddit = _interopRequireDefault(__webpack_require__(/*! ./MultiReddit.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/MultiReddit.js\"));\n\nvar _WikiPage = _interopRequireDefault(__webpack_require__(/*! ./WikiPage.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/WikiPage.js\"));\n\nvar _Listing = _interopRequireDefault(__webpack_require__(/*! ./Listing.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/Listing.js\"));\n\nvar _More = _interopRequireDefault(__webpack_require__(/*! ./More.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/More.js\"));\n\nvar _UserList = _interopRequireDefault(__webpack_require__(/*! ./UserList.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/UserList.js\"));\n\nvar _ModmailConversation = _interopRequireDefault(__webpack_require__(/*! ./ModmailConversation.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/ModmailConversation.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9vYmplY3RzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7QUFFRiw0Q0FBNEMsbUJBQU8sQ0FBQyx1RkFBb0I7O0FBRXhFLCtDQUErQyxtQkFBTyxDQUFDLDZGQUF1Qjs7QUFFOUUsOENBQThDLG1CQUFPLENBQUMsMkZBQXNCOztBQUU1RSxzQ0FBc0MsbUJBQU8sQ0FBQywyRUFBYzs7QUFFNUQseUNBQXlDLG1CQUFPLENBQUMsaUZBQWlCOztBQUVsRSx5Q0FBeUMsbUJBQU8sQ0FBQyxpRkFBaUI7O0FBRWxFLHlDQUF5QyxtQkFBTyxDQUFDLGlGQUFpQjs7QUFFbEUsNkNBQTZDLG1CQUFPLENBQUMseUZBQXFCOztBQUUxRSx3Q0FBd0MsbUJBQU8sQ0FBQywrRUFBZ0I7O0FBRWhFLDBDQUEwQyxtQkFBTyxDQUFDLG1GQUFrQjs7QUFFcEUsdUNBQXVDLG1CQUFPLENBQUMsNkVBQWU7O0FBRTlELHNDQUFzQyxtQkFBTyxDQUFDLDJFQUFjOztBQUU1RCxtQ0FBbUMsbUJBQU8sQ0FBQyxxRUFBVzs7QUFFdEQsdUNBQXVDLG1CQUFPLENBQUMsNkVBQWU7O0FBRTlELGtEQUFrRCxtQkFBTyxDQUFDLG1HQUEwQjs7QUFFcEYsdUNBQXVDLHVDQUF1QyIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L29iamVjdHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWRkaXRDb250ZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9SZWRkaXRDb250ZW50LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVwbHlhYmxlQ29udGVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfUmVwbHlhYmxlQ29udGVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZvdGVhYmxlQ29udGVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfVm90ZWFibGVDb250ZW50LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29tbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfQ29tbWVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlZGRpdFVzZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX1JlZGRpdFVzZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdWJtaXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9TdWJtaXNzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGl2ZVRocmVhZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTGl2ZVRocmVhZC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByaXZhdGVNZXNzYWdlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9Qcml2YXRlTWVzc2FnZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN1YnJlZGRpdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfU3VicmVkZGl0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlSZWRkaXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX011bHRpUmVkZGl0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2lraVBhZ2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX1dpa2lQYWdlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlzdGluZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfTGlzdGluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1vcmVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX01vcmUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVc2VyTGlzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfVXNlckxpc3QuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNb2RtYWlsQ29udmVyc2F0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9Nb2RtYWlsQ29udmVyc2F0aW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX1JlZGRpdENvbnRlbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlZGRpdENvbnRlbnQuanNcIikpO1xuXG52YXIgX1JlcGx5YWJsZUNvbnRlbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlcGx5YWJsZUNvbnRlbnQuanNcIikpO1xuXG52YXIgX1ZvdGVhYmxlQ29udGVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vVm90ZWFibGVDb250ZW50LmpzXCIpKTtcblxudmFyIF9Db21tZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Db21tZW50LmpzXCIpKTtcblxudmFyIF9SZWRkaXRVc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9SZWRkaXRVc2VyLmpzXCIpKTtcblxudmFyIF9TdWJtaXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9TdWJtaXNzaW9uLmpzXCIpKTtcblxudmFyIF9MaXZlVGhyZWFkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9MaXZlVGhyZWFkLmpzXCIpKTtcblxudmFyIF9Qcml2YXRlTWVzc2FnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUHJpdmF0ZU1lc3NhZ2UuanNcIikpO1xuXG52YXIgX1N1YnJlZGRpdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vU3VicmVkZGl0LmpzXCIpKTtcblxudmFyIF9NdWx0aVJlZGRpdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTXVsdGlSZWRkaXQuanNcIikpO1xuXG52YXIgX1dpa2lQYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9XaWtpUGFnZS5qc1wiKSk7XG5cbnZhciBfTGlzdGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTGlzdGluZy5qc1wiKSk7XG5cbnZhciBfTW9yZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTW9yZS5qc1wiKSk7XG5cbnZhciBfVXNlckxpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1VzZXJMaXN0LmpzXCIpKTtcblxudmFyIF9Nb2RtYWlsQ29udmVyc2F0aW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Nb2RtYWlsQ29udmVyc2F0aW9uLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/objects/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/request_handler.js":
/*!*******************************************************!*\
  !*** ./node_modules/snoowrap/dist/request_handler.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.oauthRequest = oauthRequest;\nexports._awaitExponentialBackoff = _awaitExponentialBackoff;\nexports._awaitRatelimit = _awaitRatelimit;\nexports._awaitRequestDelay = _awaitRequestDelay;\nexports.credentialedClientRequest = credentialedClientRequest;\nexports.unauthenticatedRequest = unauthenticatedRequest;\nexports.updateAccessToken = updateAccessToken;\nexports.rawRequest = void 0;\n\nvar _lodash = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ./Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _constants = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/snoowrap/dist/constants.js\");\n\nvar _errors = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/snoowrap/dist/errors.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n/**\n* @summary Sends an oauth-authenticated request to the reddit server, and returns the server's response.\n* @desc **Note**: While this function primarily exists for internal use, it is exposed and considered a stable feature.\nHowever, keep in mind that there are usually better alternatives to using this function. For instance, this\nfunction can be used to send a POST request to the 'api/vote' endpoint in order to upvote a comment, but it's generally\neasier to just use snoowrap's [upvote function]{@link VoteableContent#upvote}.\n*\n* If you're using this function to access an API feature/endpoint that is unsupported by snoowrap, please consider [creating an\nissue for it](https://github.com/not-an-aardvark/snoowrap/issues) so that the functionality can be added to snoowrap more\ndirectly.\n* @param {object} options Options for the request. For documentation on these options, see the\n[Request API](https://www.npmjs.com/package/request). Supported options include `uri`, `qs`, `form`, `headers`, `method`,\n`auth`, and `body`. A default `baseUrl` parameter of `this.config().endpoint_domain` is internally included by default, so it\nis recommended that a `uri` parameter be used, rather than a `url` parameter with a\ndomain name.\n* @returns {Promise} A Promise that fulfills with reddit's response.\n* @memberof snoowrap\n* @instance\n* @example\n*\n* r.oauthRequest({uri: '/user/spez/about', method: 'get'}).then(console.log)\n* // => RedditUser { name: 'spez', link_karma: 9567, ... }\n*\n* // Note that this is equivalent to:\n* r.getUser('spez').fetch().then(console.log)\n*\n* // ######\n*\n* r.oauthRequest({uri: '/api/vote', method: 'post', form: {dir: 1, id: 't3_4fzg2k'}})\n* // equivalent to:\n* r.getSubmission('4fzg2k').upvote()\n*\n* // ######\n*\n* r.oauthRequest({uri: '/top', method: 'get', qs: {t: 'all'}})\n* // equivalent to:\n* r.getTop({time: 'all'})\n*/\nfunction oauthRequest(options) {\n  var _Promise$resolve$then,\n      _this = this;\n\n  var attempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return (_Promise$resolve$then = _Promise.default.resolve().then(function () {\n    return _this._awaitRatelimit();\n  }).then(function () {\n    return _this._awaitRequestDelay();\n  }).then(function () {\n    return _awaitExponentialBackoff(attempts);\n  }).then(function () {\n    return _this.updateAccessToken();\n  }).then(function (token) {\n    return _this.rawRequest((0, _lodash.merge)({\n      json: true,\n      headers: {\n        'user-agent': _this.userAgent\n      },\n      baseUrl: \"https://oauth.\".concat(_this._config.endpointDomain),\n      qs: {\n        raw_json: 1\n      },\n      auth: {\n        bearer: token\n      },\n      resolveWithFullResponse: true,\n      timeout: _this._config.requestTimeout,\n      transform: function (body, response) {\n        if (Object.prototype.hasOwnProperty.call(response.headers, 'x-ratelimit-remaining')) {\n          _this.ratelimitRemaining = +response.headers['x-ratelimit-remaining'];\n          _this.ratelimitExpiration = Date.now() + response.headers['x-ratelimit-reset'] * 1000;\n        }\n\n        _this._debug(\"Received a \".concat(response.statusCode, \" status code from a `\").concat(response.request.method, \"` request\"), \"sent to \".concat(response.request.uri.href, \". ratelimitRemaining: \").concat(_this.ratelimitRemaining));\n\n        return response;\n      }\n    }, options));\n  }).then(function (response) {\n    var populated = _this._populate(response.body);\n\n    if (populated && populated.constructor._name === 'Listing') {\n      populated._setUri(response.request.uri.href);\n    }\n\n    return populated;\n  })).catch.apply(_Promise$resolve$then, _toConsumableArray(this._config.retryErrorCodes.map(function (retryCode) {\n    return {\n      statusCode: retryCode\n    };\n  })).concat([function (e) {\n    if (!(0, _lodash.includes)(_constants.IDEMPOTENT_HTTP_VERBS, e.response.request.method) || attempts >= _this._config.maxRetryAttempts) {\n      throw e;\n    }\n    /* If the error's status code is in the user's configured `retryStatusCodes` and this request still has attempts\n    remaining, retry this request and increment the `attempts` counter. */\n\n\n    _this._warn(\"Received status code \".concat(e.statusCode, \" from reddit.\"), \"Retrying request (attempt \".concat(attempts + 1, \"/\").concat(_this._config.maxRetryAttempts, \")...\"));\n\n    return _this.oauthRequest(options, attempts + 1);\n  }])).catch({\n    statusCode: 401\n  }, function (e) {\n    /* If the server returns a 401 error, it's possible that the access token expired during the latency period as this\n    request was being sent. In this scenario, snoowrap thought that the access token was valid for a few more seconds, so it\n    didn't refresh the token, but the token had expired by the time the request reached the server. To handle this issue,\n    invalidate the access token and call oauth_request again, automatically causing the token to be refreshed. */\n    if (_this.accessToken && _this.tokenExpiration - Date.now() < _constants.MAX_TOKEN_LATENCY) {\n      _this.accessToken = null;\n      _this.tokenExpiration = null;\n      return _this.oauthRequest(options, attempts);\n    }\n\n    throw e;\n  });\n}\n\nfunction _awaitExponentialBackoff(attempts) {\n  if (attempts === 1) {\n    return _Promise.default.resolve();\n  }\n\n  return _Promise.default.delay((Math.pow(2, attempts - 1) + (Math.random() - 0.3)) * 1000);\n}\n\nfunction _awaitRatelimit() {\n  if (this.ratelimitRemaining < 1 && Date.now() < this.ratelimitExpiration) {\n    // If the ratelimit has been exceeded, delay or abort the request depending on the user's config.\n    var timeUntilExpiry = this.ratelimitExpiration - Date.now();\n\n    if (this._config.continueAfterRatelimitError) {\n      /* If the `continue_after_ratelimit_error` setting is enabled, queue the request, wait until the next ratelimit\n      period, and then send it. */\n      this._warn((0, _errors.rateLimitWarning)(timeUntilExpiry));\n\n      return _Promise.default.delay(timeUntilExpiry);\n    } // Otherwise, throw an error.\n\n\n    throw new _errors.RateLimitError(timeUntilExpiry);\n  } // If the ratelimit hasn't been exceeded, no delay is necessary.\n\n\n  return _Promise.default.resolve();\n}\n\nfunction _awaitRequestDelay() {\n  var now = Date.now();\n  var waitTime = this._nextRequestTimestamp - now;\n  this._nextRequestTimestamp = Math.max(now, this._nextRequestTimestamp) + this._config.requestDelay;\n  return _Promise.default.delay(waitTime);\n}\n/**\n* @summary Sends a request to the reddit server, authenticated with the user's client ID and client secret.\n* @desc **Note**: This is used internally as part of the authentication process, but it cannot be used to actually fetch\ncontent from reddit. To do that, use {@link snoowrap#oauthRequest} or another of snoowrap's helper functions.\n*\n* This function can work with alternate `this`-bindings, provided that the binding has the `clientId`, `clientSecret`, and\n`userAgent` properties. This allows it be used if no snoowrap requester has been created yet.\n* @param {object|string} options Options for the request; these are passed directly to the\n[Request API](https://www.npmjs.com/package/request).\n* @returns {Promise} The response from the reddit server\n* @example\n*\n* // example: this function could be used to exchange a one-time authentication code for a refresh token.\nsnoowrap.prototype.credentialedClientRequest.call({\n  clientId: 'client id goes here',\n  clientSecret: 'client secret goes here',\n  userAgent: 'user agent goes here'\n}, {\n  method: 'post',\n  baseUrl: 'https://www.reddit.com',\n  uri: 'api/v1/access_token',\n  form: {grant_type: 'authorization_code', code: 'code goes here', redirect_uri: 'redirect uri goes here'}\n}).then(response => {\n  //handle response here\n})\n* @memberof snoowrap\n* @instance\n*/\n\n\nfunction credentialedClientRequest(options) {\n  var requestFunc = this.rawRequest || rawRequest;\n  return _Promise.default.resolve(requestFunc.call(this, (0, _lodash.merge)({\n    json: true,\n    auth: {\n      user: this.clientId || this.client_id || '',\n      pass: this.clientSecret || this.client_secret || ''\n    },\n    headers: {\n      'user-agent': this.userAgent\n    },\n    baseUrl: this._config ? \"https://www.\".concat(this._config.endpointDomain) : undefined\n  }, options)));\n}\n/**\n* @summary Sends a request to the reddit server without authentication.\n* @param {object|string} options Options for the request; these are passed directly to the\n[Request API](https://www.npmjs.com/package/request).\n* @returns {Promise} The response from the reddit server\n* @memberof snoowrap\n* @instance\n*/\n\n\nfunction unauthenticatedRequest(options) {\n  return _Promise.default.resolve(this.rawRequest((0, _lodash.merge)({\n    json: true,\n    headers: {\n      'user-agent': this.userAgent\n    },\n    baseUrl: \"https://www.\".concat(this._config.endpointDomain)\n  }, options)));\n}\n/**\n* @summary Updates this requester's access token if the current one is absent or expired.\n* @desc **Note**: This function is automatically called internally when making a request. While the function is exposed as\na stable feature, using it is rarely necessary unless an access token is needed for some external purpose.\n* @returns {Promise} A Promise that fulfills with the access token when this request is complete\n* @memberof snoowrap\n* @instance\n* @example r.updateAccessToken()\n*/\n\n\nfunction updateAccessToken() {\n  var _this2 = this;\n\n  // If the current access token is missing or expired, and it is possible to get a new one, do so.\n  if ((!this.accessToken || Date.now() > this.tokenExpiration) && (this.refreshToken || this.username && this.password)) {\n    return this.credentialedClientRequest({\n      method: 'post',\n      uri: 'api/v1/access_token',\n      form: this.refreshToken ? {\n        grant_type: 'refresh_token',\n        refresh_token: this.refreshToken\n      } : {\n        grant_type: 'password',\n        username: this.username,\n        password: this.password\n      }\n    }).then(function (tokenInfo) {\n      _this2.accessToken = tokenInfo.access_token;\n      _this2.tokenExpiration = Date.now() + tokenInfo.expires_in * 1000;\n\n      if (tokenInfo.error === 'invalid_grant') {\n        throw new Error('\"Invalid grant\" error returned from reddit. (You might have incorrect credentials.)');\n      } else if (tokenInfo.error_description !== undefined) {\n        throw new Error(\"Reddit returned an error: \".concat(tokenInfo.error, \": \").concat(tokenInfo.error_description));\n      } else if (tokenInfo.error !== undefined) {\n        throw new Error(\"Reddit returned an error: \".concat(tokenInfo.error));\n      }\n\n      _this2.scope = tokenInfo.scope.split(' ');\n      return _this2.accessToken;\n    });\n  } // Otherwise, just return the existing token.\n\n\n  return _Promise.default.resolve(this.accessToken);\n}\n/**\n* @function\n* @name rawRequest\n* @summary Sends an HTTP request\n* @desc **Note**: This function is called internally whenever snoowrap makes a request. You generally should not call this\n* function directly; use {@link snoowrap#oauthRequest} or another snoowrap function instead.\n*\n* This method allows snoowrap's request behavior to be customized via subclassing. If you create a snoowrap subclass and shadow\n* this method, all requests from snoowrap will pass through it.\n*\n* To ensure that all other snoowrap methods work correctly, the API for a shadowed version of this method must match the API for\n* the original `makeRequest` method. This method is based on the API of the\n* [request-promise](https://www.npmjs.com/package/request-promise) library, so if you do create a subclass, it might be helpful\n* to use `request-promise` internally. This will ensure that the API works correctly, so that you don't have to reimplement this\n* function's API from scratch.\n*\n* @param {object} options Options for the request\n* @param {boolean} options.json If `true`, the `Content-Type: application/json` header is added, and the response body will be\n* parsed as JSON automatically.\n* @param {string} options.baseUrl The base URL that a request should be sent to\n* @param {string} options.uri The uri that a request should be sent to, using the provided `baseUrl`.\n* @param {string} options.method='GET' Method for the request\n* @param {object} options.headers Headers for the request\n* @param {object} [options.qs] Querystring parameters for the request\n* @param {object} [options.form] Form data for the request. If provided, the `Content-Type: application/x-www-form-urlencoded`\n* header is set, and the provided object is serialized into URL-encoded form data in the request body.\n* @param {object} [options.formData] Multipart form data for the request. If provided, the `Content-Type: multipart/form-data`\n* header is set, and the provided object is serialized as multipart form data.\n* @param {object} [options.body] The body of the request. Should be converted to a string with JSON.stringify(). This is ignored\n* for GET requests, or of `options.form` or `options.formData` are provided.\n* @param {Function} [options.transform] A function that is called before the response Promise fulfills. Accepts two parameters:\n* `response.body` and `response`. This function should be called regardless of the status code of the response, and the returned\n* Promise from `makeRequest` should fulfill with its return value.\n* @param {boolean} [options.resolveWithFullResponse=false] If `true`, a Promise for the entire response is returned. If `false`,\n* a Promise for only the response body is returned. This is ignored if an `options.transform` function is provided.\n* @returns {Promise} A Promise for a response object. Depending on `options.transform` and `options.resolveWithFullResponse`,\n* the Promise should settle with either the response object itself, the body of the response, or the value returned by\n* `options.transform`. The Promise should be fulfilled if the status code is between 200 and 299, inclusive, and reject\n* otherwise. (If a redirect is returned from the server, the function should follow the redirect if possible, otherwise reject\n* with an error.) A response object has 4 properties: `statusCode` (number) the status code of the response, `body` (object)\n* the body of the response, `headers` (object) the parsed response headers, and `request` (object) an object of the form\n* `{method: 'GET', uri: {href: 'https://oauth.reddit.com/full/url'}}` representing information about the original request.\n* @memberof snoowrap\n* @instance\n* @example\n*\n* const snoowrap = require('snoowrap');\n*\n* class SnoowrapSubclass extends snoowrap {\n*   rawRequest(options) {\n*     // do custom behavior with `options` if you want, then call the regular rawRequest function\n*     console.log(`made a request with options:`);\n*     console.log(options);\n*     return super.rawRequest(options)\n*   }\n* }\n*\n* const request = require('request-promise');\n*\n* class AnotherSnoowrapSubclass extends snoowrap {\n*   rawRequest(options) {\n*     // send all requests through a proxy\n*     return request(Object.assign(options, {proxy: 'https://example.com'}))\n*   }\n* }\n*/\n\n\nvar rawRequest = typeof XMLHttpRequest !== 'undefined' ? __webpack_require__(/*! ./xhr */ \"(rsc)/./node_modules/snoowrap/dist/xhr.js\") : (__webpack_require__(/*! request-promise */ \"(rsc)/./node_modules/request-promise/lib/rp.js\").defaults)({\n  gzip: true\n});\nexports.rawRequest = rawRequest;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9yZXF1ZXN0X2hhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CO0FBQ3BCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLGtCQUFrQjs7QUFFbEIsY0FBYyxtQkFBTyxDQUFDLHFEQUFROztBQUU5QixzQ0FBc0MsbUJBQU8sQ0FBQyxtRUFBYzs7QUFFNUQsaUJBQWlCLG1CQUFPLENBQUMsdUVBQWdCOztBQUV6QyxjQUFjLG1CQUFPLENBQUMsaUVBQWE7O0FBRW5DLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLG1DQUFtQzs7QUFFbkMsZ0NBQWdDOztBQUVoQyxrQ0FBa0M7O0FBRWxDLG1DQUFtQywwQkFBMEIsOENBQThDLGdCQUFnQixPQUFPLG9CQUFvQjs7QUFFdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw2QkFBNkI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUNBQXVDO0FBQ3pELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDLHlCQUF5QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQyxVQUFVO0FBQzdEO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlLGlDQUFpQztBQUMxRDtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWUsaUNBQWlDO0FBQzFEO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQjtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQiwyQ0FBMkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBOzs7QUFHQSx5REFBeUQsbUJBQU8sQ0FBQyx3REFBTyxJQUFJLHVHQUFtQztBQUMvRztBQUNBLENBQUM7QUFDRCxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9yZXF1ZXN0X2hhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm9hdXRoUmVxdWVzdCA9IG9hdXRoUmVxdWVzdDtcbmV4cG9ydHMuX2F3YWl0RXhwb25lbnRpYWxCYWNrb2ZmID0gX2F3YWl0RXhwb25lbnRpYWxCYWNrb2ZmO1xuZXhwb3J0cy5fYXdhaXRSYXRlbGltaXQgPSBfYXdhaXRSYXRlbGltaXQ7XG5leHBvcnRzLl9hd2FpdFJlcXVlc3REZWxheSA9IF9hd2FpdFJlcXVlc3REZWxheTtcbmV4cG9ydHMuY3JlZGVudGlhbGVkQ2xpZW50UmVxdWVzdCA9IGNyZWRlbnRpYWxlZENsaWVudFJlcXVlc3Q7XG5leHBvcnRzLnVuYXV0aGVudGljYXRlZFJlcXVlc3QgPSB1bmF1dGhlbnRpY2F0ZWRSZXF1ZXN0O1xuZXhwb3J0cy51cGRhdGVBY2Nlc3NUb2tlbiA9IHVwZGF0ZUFjY2Vzc1Rva2VuO1xuZXhwb3J0cy5yYXdSZXF1ZXN0ID0gdm9pZCAwO1xuXG52YXIgX2xvZGFzaCA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5cbnZhciBfUHJvbWlzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUHJvbWlzZS5qc1wiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuXG52YXIgX2Vycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cblxuLyoqXG4qIEBzdW1tYXJ5IFNlbmRzIGFuIG9hdXRoLWF1dGhlbnRpY2F0ZWQgcmVxdWVzdCB0byB0aGUgcmVkZGl0IHNlcnZlciwgYW5kIHJldHVybnMgdGhlIHNlcnZlcidzIHJlc3BvbnNlLlxuKiBAZGVzYyAqKk5vdGUqKjogV2hpbGUgdGhpcyBmdW5jdGlvbiBwcmltYXJpbHkgZXhpc3RzIGZvciBpbnRlcm5hbCB1c2UsIGl0IGlzIGV4cG9zZWQgYW5kIGNvbnNpZGVyZWQgYSBzdGFibGUgZmVhdHVyZS5cbkhvd2V2ZXIsIGtlZXAgaW4gbWluZCB0aGF0IHRoZXJlIGFyZSB1c3VhbGx5IGJldHRlciBhbHRlcm5hdGl2ZXMgdG8gdXNpbmcgdGhpcyBmdW5jdGlvbi4gRm9yIGluc3RhbmNlLCB0aGlzXG5mdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBzZW5kIGEgUE9TVCByZXF1ZXN0IHRvIHRoZSAnYXBpL3ZvdGUnIGVuZHBvaW50IGluIG9yZGVyIHRvIHVwdm90ZSBhIGNvbW1lbnQsIGJ1dCBpdCdzIGdlbmVyYWxseVxuZWFzaWVyIHRvIGp1c3QgdXNlIHNub293cmFwJ3MgW3Vwdm90ZSBmdW5jdGlvbl17QGxpbmsgVm90ZWFibGVDb250ZW50I3Vwdm90ZX0uXG4qXG4qIElmIHlvdSdyZSB1c2luZyB0aGlzIGZ1bmN0aW9uIHRvIGFjY2VzcyBhbiBBUEkgZmVhdHVyZS9lbmRwb2ludCB0aGF0IGlzIHVuc3VwcG9ydGVkIGJ5IHNub293cmFwLCBwbGVhc2UgY29uc2lkZXIgW2NyZWF0aW5nIGFuXG5pc3N1ZSBmb3IgaXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9ub3QtYW4tYWFyZHZhcmsvc25vb3dyYXAvaXNzdWVzKSBzbyB0aGF0IHRoZSBmdW5jdGlvbmFsaXR5IGNhbiBiZSBhZGRlZCB0byBzbm9vd3JhcCBtb3JlXG5kaXJlY3RseS5cbiogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIEZvciBkb2N1bWVudGF0aW9uIG9uIHRoZXNlIG9wdGlvbnMsIHNlZSB0aGVcbltSZXF1ZXN0IEFQSV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVxdWVzdCkuIFN1cHBvcnRlZCBvcHRpb25zIGluY2x1ZGUgYHVyaWAsIGBxc2AsIGBmb3JtYCwgYGhlYWRlcnNgLCBgbWV0aG9kYCxcbmBhdXRoYCwgYW5kIGBib2R5YC4gQSBkZWZhdWx0IGBiYXNlVXJsYCBwYXJhbWV0ZXIgb2YgYHRoaXMuY29uZmlnKCkuZW5kcG9pbnRfZG9tYWluYCBpcyBpbnRlcm5hbGx5IGluY2x1ZGVkIGJ5IGRlZmF1bHQsIHNvIGl0XG5pcyByZWNvbW1lbmRlZCB0aGF0IGEgYHVyaWAgcGFyYW1ldGVyIGJlIHVzZWQsIHJhdGhlciB0aGFuIGEgYHVybGAgcGFyYW1ldGVyIHdpdGggYVxuZG9tYWluIG5hbWUuXG4qIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHJlZGRpdCdzIHJlc3BvbnNlLlxuKiBAbWVtYmVyb2Ygc25vb3dyYXBcbiogQGluc3RhbmNlXG4qIEBleGFtcGxlXG4qXG4qIHIub2F1dGhSZXF1ZXN0KHt1cmk6ICcvdXNlci9zcGV6L2Fib3V0JywgbWV0aG9kOiAnZ2V0J30pLnRoZW4oY29uc29sZS5sb2cpXG4qIC8vID0+IFJlZGRpdFVzZXIgeyBuYW1lOiAnc3BleicsIGxpbmtfa2FybWE6IDk1NjcsIC4uLiB9XG4qXG4qIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGVxdWl2YWxlbnQgdG86XG4qIHIuZ2V0VXNlcignc3BleicpLmZldGNoKCkudGhlbihjb25zb2xlLmxvZylcbipcbiogLy8gIyMjIyMjXG4qXG4qIHIub2F1dGhSZXF1ZXN0KHt1cmk6ICcvYXBpL3ZvdGUnLCBtZXRob2Q6ICdwb3N0JywgZm9ybToge2RpcjogMSwgaWQ6ICd0M180ZnpnMmsnfX0pXG4qIC8vIGVxdWl2YWxlbnQgdG86XG4qIHIuZ2V0U3VibWlzc2lvbignNGZ6ZzJrJykudXB2b3RlKClcbipcbiogLy8gIyMjIyMjXG4qXG4qIHIub2F1dGhSZXF1ZXN0KHt1cmk6ICcvdG9wJywgbWV0aG9kOiAnZ2V0JywgcXM6IHt0OiAnYWxsJ319KVxuKiAvLyBlcXVpdmFsZW50IHRvOlxuKiByLmdldFRvcCh7dGltZTogJ2FsbCd9KVxuKi9cbmZ1bmN0aW9uIG9hdXRoUmVxdWVzdChvcHRpb25zKSB7XG4gIHZhciBfUHJvbWlzZSRyZXNvbHZlJHRoZW4sXG4gICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIGF0dGVtcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICByZXR1cm4gKF9Qcm9taXNlJHJlc29sdmUkdGhlbiA9IF9Qcm9taXNlLmRlZmF1bHQucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5fYXdhaXRSYXRlbGltaXQoKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzLl9hd2FpdFJlcXVlc3REZWxheSgpO1xuICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2F3YWl0RXhwb25lbnRpYWxCYWNrb2ZmKGF0dGVtcHRzKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFjY2Vzc1Rva2VuKCk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIF90aGlzLnJhd1JlcXVlc3QoKDAsIF9sb2Rhc2gubWVyZ2UpKHtcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICd1c2VyLWFnZW50JzogX3RoaXMudXNlckFnZW50XG4gICAgICB9LFxuICAgICAgYmFzZVVybDogXCJodHRwczovL29hdXRoLlwiLmNvbmNhdChfdGhpcy5fY29uZmlnLmVuZHBvaW50RG9tYWluKSxcbiAgICAgIHFzOiB7XG4gICAgICAgIHJhd19qc29uOiAxXG4gICAgICB9LFxuICAgICAgYXV0aDoge1xuICAgICAgICBiZWFyZXI6IHRva2VuXG4gICAgICB9LFxuICAgICAgcmVzb2x2ZVdpdGhGdWxsUmVzcG9uc2U6IHRydWUsXG4gICAgICB0aW1lb3V0OiBfdGhpcy5fY29uZmlnLnJlcXVlc3RUaW1lb3V0LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoYm9keSwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXNwb25zZS5oZWFkZXJzLCAneC1yYXRlbGltaXQtcmVtYWluaW5nJykpIHtcbiAgICAgICAgICBfdGhpcy5yYXRlbGltaXRSZW1haW5pbmcgPSArcmVzcG9uc2UuaGVhZGVyc1sneC1yYXRlbGltaXQtcmVtYWluaW5nJ107XG4gICAgICAgICAgX3RoaXMucmF0ZWxpbWl0RXhwaXJhdGlvbiA9IERhdGUubm93KCkgKyByZXNwb25zZS5oZWFkZXJzWyd4LXJhdGVsaW1pdC1yZXNldCddICogMTAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9kZWJ1ZyhcIlJlY2VpdmVkIGEgXCIuY29uY2F0KHJlc3BvbnNlLnN0YXR1c0NvZGUsIFwiIHN0YXR1cyBjb2RlIGZyb20gYSBgXCIpLmNvbmNhdChyZXNwb25zZS5yZXF1ZXN0Lm1ldGhvZCwgXCJgIHJlcXVlc3RcIiksIFwic2VudCB0byBcIi5jb25jYXQocmVzcG9uc2UucmVxdWVzdC51cmkuaHJlZiwgXCIuIHJhdGVsaW1pdFJlbWFpbmluZzogXCIpLmNvbmNhdChfdGhpcy5yYXRlbGltaXRSZW1haW5pbmcpKTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucykpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHZhciBwb3B1bGF0ZWQgPSBfdGhpcy5fcG9wdWxhdGUocmVzcG9uc2UuYm9keSk7XG5cbiAgICBpZiAocG9wdWxhdGVkICYmIHBvcHVsYXRlZC5jb25zdHJ1Y3Rvci5fbmFtZSA9PT0gJ0xpc3RpbmcnKSB7XG4gICAgICBwb3B1bGF0ZWQuX3NldFVyaShyZXNwb25zZS5yZXF1ZXN0LnVyaS5ocmVmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9wdWxhdGVkO1xuICB9KSkuY2F0Y2guYXBwbHkoX1Byb21pc2UkcmVzb2x2ZSR0aGVuLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fY29uZmlnLnJldHJ5RXJyb3JDb2Rlcy5tYXAoZnVuY3Rpb24gKHJldHJ5Q29kZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXNDb2RlOiByZXRyeUNvZGVcbiAgICB9O1xuICB9KSkuY29uY2F0KFtmdW5jdGlvbiAoZSkge1xuICAgIGlmICghKDAsIF9sb2Rhc2guaW5jbHVkZXMpKF9jb25zdGFudHMuSURFTVBPVEVOVF9IVFRQX1ZFUkJTLCBlLnJlc3BvbnNlLnJlcXVlc3QubWV0aG9kKSB8fCBhdHRlbXB0cyA+PSBfdGhpcy5fY29uZmlnLm1heFJldHJ5QXR0ZW1wdHMpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIC8qIElmIHRoZSBlcnJvcidzIHN0YXR1cyBjb2RlIGlzIGluIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgcmV0cnlTdGF0dXNDb2Rlc2AgYW5kIHRoaXMgcmVxdWVzdCBzdGlsbCBoYXMgYXR0ZW1wdHNcbiAgICByZW1haW5pbmcsIHJldHJ5IHRoaXMgcmVxdWVzdCBhbmQgaW5jcmVtZW50IHRoZSBgYXR0ZW1wdHNgIGNvdW50ZXIuICovXG5cblxuICAgIF90aGlzLl93YXJuKFwiUmVjZWl2ZWQgc3RhdHVzIGNvZGUgXCIuY29uY2F0KGUuc3RhdHVzQ29kZSwgXCIgZnJvbSByZWRkaXQuXCIpLCBcIlJldHJ5aW5nIHJlcXVlc3QgKGF0dGVtcHQgXCIuY29uY2F0KGF0dGVtcHRzICsgMSwgXCIvXCIpLmNvbmNhdChfdGhpcy5fY29uZmlnLm1heFJldHJ5QXR0ZW1wdHMsIFwiKS4uLlwiKSk7XG5cbiAgICByZXR1cm4gX3RoaXMub2F1dGhSZXF1ZXN0KG9wdGlvbnMsIGF0dGVtcHRzICsgMSk7XG4gIH1dKSkuY2F0Y2goe1xuICAgIHN0YXR1c0NvZGU6IDQwMVxuICB9LCBmdW5jdGlvbiAoZSkge1xuICAgIC8qIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhIDQwMSBlcnJvciwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBhY2Nlc3MgdG9rZW4gZXhwaXJlZCBkdXJpbmcgdGhlIGxhdGVuY3kgcGVyaW9kIGFzIHRoaXNcbiAgICByZXF1ZXN0IHdhcyBiZWluZyBzZW50LiBJbiB0aGlzIHNjZW5hcmlvLCBzbm9vd3JhcCB0aG91Z2h0IHRoYXQgdGhlIGFjY2VzcyB0b2tlbiB3YXMgdmFsaWQgZm9yIGEgZmV3IG1vcmUgc2Vjb25kcywgc28gaXRcbiAgICBkaWRuJ3QgcmVmcmVzaCB0aGUgdG9rZW4sIGJ1dCB0aGUgdG9rZW4gaGFkIGV4cGlyZWQgYnkgdGhlIHRpbWUgdGhlIHJlcXVlc3QgcmVhY2hlZCB0aGUgc2VydmVyLiBUbyBoYW5kbGUgdGhpcyBpc3N1ZSxcbiAgICBpbnZhbGlkYXRlIHRoZSBhY2Nlc3MgdG9rZW4gYW5kIGNhbGwgb2F1dGhfcmVxdWVzdCBhZ2FpbiwgYXV0b21hdGljYWxseSBjYXVzaW5nIHRoZSB0b2tlbiB0byBiZSByZWZyZXNoZWQuICovXG4gICAgaWYgKF90aGlzLmFjY2Vzc1Rva2VuICYmIF90aGlzLnRva2VuRXhwaXJhdGlvbiAtIERhdGUubm93KCkgPCBfY29uc3RhbnRzLk1BWF9UT0tFTl9MQVRFTkNZKSB7XG4gICAgICBfdGhpcy5hY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICBfdGhpcy50b2tlbkV4cGlyYXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzLm9hdXRoUmVxdWVzdChvcHRpb25zLCBhdHRlbXB0cyk7XG4gICAgfVxuXG4gICAgdGhyb3cgZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9hd2FpdEV4cG9uZW50aWFsQmFja29mZihhdHRlbXB0cykge1xuICBpZiAoYXR0ZW1wdHMgPT09IDEpIHtcbiAgICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5yZXNvbHZlKCk7XG4gIH1cblxuICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5kZWxheSgoTWF0aC5wb3coMiwgYXR0ZW1wdHMgLSAxKSArIChNYXRoLnJhbmRvbSgpIC0gMC4zKSkgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gX2F3YWl0UmF0ZWxpbWl0KCkge1xuICBpZiAodGhpcy5yYXRlbGltaXRSZW1haW5pbmcgPCAxICYmIERhdGUubm93KCkgPCB0aGlzLnJhdGVsaW1pdEV4cGlyYXRpb24pIHtcbiAgICAvLyBJZiB0aGUgcmF0ZWxpbWl0IGhhcyBiZWVuIGV4Y2VlZGVkLCBkZWxheSBvciBhYm9ydCB0aGUgcmVxdWVzdCBkZXBlbmRpbmcgb24gdGhlIHVzZXIncyBjb25maWcuXG4gICAgdmFyIHRpbWVVbnRpbEV4cGlyeSA9IHRoaXMucmF0ZWxpbWl0RXhwaXJhdGlvbiAtIERhdGUubm93KCk7XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmNvbnRpbnVlQWZ0ZXJSYXRlbGltaXRFcnJvcikge1xuICAgICAgLyogSWYgdGhlIGBjb250aW51ZV9hZnRlcl9yYXRlbGltaXRfZXJyb3JgIHNldHRpbmcgaXMgZW5hYmxlZCwgcXVldWUgdGhlIHJlcXVlc3QsIHdhaXQgdW50aWwgdGhlIG5leHQgcmF0ZWxpbWl0XG4gICAgICBwZXJpb2QsIGFuZCB0aGVuIHNlbmQgaXQuICovXG4gICAgICB0aGlzLl93YXJuKCgwLCBfZXJyb3JzLnJhdGVMaW1pdFdhcm5pbmcpKHRpbWVVbnRpbEV4cGlyeSkpO1xuXG4gICAgICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5kZWxheSh0aW1lVW50aWxFeHBpcnkpO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuXG4gICAgdGhyb3cgbmV3IF9lcnJvcnMuUmF0ZUxpbWl0RXJyb3IodGltZVVudGlsRXhwaXJ5KTtcbiAgfSAvLyBJZiB0aGUgcmF0ZWxpbWl0IGhhc24ndCBiZWVuIGV4Y2VlZGVkLCBubyBkZWxheSBpcyBuZWNlc3NhcnkuXG5cblxuICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5yZXNvbHZlKCk7XG59XG5cbmZ1bmN0aW9uIF9hd2FpdFJlcXVlc3REZWxheSgpIHtcbiAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gIHZhciB3YWl0VGltZSA9IHRoaXMuX25leHRSZXF1ZXN0VGltZXN0YW1wIC0gbm93O1xuICB0aGlzLl9uZXh0UmVxdWVzdFRpbWVzdGFtcCA9IE1hdGgubWF4KG5vdywgdGhpcy5fbmV4dFJlcXVlc3RUaW1lc3RhbXApICsgdGhpcy5fY29uZmlnLnJlcXVlc3REZWxheTtcbiAgcmV0dXJuIF9Qcm9taXNlLmRlZmF1bHQuZGVsYXkod2FpdFRpbWUpO1xufVxuLyoqXG4qIEBzdW1tYXJ5IFNlbmRzIGEgcmVxdWVzdCB0byB0aGUgcmVkZGl0IHNlcnZlciwgYXV0aGVudGljYXRlZCB3aXRoIHRoZSB1c2VyJ3MgY2xpZW50IElEIGFuZCBjbGllbnQgc2VjcmV0LlxuKiBAZGVzYyAqKk5vdGUqKjogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYXMgcGFydCBvZiB0aGUgYXV0aGVudGljYXRpb24gcHJvY2VzcywgYnV0IGl0IGNhbm5vdCBiZSB1c2VkIHRvIGFjdHVhbGx5IGZldGNoXG5jb250ZW50IGZyb20gcmVkZGl0LiBUbyBkbyB0aGF0LCB1c2Uge0BsaW5rIHNub293cmFwI29hdXRoUmVxdWVzdH0gb3IgYW5vdGhlciBvZiBzbm9vd3JhcCdzIGhlbHBlciBmdW5jdGlvbnMuXG4qXG4qIFRoaXMgZnVuY3Rpb24gY2FuIHdvcmsgd2l0aCBhbHRlcm5hdGUgYHRoaXNgLWJpbmRpbmdzLCBwcm92aWRlZCB0aGF0IHRoZSBiaW5kaW5nIGhhcyB0aGUgYGNsaWVudElkYCwgYGNsaWVudFNlY3JldGAsIGFuZFxuYHVzZXJBZ2VudGAgcHJvcGVydGllcy4gVGhpcyBhbGxvd3MgaXQgYmUgdXNlZCBpZiBubyBzbm9vd3JhcCByZXF1ZXN0ZXIgaGFzIGJlZW4gY3JlYXRlZCB5ZXQuXG4qIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgcmVxdWVzdDsgdGhlc2UgYXJlIHBhc3NlZCBkaXJlY3RseSB0byB0aGVcbltSZXF1ZXN0IEFQSV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVxdWVzdCkuXG4qIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgcmVkZGl0IHNlcnZlclxuKiBAZXhhbXBsZVxuKlxuKiAvLyBleGFtcGxlOiB0aGlzIGZ1bmN0aW9uIGNvdWxkIGJlIHVzZWQgdG8gZXhjaGFuZ2UgYSBvbmUtdGltZSBhdXRoZW50aWNhdGlvbiBjb2RlIGZvciBhIHJlZnJlc2ggdG9rZW4uXG5zbm9vd3JhcC5wcm90b3R5cGUuY3JlZGVudGlhbGVkQ2xpZW50UmVxdWVzdC5jYWxsKHtcbiAgY2xpZW50SWQ6ICdjbGllbnQgaWQgZ29lcyBoZXJlJyxcbiAgY2xpZW50U2VjcmV0OiAnY2xpZW50IHNlY3JldCBnb2VzIGhlcmUnLFxuICB1c2VyQWdlbnQ6ICd1c2VyIGFnZW50IGdvZXMgaGVyZSdcbn0sIHtcbiAgbWV0aG9kOiAncG9zdCcsXG4gIGJhc2VVcmw6ICdodHRwczovL3d3dy5yZWRkaXQuY29tJyxcbiAgdXJpOiAnYXBpL3YxL2FjY2Vzc190b2tlbicsXG4gIGZvcm06IHtncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJywgY29kZTogJ2NvZGUgZ29lcyBoZXJlJywgcmVkaXJlY3RfdXJpOiAncmVkaXJlY3QgdXJpIGdvZXMgaGVyZSd9XG59KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgLy9oYW5kbGUgcmVzcG9uc2UgaGVyZVxufSlcbiogQG1lbWJlcm9mIHNub293cmFwXG4qIEBpbnN0YW5jZVxuKi9cblxuXG5mdW5jdGlvbiBjcmVkZW50aWFsZWRDbGllbnRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgdmFyIHJlcXVlc3RGdW5jID0gdGhpcy5yYXdSZXF1ZXN0IHx8IHJhd1JlcXVlc3Q7XG4gIHJldHVybiBfUHJvbWlzZS5kZWZhdWx0LnJlc29sdmUocmVxdWVzdEZ1bmMuY2FsbCh0aGlzLCAoMCwgX2xvZGFzaC5tZXJnZSkoe1xuICAgIGpzb246IHRydWUsXG4gICAgYXV0aDoge1xuICAgICAgdXNlcjogdGhpcy5jbGllbnRJZCB8fCB0aGlzLmNsaWVudF9pZCB8fCAnJyxcbiAgICAgIHBhc3M6IHRoaXMuY2xpZW50U2VjcmV0IHx8IHRoaXMuY2xpZW50X3NlY3JldCB8fCAnJ1xuICAgIH0sXG4gICAgaGVhZGVyczoge1xuICAgICAgJ3VzZXItYWdlbnQnOiB0aGlzLnVzZXJBZ2VudFxuICAgIH0sXG4gICAgYmFzZVVybDogdGhpcy5fY29uZmlnID8gXCJodHRwczovL3d3dy5cIi5jb25jYXQodGhpcy5fY29uZmlnLmVuZHBvaW50RG9tYWluKSA6IHVuZGVmaW5lZFxuICB9LCBvcHRpb25zKSkpO1xufVxuLyoqXG4qIEBzdW1tYXJ5IFNlbmRzIGEgcmVxdWVzdCB0byB0aGUgcmVkZGl0IHNlcnZlciB3aXRob3V0IGF1dGhlbnRpY2F0aW9uLlxuKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHJlcXVlc3Q7IHRoZXNlIGFyZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlXG5bUmVxdWVzdCBBUEldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3JlcXVlc3QpLlxuKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHJlc3BvbnNlIGZyb20gdGhlIHJlZGRpdCBzZXJ2ZXJcbiogQG1lbWJlcm9mIHNub293cmFwXG4qIEBpbnN0YW5jZVxuKi9cblxuXG5mdW5jdGlvbiB1bmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9Qcm9taXNlLmRlZmF1bHQucmVzb2x2ZSh0aGlzLnJhd1JlcXVlc3QoKDAsIF9sb2Rhc2gubWVyZ2UpKHtcbiAgICBqc29uOiB0cnVlLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICd1c2VyLWFnZW50JzogdGhpcy51c2VyQWdlbnRcbiAgICB9LFxuICAgIGJhc2VVcmw6IFwiaHR0cHM6Ly93d3cuXCIuY29uY2F0KHRoaXMuX2NvbmZpZy5lbmRwb2ludERvbWFpbilcbiAgfSwgb3B0aW9ucykpKTtcbn1cbi8qKlxuKiBAc3VtbWFyeSBVcGRhdGVzIHRoaXMgcmVxdWVzdGVyJ3MgYWNjZXNzIHRva2VuIGlmIHRoZSBjdXJyZW50IG9uZSBpcyBhYnNlbnQgb3IgZXhwaXJlZC5cbiogQGRlc2MgKipOb3RlKio6IFRoaXMgZnVuY3Rpb24gaXMgYXV0b21hdGljYWxseSBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIG1ha2luZyBhIHJlcXVlc3QuIFdoaWxlIHRoZSBmdW5jdGlvbiBpcyBleHBvc2VkIGFzXG5hIHN0YWJsZSBmZWF0dXJlLCB1c2luZyBpdCBpcyByYXJlbHkgbmVjZXNzYXJ5IHVubGVzcyBhbiBhY2Nlc3MgdG9rZW4gaXMgbmVlZGVkIGZvciBzb21lIGV4dGVybmFsIHB1cnBvc2UuXG4qIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4gd2hlbiB0aGlzIHJlcXVlc3QgaXMgY29tcGxldGVcbiogQG1lbWJlcm9mIHNub293cmFwXG4qIEBpbnN0YW5jZVxuKiBAZXhhbXBsZSByLnVwZGF0ZUFjY2Vzc1Rva2VuKClcbiovXG5cblxuZnVuY3Rpb24gdXBkYXRlQWNjZXNzVG9rZW4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIElmIHRoZSBjdXJyZW50IGFjY2VzcyB0b2tlbiBpcyBtaXNzaW5nIG9yIGV4cGlyZWQsIGFuZCBpdCBpcyBwb3NzaWJsZSB0byBnZXQgYSBuZXcgb25lLCBkbyBzby5cbiAgaWYgKCghdGhpcy5hY2Nlc3NUb2tlbiB8fCBEYXRlLm5vdygpID4gdGhpcy50b2tlbkV4cGlyYXRpb24pICYmICh0aGlzLnJlZnJlc2hUb2tlbiB8fCB0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlZGVudGlhbGVkQ2xpZW50UmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgIHVyaTogJ2FwaS92MS9hY2Nlc3NfdG9rZW4nLFxuICAgICAgZm9ybTogdGhpcy5yZWZyZXNoVG9rZW4gPyB7XG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogdGhpcy5yZWZyZXNoVG9rZW5cbiAgICAgIH0gOiB7XG4gICAgICAgIGdyYW50X3R5cGU6ICdwYXNzd29yZCcsXG4gICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgICBwYXNzd29yZDogdGhpcy5wYXNzd29yZFxuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHRva2VuSW5mbykge1xuICAgICAgX3RoaXMyLmFjY2Vzc1Rva2VuID0gdG9rZW5JbmZvLmFjY2Vzc190b2tlbjtcbiAgICAgIF90aGlzMi50b2tlbkV4cGlyYXRpb24gPSBEYXRlLm5vdygpICsgdG9rZW5JbmZvLmV4cGlyZXNfaW4gKiAxMDAwO1xuXG4gICAgICBpZiAodG9rZW5JbmZvLmVycm9yID09PSAnaW52YWxpZF9ncmFudCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkludmFsaWQgZ3JhbnRcIiBlcnJvciByZXR1cm5lZCBmcm9tIHJlZGRpdC4gKFlvdSBtaWdodCBoYXZlIGluY29ycmVjdCBjcmVkZW50aWFscy4pJyk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuSW5mby5lcnJvcl9kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZGRpdCByZXR1cm5lZCBhbiBlcnJvcjogXCIuY29uY2F0KHRva2VuSW5mby5lcnJvciwgXCI6IFwiKS5jb25jYXQodG9rZW5JbmZvLmVycm9yX2Rlc2NyaXB0aW9uKSk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuSW5mby5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZGRpdCByZXR1cm5lZCBhbiBlcnJvcjogXCIuY29uY2F0KHRva2VuSW5mby5lcnJvcikpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczIuc2NvcGUgPSB0b2tlbkluZm8uc2NvcGUuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBfdGhpczIuYWNjZXNzVG9rZW47XG4gICAgfSk7XG4gIH0gLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiB0aGUgZXhpc3RpbmcgdG9rZW4uXG5cblxuICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5yZXNvbHZlKHRoaXMuYWNjZXNzVG9rZW4pO1xufVxuLyoqXG4qIEBmdW5jdGlvblxuKiBAbmFtZSByYXdSZXF1ZXN0XG4qIEBzdW1tYXJ5IFNlbmRzIGFuIEhUVFAgcmVxdWVzdFxuKiBAZGVzYyAqKk5vdGUqKjogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW50ZXJuYWxseSB3aGVuZXZlciBzbm9vd3JhcCBtYWtlcyBhIHJlcXVlc3QuIFlvdSBnZW5lcmFsbHkgc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiogZnVuY3Rpb24gZGlyZWN0bHk7IHVzZSB7QGxpbmsgc25vb3dyYXAjb2F1dGhSZXF1ZXN0fSBvciBhbm90aGVyIHNub293cmFwIGZ1bmN0aW9uIGluc3RlYWQuXG4qXG4qIFRoaXMgbWV0aG9kIGFsbG93cyBzbm9vd3JhcCdzIHJlcXVlc3QgYmVoYXZpb3IgdG8gYmUgY3VzdG9taXplZCB2aWEgc3ViY2xhc3NpbmcuIElmIHlvdSBjcmVhdGUgYSBzbm9vd3JhcCBzdWJjbGFzcyBhbmQgc2hhZG93XG4qIHRoaXMgbWV0aG9kLCBhbGwgcmVxdWVzdHMgZnJvbSBzbm9vd3JhcCB3aWxsIHBhc3MgdGhyb3VnaCBpdC5cbipcbiogVG8gZW5zdXJlIHRoYXQgYWxsIG90aGVyIHNub293cmFwIG1ldGhvZHMgd29yayBjb3JyZWN0bHksIHRoZSBBUEkgZm9yIGEgc2hhZG93ZWQgdmVyc2lvbiBvZiB0aGlzIG1ldGhvZCBtdXN0IG1hdGNoIHRoZSBBUEkgZm9yXG4qIHRoZSBvcmlnaW5hbCBgbWFrZVJlcXVlc3RgIG1ldGhvZC4gVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIEFQSSBvZiB0aGVcbiogW3JlcXVlc3QtcHJvbWlzZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVxdWVzdC1wcm9taXNlKSBsaWJyYXJ5LCBzbyBpZiB5b3UgZG8gY3JlYXRlIGEgc3ViY2xhc3MsIGl0IG1pZ2h0IGJlIGhlbHBmdWxcbiogdG8gdXNlIGByZXF1ZXN0LXByb21pc2VgIGludGVybmFsbHkuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgQVBJIHdvcmtzIGNvcnJlY3RseSwgc28gdGhhdCB5b3UgZG9uJ3QgaGF2ZSB0byByZWltcGxlbWVudCB0aGlzXG4qIGZ1bmN0aW9uJ3MgQVBJIGZyb20gc2NyYXRjaC5cbipcbiogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHJlcXVlc3RcbiogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmpzb24gSWYgYHRydWVgLCB0aGUgYENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbmAgaGVhZGVyIGlzIGFkZGVkLCBhbmQgdGhlIHJlc3BvbnNlIGJvZHkgd2lsbCBiZVxuKiBwYXJzZWQgYXMgSlNPTiBhdXRvbWF0aWNhbGx5LlxuKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5iYXNlVXJsIFRoZSBiYXNlIFVSTCB0aGF0IGEgcmVxdWVzdCBzaG91bGQgYmUgc2VudCB0b1xuKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmkgVGhlIHVyaSB0aGF0IGEgcmVxdWVzdCBzaG91bGQgYmUgc2VudCB0bywgdXNpbmcgdGhlIHByb3ZpZGVkIGBiYXNlVXJsYC5cbiogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubWV0aG9kPSdHRVQnIE1ldGhvZCBmb3IgdGhlIHJlcXVlc3RcbiogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuaGVhZGVycyBIZWFkZXJzIGZvciB0aGUgcmVxdWVzdFxuKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucXNdIFF1ZXJ5c3RyaW5nIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0XG4qIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5mb3JtXSBGb3JtIGRhdGEgZm9yIHRoZSByZXF1ZXN0LiBJZiBwcm92aWRlZCwgdGhlIGBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiogaGVhZGVyIGlzIHNldCwgYW5kIHRoZSBwcm92aWRlZCBvYmplY3QgaXMgc2VyaWFsaXplZCBpbnRvIFVSTC1lbmNvZGVkIGZvcm0gZGF0YSBpbiB0aGUgcmVxdWVzdCBib2R5LlxuKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZm9ybURhdGFdIE11bHRpcGFydCBmb3JtIGRhdGEgZm9yIHRoZSByZXF1ZXN0LiBJZiBwcm92aWRlZCwgdGhlIGBDb250ZW50LVR5cGU6IG11bHRpcGFydC9mb3JtLWRhdGFgXG4qIGhlYWRlciBpcyBzZXQsIGFuZCB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIHNlcmlhbGl6ZWQgYXMgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmJvZHldIFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LiBTaG91bGQgYmUgY29udmVydGVkIHRvIGEgc3RyaW5nIHdpdGggSlNPTi5zdHJpbmdpZnkoKS4gVGhpcyBpcyBpZ25vcmVkXG4qIGZvciBHRVQgcmVxdWVzdHMsIG9yIG9mIGBvcHRpb25zLmZvcm1gIG9yIGBvcHRpb25zLmZvcm1EYXRhYCBhcmUgcHJvdmlkZWQuXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnRyYW5zZm9ybV0gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBiZWZvcmUgdGhlIHJlc3BvbnNlIFByb21pc2UgZnVsZmlsbHMuIEFjY2VwdHMgdHdvIHBhcmFtZXRlcnM6XG4qIGByZXNwb25zZS5ib2R5YCBhbmQgYHJlc3BvbnNlYC4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZSwgYW5kIHRoZSByZXR1cm5lZFxuKiBQcm9taXNlIGZyb20gYG1ha2VSZXF1ZXN0YCBzaG91bGQgZnVsZmlsbCB3aXRoIGl0cyByZXR1cm4gdmFsdWUuXG4qIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzb2x2ZVdpdGhGdWxsUmVzcG9uc2U9ZmFsc2VdIElmIGB0cnVlYCwgYSBQcm9taXNlIGZvciB0aGUgZW50aXJlIHJlc3BvbnNlIGlzIHJldHVybmVkLiBJZiBgZmFsc2VgLFxuKiBhIFByb21pc2UgZm9yIG9ubHkgdGhlIHJlc3BvbnNlIGJvZHkgaXMgcmV0dXJuZWQuIFRoaXMgaXMgaWdub3JlZCBpZiBhbiBgb3B0aW9ucy50cmFuc2Zvcm1gIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLlxuKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIGZvciBhIHJlc3BvbnNlIG9iamVjdC4gRGVwZW5kaW5nIG9uIGBvcHRpb25zLnRyYW5zZm9ybWAgYW5kIGBvcHRpb25zLnJlc29sdmVXaXRoRnVsbFJlc3BvbnNlYCxcbiogdGhlIFByb21pc2Ugc2hvdWxkIHNldHRsZSB3aXRoIGVpdGhlciB0aGUgcmVzcG9uc2Ugb2JqZWN0IGl0c2VsZiwgdGhlIGJvZHkgb2YgdGhlIHJlc3BvbnNlLCBvciB0aGUgdmFsdWUgcmV0dXJuZWQgYnlcbiogYG9wdGlvbnMudHJhbnNmb3JtYC4gVGhlIFByb21pc2Ugc2hvdWxkIGJlIGZ1bGZpbGxlZCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgYmV0d2VlbiAyMDAgYW5kIDI5OSwgaW5jbHVzaXZlLCBhbmQgcmVqZWN0XG4qIG90aGVyd2lzZS4gKElmIGEgcmVkaXJlY3QgaXMgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCB0aGUgZnVuY3Rpb24gc2hvdWxkIGZvbGxvdyB0aGUgcmVkaXJlY3QgaWYgcG9zc2libGUsIG90aGVyd2lzZSByZWplY3Rcbiogd2l0aCBhbiBlcnJvci4pIEEgcmVzcG9uc2Ugb2JqZWN0IGhhcyA0IHByb3BlcnRpZXM6IGBzdGF0dXNDb2RlYCAobnVtYmVyKSB0aGUgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlLCBgYm9keWAgKG9iamVjdClcbiogdGhlIGJvZHkgb2YgdGhlIHJlc3BvbnNlLCBgaGVhZGVyc2AgKG9iamVjdCkgdGhlIHBhcnNlZCByZXNwb25zZSBoZWFkZXJzLCBhbmQgYHJlcXVlc3RgIChvYmplY3QpIGFuIG9iamVjdCBvZiB0aGUgZm9ybVxuKiBge21ldGhvZDogJ0dFVCcsIHVyaToge2hyZWY6ICdodHRwczovL29hdXRoLnJlZGRpdC5jb20vZnVsbC91cmwnfX1gIHJlcHJlc2VudGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiogQG1lbWJlcm9mIHNub293cmFwXG4qIEBpbnN0YW5jZVxuKiBAZXhhbXBsZVxuKlxuKiBjb25zdCBzbm9vd3JhcCA9IHJlcXVpcmUoJ3Nub293cmFwJyk7XG4qXG4qIGNsYXNzIFNub293cmFwU3ViY2xhc3MgZXh0ZW5kcyBzbm9vd3JhcCB7XG4qICAgcmF3UmVxdWVzdChvcHRpb25zKSB7XG4qICAgICAvLyBkbyBjdXN0b20gYmVoYXZpb3Igd2l0aCBgb3B0aW9uc2AgaWYgeW91IHdhbnQsIHRoZW4gY2FsbCB0aGUgcmVndWxhciByYXdSZXF1ZXN0IGZ1bmN0aW9uXG4qICAgICBjb25zb2xlLmxvZyhgbWFkZSBhIHJlcXVlc3Qgd2l0aCBvcHRpb25zOmApO1xuKiAgICAgY29uc29sZS5sb2cob3B0aW9ucyk7XG4qICAgICByZXR1cm4gc3VwZXIucmF3UmVxdWVzdChvcHRpb25zKVxuKiAgIH1cbiogfVxuKlxuKiBjb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgncmVxdWVzdC1wcm9taXNlJyk7XG4qXG4qIGNsYXNzIEFub3RoZXJTbm9vd3JhcFN1YmNsYXNzIGV4dGVuZHMgc25vb3dyYXAge1xuKiAgIHJhd1JlcXVlc3Qob3B0aW9ucykge1xuKiAgICAgLy8gc2VuZCBhbGwgcmVxdWVzdHMgdGhyb3VnaCBhIHByb3h5XG4qICAgICByZXR1cm4gcmVxdWVzdChPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtwcm94eTogJ2h0dHBzOi8vZXhhbXBsZS5jb20nfSkpXG4qICAgfVxuKiB9XG4qL1xuXG5cbnZhciByYXdSZXF1ZXN0ID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJy4veGhyJykgOiByZXF1aXJlKCdyZXF1ZXN0LXByb21pc2UnKS5kZWZhdWx0cyh7XG4gIGd6aXA6IHRydWVcbn0pO1xuZXhwb3J0cy5yYXdSZXF1ZXN0ID0gcmF3UmVxdWVzdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/request_handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/snoowrap.js":
/*!************************************************!*\
  !*** ./node_modules/snoowrap/dist/snoowrap.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nvar _lodash = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ./Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _promiseChains = _interopRequireDefault(__webpack_require__(/*! promise-chains */ \"(rsc)/./node_modules/promise-chains/index.js\"));\n\nvar _util = _interopRequireDefault(__webpack_require__(/*! util */ \"util\"));\n\nvar requestHandler = _interopRequireWildcard(__webpack_require__(/*! ./request_handler.js */ \"(rsc)/./node_modules/snoowrap/dist/request_handler.js\"));\n\nvar _constants = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/snoowrap/dist/constants.js\");\n\nvar errors = _interopRequireWildcard(__webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/snoowrap/dist/errors.js\"));\n\nvar _helpers = __webpack_require__(/*! ./helpers.js */ \"(rsc)/./node_modules/snoowrap/dist/helpers.js\");\n\nvar _create_config = _interopRequireDefault(__webpack_require__(/*! ./create_config.js */ \"(rsc)/./node_modules/snoowrap/dist/create_config.js\"));\n\nvar objects = _interopRequireWildcard(__webpack_require__(/*! ./objects/index.js */ \"(rsc)/./node_modules/snoowrap/dist/objects/index.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar api_type = 'json';\n/** The class for a snoowrap requester.\n * A requester is the base object that is used to fetch content from reddit. Each requester contains a single set of OAuth\n tokens.\n\n If constructed with a refresh token, a requester will be able to repeatedly generate access tokens as necessary, without any\n further user intervention. After making at least one request, a requester will have the `access_token` property, which specifies\n the access token currently in use. It will also have a few additional properties such as `scope` (an array of scope strings)\n and `ratelimitRemaining` (the number of requests remaining for the current 10-minute interval, in compliance with reddit's\n [API rules](https://github.com/reddit/reddit/wiki/API).) These properties primarily exist for internal use, but they are\n exposed since they are useful externally as well.\n */\n\nvar snoowrap = class snoowrap {\n  /**\n   * @summary Constructs a new requester.\n   * @desc You should use the snoowrap constructor if you are able to authorize a reddit account in advance (e.g. for a Node.js\n   script that always uses the same account). If you aren't able to authorize in advance (e.g. acting through an arbitrary user's\n   account while running snoowrap in a browser), then you should use {@link snoowrap.getAuthUrl} and\n   {@link snoowrap.fromAuthCode} instead.\n   *\n   * To edit snoowrap specific settings, see {@link snoowrap#config}.\n   *\n   * snoowrap supports several different options for pre-existing authentication:\n   * 1. *Refresh token*: To authenticate with a refresh token, pass an object with the properties `userAgent`, `clientId`,\n   `clientSecret`, and `refreshToken` to the snoowrap constructor. You will need to get the refresh token from reddit\n   beforehand. A script to automatically generate refresh tokens for you can be found\n   [here](https://github.com/not-an-aardvark/reddit-oauth-helper).\n   * 1. *Username/password*: To authenticate with a username and password, pass an object with the properties `userAgent`,\n   `clientId`, `clientSecret`, `username`, and `password` to the snoowrap constructor. Note that username/password\n   authentication is only possible for `script`-type apps.\n   * 1. *Access token*: To authenticate with an access token, pass an object with the properties `userAgent` and `accessToken`\n   to the snoowrap constructor. Note that all access tokens expire one hour after being generated, so this method is\n   not recommended for long-term use.\n   * @param {object} options An object containing authentication options. This should always have the property `userAgent`. It\n   must also contain some combination of credentials (see above)\n   * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n   is running in a browser.\n   * @param {string} [options.clientId] The client ID of your app (assigned by reddit)\n   * @param {string} [options.clientSecret] The client secret of your app (assigned by reddit). If you are using a refresh token\n   with an installed app (which does not have a client secret), pass an empty string as your `clientSecret`.\n   * @param {string} [options.username] The username of the account to access\n   * @param {string} [options.password] The password of the account to access\n   * @param {string} [options.refreshToken] A refresh token for your app\n   * @param {string} [options.accessToken] An access token for your app\n   */\n  constructor() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        user_agent = _ref.user_agent,\n        _ref$userAgent = _ref.userAgent,\n        userAgent = _ref$userAgent === void 0 ? user_agent : _ref$userAgent,\n        client_id = _ref.client_id,\n        _ref$clientId = _ref.clientId,\n        clientId = _ref$clientId === void 0 ? client_id : _ref$clientId,\n        client_secret = _ref.client_secret,\n        _ref$clientSecret = _ref.clientSecret,\n        clientSecret = _ref$clientSecret === void 0 ? client_secret : _ref$clientSecret,\n        refresh_token = _ref.refresh_token,\n        _ref$refreshToken = _ref.refreshToken,\n        refreshToken = _ref$refreshToken === void 0 ? refresh_token : _ref$refreshToken,\n        access_token = _ref.access_token,\n        _ref$accessToken = _ref.accessToken,\n        accessToken = _ref$accessToken === void 0 ? access_token : _ref$accessToken,\n        username = _ref.username,\n        password = _ref.password;\n\n    if (!userAgent && !_helpers.isBrowser) {\n      return (0, _helpers.requiredArg)('userAgent');\n    }\n\n    if ((!accessToken || typeof accessToken !== 'string') && (clientId === undefined || clientSecret === undefined || typeof refreshToken !== 'string') && (clientId === undefined || clientSecret === undefined || username === undefined || password === undefined)) {\n      throw new errors.NoCredentialsError();\n    }\n\n    if (_helpers.isBrowser) {\n      this.userAgent = global.navigator.userAgent;\n    }\n\n    (0, _lodash.defaults)(this, {\n      userAgent,\n      clientId,\n      clientSecret,\n      refreshToken,\n      accessToken,\n      username,\n      password\n    }, {\n      clientId: null,\n      clientSecret: null,\n      refreshToken: null,\n      accessToken: null,\n      username: null,\n      password: null,\n      ratelimitRemaining: null,\n      ratelimitExpiration: null,\n      tokenExpiration: null,\n      scope: null,\n      _config: (0, _create_config.default)(),\n      _nextRequestTimestamp: -Infinity\n    });\n    (0, _helpers.addSnakeCaseShadowProps)(this);\n  }\n  /**\n   * @summary Gets an authorization URL, which allows a user to authorize access to their account\n   * @desc This create a URL where a user can authorize an app to act through their account. If the user visits the returned URL\n   in a web browser, they will see a page that looks like [this](https://i.gyazo.com/0325534f38b78c1dbd4c84d690dda6c2.png). If\n   the user clicks \"Allow\", they will be redirected to your `redirectUri`, with a `code` querystring parameter containing an\n   * *authorization code*. If this code is passed to {@link snoowrap.fromAuthCode}, you can create a requester to make\n   requests on behalf of the user.\n   *\n   * The main use-case here is for running snoowrap in a browser. You can generate a URL, send the user there, and then continue\n   after the user authenticates on reddit and is redirected back.\n   *\n   * @param {object} options\n   * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n   browser, using an \"Installed\" app type is recommended.\n   * @param {string[]} options.scope An array of scopes (permissions on the user's account) to request on the authentication\n   page. A list of possible scopes can be found [here](https://www.reddit.com/api/v1/scopes). You can also get them on-the-fly\n   with {@link snoowrap#getOauthScopeList}.\n   * @param {string} options.redirectUri The URL where the user should be redirected after authenticating. This **must** be the\n   same as the redirect URI that is configured for the reddit app. (If there is a mismatch, the returned URL will display an\n   error page instead of an authentication form.)\n   * @param {boolean} [options.permanent=true] If `true`, the app will have indefinite access to the user's account. If `false`,\n   access to the user's account will expire after 1 hour.\n   * @param {string} [options.state] A string that can be used to verify a user after they are redirected back to the site. When\n   the user is redirected from reddit, to the redirect URI after authenticating, the resulting URI will have this same `state`\n   value in the querystring. (See [here](http://www.twobotechnologies.com/blog/2014/02/importance-of-state-in-oauth2.html) for\n   more information on how to use the `state` value.)\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain for the URL. If the user is authenticating on\n   reddit.com (as opposed to some other site with a reddit-like API), you can omit this value.\n   * @returns {string} A URL where the user can authenticate with the given options\n   * @example\n   *\n   * var authenticationUrl = snoowrap.getAuthUrl({\n   *   clientId: 'foobarbazquuux',\n   *   scope: ['identity', 'wikiread', 'wikiedit'],\n   *   redirectUri: 'https://example.com/reddit_callback',\n   *   permanent: false,\n   *   state: 'fe211bebc52eb3da9bef8db6e63104d3' // a random string, this could be validated when the user is redirected back\n   * });\n   * // --> 'https://www.reddit.com/api/v1/authorize?client_id=foobarbaz&response_type=code&state= ...'\n   *\n   * window.location.href = authenticationUrl; // send the user to the authentication url\n   */\n\n\n  static getAuthUrl(_ref2) {\n    var _ref2$clientId = _ref2.clientId,\n        clientId = _ref2$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref2$clientId,\n        _ref2$scope = _ref2.scope,\n        scope = _ref2$scope === void 0 ? (0, _helpers.requiredArg)('scope') : _ref2$scope,\n        _ref2$redirectUri = _ref2.redirectUri,\n        redirectUri = _ref2$redirectUri === void 0 ? (0, _helpers.requiredArg)('redirectUri') : _ref2$redirectUri,\n        _ref2$permanent = _ref2.permanent,\n        permanent = _ref2$permanent === void 0 ? true : _ref2$permanent,\n        _ref2$state = _ref2.state,\n        state = _ref2$state === void 0 ? '_' : _ref2$state,\n        _ref2$endpointDomain = _ref2.endpointDomain,\n        endpointDomain = _ref2$endpointDomain === void 0 ? 'reddit.com' : _ref2$endpointDomain;\n\n    if (!(Array.isArray(scope) && scope.length && scope.every(function (scopeValue) {\n      return scopeValue && typeof scopeValue === 'string';\n    }))) {\n      throw new TypeError('Missing `scope` argument; a non-empty list of OAuth scopes must be provided');\n    }\n\n    return \"\\n      https://www.\".concat(endpointDomain, \"/api/v1/authorize?\\n      client_id=\").concat(encodeURIComponent(clientId), \"\\n      &response_type=code\\n      &state=\").concat(encodeURIComponent(state), \"\\n      &redirect_uri=\").concat(encodeURIComponent(redirectUri), \"\\n      &duration=\").concat(permanent ? 'permanent' : 'temporary', \"\\n      &scope=\").concat(encodeURIComponent(scope.join(' ')), \"\\n    \").replace(/\\s/g, '');\n  }\n  /**\n   * @summary Creates a snoowrap requester from an authorization code.\n   * @desc An authorization code is the `code` value that appears in the querystring after a user authenticates with reddit and\n   is redirected. For more information, see {@link snoowrap.getAuthUrl}.\n   *\n   * The main use-case for this function is for running snoowrap in a browser. You can generate a URL with\n   {@link snoowrap.getAuthUrl} and send the user to that URL, and then use this function to create a requester when\n   the user is redirected back with an authorization code.\n   * @param {object} options\n   * @param {string} options.code The authorization code\n   * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n   is running in a browser.\n   * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n   browser, using an \"Installed\" app type is recommended.\n   * @param {string} [options.clientSecret] The client secret of your app. If your app has the \"Installed\" app type, omit\n   this parameter.\n   * @param {string} options.redirectUri The redirect URI that is configured for the reddit app.\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain that the returned requester should be configured\n   to use. If the user is authenticating on reddit.com (as opposed to some other site with a reddit-like API), you can omit this\n   value.\n   * @returns {Promise<snoowrap>} A Promise that fulfills with a `snoowrap` instance\n   * @example\n   *\n   * // Get the `code` querystring param (assuming the user was redirected from reddit)\n   * var code = new URL(window.location.href).searchParams.get('code');\n   *\n   * snoowrap.fromAuthCode({\n   *   code: code,\n   *   userAgent: 'My app',\n   *   clientId: 'foobarbazquuux',\n   *   redirectUri: 'example.com'\n   * }).then(r => {\n   *   // Now we have a requester that can access reddit through the user's account\n   *   return r.getHot().then(posts => {\n   *     // do something with posts from the front page\n   *   });\n   * })\n   */\n\n\n  static fromAuthCode(_ref3) {\n    var _this = this;\n\n    var _ref3$code = _ref3.code,\n        code = _ref3$code === void 0 ? (0, _helpers.requiredArg)('code') : _ref3$code,\n        _ref3$userAgent = _ref3.userAgent,\n        userAgent = _ref3$userAgent === void 0 ? _helpers.isBrowser ? global.navigator.userAgent : (0, _helpers.requiredArg)('userAgent') : _ref3$userAgent,\n        _ref3$clientId = _ref3.clientId,\n        clientId = _ref3$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref3$clientId,\n        clientSecret = _ref3.clientSecret,\n        _ref3$redirectUri = _ref3.redirectUri,\n        redirectUri = _ref3$redirectUri === void 0 ? (0, _helpers.requiredArg)('redirectUri') : _ref3$redirectUri,\n        _ref3$endpointDomain = _ref3.endpointDomain,\n        endpointDomain = _ref3$endpointDomain === void 0 ? 'reddit.com' : _ref3$endpointDomain;\n    return this.prototype.credentialedClientRequest.call({\n      userAgent,\n      clientId,\n      clientSecret,\n      // Use `this.prototype.rawRequest` function to allow for custom `rawRequest` method usage in subclasses.\n      rawRequest: this.prototype.rawRequest\n    }, {\n      method: 'post',\n      baseUrl: \"https://www.\".concat(endpointDomain, \"/\"),\n      uri: 'api/v1/access_token',\n      form: {\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: redirectUri\n      }\n    }).then(function (response) {\n      if (response.error) {\n        throw new errors.RequestError(\"API Error: \".concat(response.error, \" - \").concat(response.error_description));\n      } // Use `new this` instead of `new snoowrap` to ensure that subclass instances can be returned\n\n\n      var requester = new _this(_objectSpread({\n        userAgent,\n        clientId,\n        clientSecret\n      }, response));\n      requester.config({\n        endpointDomain\n      });\n      return requester;\n    });\n  }\n  /**\n   * @summary Returns the grant types available for app-only authentication\n   * @desc Per the Reddit API OAuth docs, there are two different grant types depending on whether the app is an installed client\n   * or a confidential client such as a web app or string. This getter returns the possible values for the \"grant_type\" field\n   * in application-only auth.\n   * @returns {object} The enumeration of possible grant_type values\n   */\n\n\n  static get grantType() {\n    return {\n      CLIENT_CREDENTIALS: 'client_credentials',\n      INSTALLED_CLIENT: 'https://oauth.reddit.com/grants/installed_client'\n    };\n  }\n  /**\n  * @summary Creates a snoowrap requester from a \"user-less\" Authorization token\n  * @desc In some cases, 3rd party app clients may wish to make API requests without a user context. App clients can request\n  * a \"user-less\" Authorization token via either the standard client_credentials grant, or the reddit specific\n  * extension to this grant, https://oauth.reddit.com/grants/installed_client. Which grant type an app uses depends on\n  * the app-type and its use case.\n  * @param {object} options\n  * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n  is running in a browser.\n  * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n  * browser, using an \"Installed\" app type is recommended.\n  * @param {string} [options.clientSecret] The client secret of your app. Only required for \"client_credentials\" grant type.\n  * @param {string} [options.deviceId] A unique, per-device ID generated by your client. Only required\n  * for \"Installed\" grant type, needs to be between 20-30 characters long. From the reddit docs: \"reddit *may* choose to use\n  * this ID to generate aggregate data about user counts. Clients that wish to remain anonymous should use the value\n  * DO_NOT_TRACK_THIS_DEVICE.\"\n  * @param {string} [options.grantType=snoowrap.grantType.INSTALLED_CLIENT] The type of \"user-less\"\n  * token to use {@link snoowrap.grantType}\n  * @param {boolean} [options.permanent=true] If `true`, the app will have indefinite access. If `false`,\n  access will expire after 1 hour.\n  * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain that the returned requester should be configured\n  to use. If the user is authenticating on reddit.com (as opposed to some other site with a reddit-like API), you can omit this\n  value.\n  * @returns {Promise<snoowrap>} A Promise that fulfills with a `snoowrap` instance\n  * @example\n  *\n  * snoowrap.fromApplicationOnlyAuth({\n  *   userAgent: 'My app',\n  *   clientId: 'foobarbazquuux',\n  *   deviceId: 'unique id between 20-30 chars',\n  *   grantType: snoowrap.grantType.INSTALLED_CLIENT\n  * }).then(r => {\n  *   // Now we have a requester that can access reddit through a \"user-less\" Auth token\n  *   return r.getHot().then(posts => {\n  *     // do something with posts from the front page\n  *   });\n  * })\n  *\n  * snoowrap.fromApplicationOnlyAuth({\n  *   userAgent: 'My app',\n  *   clientId: 'foobarbazquuux',\n  *   clientSecret: 'your web app secret',\n  *   grantType: snoowrap.grantType.CLIENT_CREDENTIALS\n  * }).then(r => {\n  *   // Now we have a requester that can access reddit through a \"user-less\" Auth token\n  *   return r.getHot().then(posts => {\n  *     // do something with posts from the front page\n  *   });\n  * })\n  */\n\n\n  static fromApplicationOnlyAuth(_ref4) {\n    var _this2 = this;\n\n    var _ref4$userAgent = _ref4.userAgent,\n        userAgent = _ref4$userAgent === void 0 ? _helpers.isBrowser ? global.navigator.userAgent : (0, _helpers.requiredArg)('userAgent') : _ref4$userAgent,\n        _ref4$clientId = _ref4.clientId,\n        clientId = _ref4$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref4$clientId,\n        clientSecret = _ref4.clientSecret,\n        deviceId = _ref4.deviceId,\n        _ref4$grantType = _ref4.grantType,\n        grantType = _ref4$grantType === void 0 ? snoowrap.grantType.INSTALLED_CLIENT : _ref4$grantType,\n        _ref4$permanent = _ref4.permanent,\n        permanent = _ref4$permanent === void 0 ? true : _ref4$permanent,\n        _ref4$endpointDomain = _ref4.endpointDomain,\n        endpointDomain = _ref4$endpointDomain === void 0 ? 'reddit.com' : _ref4$endpointDomain;\n    return this.prototype.credentialedClientRequest.call({\n      clientId,\n      clientSecret,\n      // Use `this.prototype.rawRequest` function to allow for custom `rawRequest` method usage in subclasses.\n      rawRequest: this.prototype.rawRequest\n    }, {\n      method: 'post',\n      baseUrl: \"https://www.\".concat(endpointDomain, \"/\"),\n      uri: 'api/v1/access_token',\n      form: {\n        grant_type: grantType,\n        device_id: deviceId,\n        duration: permanent ? 'permanent' : 'temporary'\n      }\n    }).then(function (response) {\n      if (response.error) {\n        throw new errors.RequestError(\"API Error: \".concat(response.error, \" - \").concat(response.error_description));\n      } // Use `new this` instead of `new snoowrap` to ensure that subclass instances can be returned\n\n\n      var requester = new _this2(_objectSpread({\n        userAgent,\n        clientId,\n        clientSecret\n      }, response));\n      requester.config({\n        endpointDomain\n      });\n      return requester;\n    });\n  }\n\n  _newObject(objectType, content) {\n    var _hasFetched = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    return Array.isArray(content) ? content : new snoowrap.objects[objectType](content, this, _hasFetched);\n  }\n  /**\n   * @summary Retrieves or modifies the configuration options for this snoowrap instance.\n   * @param {object} [options] A map of `{[config property name]: value}`. Note that any omitted config properties will simply\n   retain whatever value they had previously. (In other words, if you only want to change one property, you only need to put\n   that one property in this parameter. To get the current configuration without modifying anything, simply omit this\n   parameter.)\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint where requests should be sent\n   * @param {Number} [options.requestDelay=0] A minimum delay, in milliseconds, to enforce between API calls. If multiple\n   api calls are requested during this timespan, they will be queued and sent one at a time. Setting this to more than 1000 will\n   ensure that reddit's ratelimit is never reached, but it will make things run slower than necessary if only a few requests\n   are being sent. If this is set to zero, snoowrap will not enforce any delay between individual requests. However, it will\n   still refuse to continue if reddit's enforced ratelimit (600 requests per 10 minutes) is exceeded.\n   * @param {Number} [options.requestTimeout=30000] A timeout for all OAuth requests, in milliseconds. If the reddit server\n   fails to return a response within this amount of time, the Promise will be rejected with a timeout error.\n   * @param {boolean} [options.continueAfterRatelimitError=false] Determines whether snoowrap should queue API calls if\n   reddit's ratelimit is exceeded. If set to `true` when the ratelimit is exceeded, snoowrap will queue all further requests,\n   and will attempt to send them again after the current ratelimit period expires (which happens every 10 minutes). If set\n   to `false`, snoowrap will simply throw an error when reddit's ratelimit is exceeded.\n   * @param {Number[]} [options.retryErrorCodes=[502, 503, 504, 522]] If reddit responds to an idempotent request with one of\n   these error codes, snoowrap will retry the request, up to a maximum of `max_retry_attempts` requests in total. (These\n   errors usually indicate that there was an temporary issue on reddit's end, and retrying the request has a decent chance of\n   success.) This behavior can be disabled by simply setting this property to an empty array.\n   * @param {Number} [options.maxRetryAttempts=3] See `retryErrorCodes`.\n   * @param {boolean} [options.warnings=true] snoowrap may occasionally log warnings, such as deprecation notices, to the\n   console. These can be disabled by setting this to `false`.\n   * @param {boolean} [options.debug=false] If set to true, snoowrap will print out potentially-useful information for debugging\n   purposes as it runs.\n   * @param {object} [options.logger=console] By default, snoowrap will log any warnings and debug output to the console.\n   A custom logger object may be supplied via this option; it must expose `warn`, `info`, `debug`, and `trace` functions.\n   * @param {boolean} [options.proxies=true] Setting this to `false` disables snoowrap's method-chaining feature. This causes\n   the syntax for using snoowrap to become a bit heavier, but allows for consistency between environments that support the ES6\n   `Proxy` object and environments that don't. This option is a no-op in environments that don't support the `Proxy` object,\n   since method chaining is always disabled in those environments. Note, changing this setting must be done before making\n   any requests.\n   * @returns {object} An updated Object containing all of the configuration values\n   * @example\n   *\n   * r.config({requestDelay: 1000, warnings: false});\n   * // sets the request delay to 1000 milliseconds, and suppresses warnings.\n   */\n\n\n  config() {\n    var _this3 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var invalidKey = Object.keys(options).find(function (key) {\n      return !(key in _this3._config);\n    });\n\n    if (invalidKey) {\n      throw new TypeError(\"Invalid config option '\".concat(invalidKey, \"'\"));\n    }\n\n    return Object.assign(this._config, options);\n  }\n\n  _warn() {\n    if (this._config.warnings) {\n      var _this$_config$logger;\n\n      (_this$_config$logger = this._config.logger).warn.apply(_this$_config$logger, arguments);\n    }\n  }\n\n  _debug() {\n    if (this._config.debug) {\n      var _this$_config$logger2;\n\n      (_this$_config$logger2 = this._config.logger).debug.apply(_this$_config$logger2, arguments);\n    }\n  }\n\n  get _promiseWrap() {\n    return this._config.proxies ? _promiseChains.default : identity;\n  }\n  /**\n   * @summary Gets information on a reddit user with a given name.\n   * @param {string} name - The user's username\n   * @returns {RedditUser} An unfetched RedditUser object for the requested user\n   * @example\n   *\n   * r.getUser('not_an_aardvark')\n   * // => RedditUser { name: 'not_an_aardvark' }\n   * r.getUser('not_an_aardvark').link_karma.then(console.log)\n   * // => 6\n   */\n\n\n  getUser(name) {\n    return this._newObject('RedditUser', {\n      name: (name + '').replace(/^\\/?u\\//, '')\n    });\n  }\n  /**\n   * @summary Gets information on a comment with a given id.\n   * @param {string} commentId - The base36 id of the comment\n   * @returns {Comment} An unfetched Comment object for the requested comment\n   * @example\n   *\n   * r.getComment('c0b6xx0')\n   * // => Comment { name: 't1_c0b6xx0' }\n   * r.getComment('c0b6xx0').author.name.then(console.log)\n   * // => 'Kharos'\n   */\n\n\n  getComment(commentId) {\n    return this._newObject('Comment', {\n      name: (0, _helpers.addFullnamePrefix)(commentId, 't1_')\n    });\n  }\n  /**\n   * @summary Gets information on a given subreddit.\n   * @param {string} displayName - The name of the subreddit (e.g. 'AskReddit')\n   * @returns {Subreddit} An unfetched Subreddit object for the requested subreddit\n   * @example\n   *\n   * r.getSubreddit('AskReddit')\n   * // => Subreddit { display_name: 'AskReddit' }\n   * r.getSubreddit('AskReddit').created_utc.then(console.log)\n   * // => 1201233135\n   */\n\n\n  getSubreddit(displayName) {\n    return this._newObject('Subreddit', {\n      display_name: displayName.replace(/^\\/?r\\//, '')\n    });\n  }\n  /**\n   * @summary Gets information on a given submission.\n   * @param {string} submissionId - The base36 id of the submission\n   * @returns {Submission} An unfetched Submission object for the requested submission\n   * @example\n   *\n   * r.getSubmission('2np694')\n   * // => Submission { name: 't3_2np694' }\n   * r.getSubmission('2np694').title.then(console.log)\n   * // => 'What tasty food would be distusting if eaten over rice?'\n   */\n\n\n  getSubmission(submissionId) {\n    return this._newObject('Submission', {\n      name: (0, _helpers.addFullnamePrefix)(submissionId, 't3_')\n    });\n  }\n  /**\n   * @summary Gets a private message by ID.\n   * @param {string} messageId The base36 ID of the message\n   * @returns {PrivateMessage} An unfetched PrivateMessage object for the requested message\n   * @example\n   *\n   * r.getMessage('51shnw')\n   * // => PrivateMessage { name: 't4_51shnw' }\n   * r.getMessage('51shnw').subject.then(console.log)\n   * // => 'Example'\n   * // See here for a screenshot of the PM in question https://i.gyazo.com/24f3b97e55b6ff8e3a74cb026a58b167.png\n   */\n\n\n  getMessage(messageId) {\n    return this._newObject('PrivateMessage', {\n      name: (0, _helpers.addFullnamePrefix)(messageId, 't4_')\n    });\n  }\n  /**\n   * Gets a livethread by ID.\n   * @param {string} threadId The base36 ID of the livethread\n   * @returns {LiveThread} An unfetched LiveThread object\n   * @example\n   *\n   * r.getLivethread('whrdxo8dg9n0')\n   * // => LiveThread { id: 'whrdxo8dg9n0' }\n   * r.getLivethread('whrdxo8dg9n0').nsfw.then(console.log)\n   * // => false\n   */\n\n\n  getLivethread(threadId) {\n    return this._newObject('LiveThread', {\n      id: (0, _helpers.addFullnamePrefix)(threadId, 'LiveUpdateEvent_').slice(16)\n    });\n  }\n  /**\n   * @summary Gets information on the requester's own user profile.\n   * @returns {RedditUser} A RedditUser object corresponding to the requester's profile\n   * @example\n   *\n   * r.getMe().then(console.log);\n   * // => RedditUser { is_employee: false, has_mail: false, name: 'snoowrap_testing', ... }\n   */\n\n\n  getMe() {\n    var _this4 = this;\n\n    return this._get({\n      uri: 'api/v1/me'\n    }).then(function (result) {\n      _this4._ownUserInfo = _this4._newObject('RedditUser', result, true);\n      return _this4._ownUserInfo;\n    });\n  }\n\n  _getMyName() {\n    return _Promise.default.resolve(this._ownUserInfo ? this._ownUserInfo.name : this.getMe().get('name'));\n  }\n  /**\n   * @summary Gets a distribution of the requester's own karma distribution by subreddit.\n   * @returns {Promise} A Promise for an object with karma information\n   * @example\n   *\n   * r.getKarma().then(console.log)\n   * // => [\n   * //  { sr: Subreddit { display_name: 'redditdev' }, comment_karma: 16, link_karma: 1 },\n   * //  { sr: Subreddit { display_name: 'programming' }, comment_karma: 2, link_karma: 1 },\n   * //  ...\n   * // ]\n   */\n\n\n  getKarma() {\n    return this._get({\n      uri: 'api/v1/me/karma'\n    });\n  }\n  /**\n   * @summary Gets information on the user's current preferences.\n   * @returns {Promise} A promise for an object containing the user's current preferences\n   * @example\n   *\n   * r.getPreferences().then(console.log)\n   * // => { default_theme_sr: null, threaded_messages: true, hide_downs: false, ... }\n   */\n\n\n  getPreferences() {\n    return this._get({\n      uri: 'api/v1/me/prefs'\n    });\n  }\n  /**\n   * @summary Updates the user's current preferences.\n   * @param {object} updatedPreferences An object of the form {[some preference name]: 'some value', ...}. Any preference\n   * not included in this object will simply retain its current value.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.updatePreferences({threaded_messages: false, hide_downs: true})\n   * // => { default_theme_sr: null, threaded_messages: false,hide_downs: true, ... }\n   * // (preferences updated on reddit)\n   */\n\n\n  updatePreferences(updatedPreferences) {\n    return this._patch({\n      uri: 'api/v1/me/prefs',\n      body: updatedPreferences\n    });\n  }\n  /**\n   * @summary Gets the currently-authenticated user's trophies.\n   * @returns {Promise} A TrophyList containing the user's trophies\n   * @example\n   *\n   * r.getMyTrophies().then(console.log)\n   * // => TrophyList { trophies: [\n   * //   Trophy { icon_70: 'https://s3.amazonaws.com/redditstatic/award/verified_email-70.png',\n   * //     description: null,\n   * //     url: null,\n   * //     icon_40: 'https://s3.amazonaws.com/redditstatic/award/verified_email-40.png',\n   * //     award_id: 'o',\n   * //     id: '16fn29',\n   * //     name: 'Verified Email'\n   * //   }\n   * // ] }\n   */\n\n\n  getMyTrophies() {\n    return this._get({\n      uri: 'api/v1/me/trophies'\n    });\n  }\n  /**\n   * @summary Gets the list of the currently-authenticated user's friends.\n   * @returns {Promise} A Promise that resolves with a list of friends\n   * @example\n   *\n   * r.getFriends().then(console.log)\n   * // => [ [ RedditUser { date: 1457927963, name: 'not_an_aardvark', id: 't2_k83md' } ], [] ]\n   */\n\n\n  getFriends() {\n    return this._get({\n      uri: 'prefs/friends'\n    });\n  }\n  /**\n   * @summary Gets the list of people that the currently-authenticated user has blocked.\n   * @returns {Promise} A Promise that resolves with a list of blocked users\n   * @example\n   *\n   * r.getBlockedUsers().then(console.log)\n   * // => [ RedditUser { date: 1457928120, name: 'actually_an_aardvark', id: 't2_q3519' } ]\n   */\n\n\n  getBlockedUsers() {\n    return this._get({\n      uri: 'prefs/blocked'\n    });\n  }\n  /**\n   * @summary Determines whether the currently-authenticated user needs to fill out a captcha in order to submit content.\n   * @returns {Promise} A Promise that resolves with a boolean value\n   * @example\n   *\n   * r.checkCaptchaRequirement().then(console.log)\n   * // => false\n   */\n\n\n  checkCaptchaRequirement() {\n    return this._get({\n      uri: 'api/needs_captcha'\n    });\n  }\n  /**\n   * @summary Gets the identifier (a hex string) for a new captcha image.\n   * @returns {Promise} A Promise that resolves with a string\n   * @example\n   *\n   * r.getNewCaptchaIdentifier().then(console.log)\n   * // => 'o5M18uy4mk0IW4hs0fu2GNPdXb1Dxe9d'\n   */\n\n\n  getNewCaptchaIdentifier() {\n    return this._post({\n      uri: 'api/new_captcha',\n      form: {\n        api_type\n      }\n    }).then(function (res) {\n      return res.json.data.iden;\n    });\n  }\n  /**\n   * @summary Gets an image for a given captcha identifier.\n   * @param {string} identifier The captcha identifier.\n   * @returns {Promise} A string containing raw image data in PNG format\n   * @example\n   *\n   * r.getCaptchaImage('o5M18uy4mk0IW4hs0fu2GNPdXb1Dxe9d').then(console.log)\n   // => (A long, incoherent string representing the image in PNG format)\n   */\n\n\n  getCaptchaImage(identifier) {\n    return this._get({\n      uri: \"captcha/\".concat(identifier)\n    });\n  }\n  /**\n   * @summary Gets an array of categories that items can be saved in. (Requires reddit gold)\n   * @returns {Promise} An array of categories\n   * @example\n   *\n   * r.getSavedCategories().then(console.log)\n   * // => [ { category: 'cute cat pictures' }, { category: 'interesting articles' } ]\n   */\n\n\n  getSavedCategories() {\n    return this._get({\n      uri: 'api/saved_categories'\n    }).get('categories');\n  }\n  /**\n   * @summary Marks a list of submissions as 'visited'.\n   * @desc **Note**: This endpoint only works if the authenticated user is subscribed to reddit gold.\n   * @param {Submission[]} links A list of Submission objects to mark\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * var submissions = [r.getSubmission('4a9u54'), r.getSubmission('4a95nb')]\n   * r.markAsVisited(submissions)\n   * // (the links will now appear purple on reddit)\n   */\n\n\n  markAsVisited(links) {\n    return this._post({\n      uri: 'api/store_visits',\n      links: (0, _lodash.map)(links, 'name').join(',')\n    });\n  }\n\n  _submit(_ref5) {\n    var _this5 = this;\n\n    var captcha_response = _ref5.captcha_response,\n        _ref5$captchaResponse = _ref5.captchaResponse,\n        captchaResponse = _ref5$captchaResponse === void 0 ? captcha_response : _ref5$captchaResponse,\n        captcha_iden = _ref5.captcha_iden,\n        _ref5$captchaIden = _ref5.captchaIden,\n        captchaIden = _ref5$captchaIden === void 0 ? captcha_iden : _ref5$captchaIden,\n        kind = _ref5.kind,\n        _ref5$resubmit = _ref5.resubmit,\n        resubmit = _ref5$resubmit === void 0 ? true : _ref5$resubmit,\n        _ref5$send_replies = _ref5.send_replies,\n        send_replies = _ref5$send_replies === void 0 ? true : _ref5$send_replies,\n        _ref5$sendReplies = _ref5.sendReplies,\n        sendReplies = _ref5$sendReplies === void 0 ? send_replies : _ref5$sendReplies,\n        crosspost_fullname = _ref5.crosspost_fullname,\n        text = _ref5.text,\n        title = _ref5.title,\n        url = _ref5.url,\n        subreddit_name = _ref5.subreddit_name,\n        _ref5$subredditName = _ref5.subredditName,\n        subredditName = _ref5$subredditName === void 0 ? subreddit_name : _ref5$subredditName,\n        nsfw = _ref5.nsfw,\n        spoiler = _ref5.spoiler,\n        flairId = _ref5.flairId,\n        flairText = _ref5.flairText,\n        options = _objectWithoutProperties(_ref5, [\"captcha_response\", \"captchaResponse\", \"captcha_iden\", \"captchaIden\", \"kind\", \"resubmit\", \"send_replies\", \"sendReplies\", \"crosspost_fullname\", \"text\", \"title\", \"url\", \"subreddit_name\", \"subredditName\", \"nsfw\", \"spoiler\", \"flairId\", \"flairText\"]);\n\n    return this._post({\n      uri: 'api/submit',\n      form: _objectSpread({\n        api_type,\n        captcha: captchaResponse,\n        iden: captchaIden,\n        sendreplies: sendReplies,\n        sr: subredditName,\n        kind,\n        resubmit,\n        crosspost_fullname,\n        text,\n        title,\n        url,\n        spoiler,\n        nsfw,\n        flair_id: flairId,\n        flair_text: flairText\n      }, options)\n    }).tap((0, _helpers.handleJsonErrors)(this)).then(function (result) {\n      return _this5.getSubmission(result.json.data.id);\n    });\n  }\n  /**\n   * @summary Creates a new selfpost on the given subreddit.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the post should be submitted to\n   * @param {string} options.title The title of the submission\n   * @param {string} [options.text] The selftext of the submission\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * r.submitSelfpost({\n   *   subredditName: 'snoowrap_testing',\n   *   title: 'This is a selfpost',\n   *   text: 'This is the text body of the selfpost'\n   * }).then(console.log)\n   * // => Submission { name: 't3_4abmsz' }\n   * // (new selfpost created on reddit)\n   */\n\n\n  submitSelfpost(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'self'\n    }));\n  }\n  /**\n   * @summary Creates a new link submission on the given subreddit.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the post should be submitted to\n   * @param {string} options.title The title of the submission\n   * @param {string} options.url The url that the link submission should point to\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * r.submitLink({\n   *   subredditName: 'snoowrap_testing',\n   *   title: 'I found a cool website!',\n   *   url: 'https://google.com'\n   * }).then(console.log)\n   * // => Submission { name: 't3_4abnfe' }\n   * // (new linkpost created on reddit)\n   */\n\n\n  submitLink(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'link'\n    }));\n  }\n  /**\n   * @summary Creates a new crosspost submission on the given subreddit\n   * @desc **NOTE**: To create a crosspost, the authenticated account must be subscribed to the subreddit where\n   * the crosspost is being submitted, and that subreddit be configured to allow crossposts.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the crosspost should be submitted to\n   * @param {string} options.title The title of the crosspost\n   * @param {(string|Submission)} options.originalPost A Submission object or a post ID for the original post which\n   is being crossposted\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * await r.submitCrosspost({ title: 'I found an interesting post', originalPost: '6vths0', subredditName: 'snoowrap' })\n   */\n\n\n  submitCrosspost(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'crosspost',\n      crosspost_fullname: options.originalPost instanceof snoowrap.objects.Submission ? options.originalPost.name : (0, _helpers.addFullnamePrefix)(options.originalPost, 't3_')\n    }));\n  }\n\n  _getSortedFrontpage(sortType, subredditName) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Handle things properly if only a time parameter is provided but not the subreddit name\n    var opts = options;\n    var subName = subredditName;\n\n    if (typeof subredditName === 'object' && (0, _lodash.isEmpty)((0, _lodash.omitBy)(opts, function (option) {\n      return option === undefined;\n    }))) {\n      /* In this case, \"subredditName\" ends up referring to the second argument, which is not actually a name since the user\n      decided to omit that parameter. */\n      opts = subredditName;\n      subName = undefined;\n    }\n\n    var parsedOptions = (0, _lodash.omit)(_objectSpread({}, opts, {\n      t: opts.time || opts.t\n    }), 'time');\n    return this._getListing({\n      uri: (subName ? \"r/\".concat(subName, \"/\") : '') + sortType,\n      qs: parsedOptions\n    });\n  }\n  /**\n   * @summary Gets a Listing of hot posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getHot().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'pics' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getHot('gifs').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'gifs' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'gifs' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getHot('redditdev', {limit: 1}).then(console.log)\n   * // => Listing [\n   //   Submission { domain: 'self.redditdev', banned_by: null, subreddit: Subreddit { display_name: 'redditdev' }, ...}\n   * // ]\n   */\n\n\n  getHot(subredditName, options) {\n    return this._getSortedFrontpage('hot', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of best posts.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise<Listing>} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getBest().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'pics' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getBest({limit: 1}).then(console.log)\n   * // => Listing [\n   //   Submission { domain: 'self.redditdev', banned_by: null, subreddit: Subreddit { display_name: 'redditdev' }, ...}\n   * // ]\n   */\n\n\n  getBest(options) {\n    return this._getSortedFrontpage('best', undefined, options);\n  }\n  /**\n   * @summary Gets a Listing of new posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getNew().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.Jokes', banned_by: null, subreddit: Subreddit { display_name: 'Jokes' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  ...\n   * // ]\n   *\n   */\n\n\n  getNew(subredditName, options) {\n    return this._getSortedFrontpage('new', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of new comments.\n   * @param {string} [subredditName] The subreddit to get comments from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved comments\n   * @example\n   *\n   * r.getNewComments().then(console.log)\n   * // => Listing [\n   * //  Comment { link_title: 'What amazing book should be made into a movie, but hasn\\'t been yet?', ... }\n   * //  Comment { link_title: 'How far back in time could you go and still understand English?', ... }\n   * // ]\n   */\n\n\n  getNewComments(subredditName, options) {\n    return this._getSortedFrontpage('comments', subredditName, options);\n  }\n  /**\n   *  @summary Get list of content by IDs. Returns a listing of the requested content.\n   *  @param {Array<string|Submission|Comment>} ids An array of content IDs. Can include the id itself, or a Submission or Comment object.\n  can get a post and a comment   *  @returns {Promise<Listing<Submission|Comment>>} A listing of content requested, can be any class fetchable by API. e.g. Comment, Submission\n   *  @example\n   *\n   * r.getContentByIds(['t3_9l9vof','t3_9la341']).then(console.log);\n   * // => Listing [\n   * //  Submission { approved_at_utc: null, ... }\n   * //  Submission { approved_at_utc: null, ... }\n   * // ]\n   *\n   * r.getContentByIds([r.getSubmission('9l9vof'), r.getSubmission('9la341')]).then(console.log);\n   * // => Listing [\n   * //  Submission { approved_at_utc: null, ... }\n   * //  Submission { approved_at_utc: null, ... }\n   * // ]\n  */\n\n\n  getContentByIds(ids) {\n    if (!Array.isArray(ids)) {\n      throw new TypeError('Invalid argument: Argument needs to be an array.');\n    }\n\n    var prefixedIds = ids.map(function (id) {\n      if (id instanceof snoowrap.objects.Submission || id instanceof snoowrap.objects.Comment) {\n        return id.name;\n      } else if (typeof id === 'string') {\n        if (!/t(1|3)_/g.test(ids)) {\n          throw new TypeError('Invalid argument: Ids need to include Submission or Comment prefix, e.g. t1_, t3_.');\n        }\n\n        return id;\n      }\n\n      throw new TypeError('Id must be either a string, Submission, or Comment.');\n    });\n    return this._get({\n      uri: '/api/info',\n      method: 'get',\n      qs: {\n        id: prefixedIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Gets a single random Submission.\n   * @desc **Note**: This function will not work when snoowrap is running in a browser, because the reddit server sends a\n   redirect which cannot be followed by a CORS request.\n   * @param {string} [subredditName] The subreddit to get the random submission. If not provided, the post is fetched from\n   the front page of reddit.\n   * @returns {Promise} The retrieved Submission object\n   * @example\n   *\n   * r.getRandomSubmission('aww').then(console.log)\n   * // => Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'aww' }, ... }\n   */\n\n\n  getRandomSubmission(subredditName) {\n    return this._get({\n      uri: \"\".concat(subredditName ? \"r/\".concat(subredditName, \"/\") : '', \"random\")\n    });\n  }\n  /**\n   * @summary Gets a Listing of top posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n   `hour, day, week, month, year, all`\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getTop({time: 'all', limit: 2}).then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... }\n   * // ]\n   *\n   * r.getTop('AskReddit').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  ...\n   * // ]\n   */\n\n\n  getTop(subredditName, options) {\n    return this._getSortedFrontpage('top', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of controversial posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n   `hour, day, week, month, year, all`\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getControversial('technology').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'thenextweb.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... },\n   * //  Submission { domain: 'pcmag.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... }\n   * // ]\n   */\n\n\n  getControversial(subredditName, options) {\n    return this._getSortedFrontpage('controversial', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of controversial posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getRising('technology').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'thenextweb.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... },\n   * //  Submission { domain: 'pcmag.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... }\n   * // ]\n   */\n\n\n  getRising(subredditName, options) {\n    return this._getSortedFrontpage('rising', subredditName, options);\n  }\n  /**\n   * @summary Gets the authenticated user's unread messages.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing unread items in the user's inbox\n   * @example\n   *\n   * r.getUnreadMessages().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'hi!', was_comment: false, first_message: null, ... },\n   * //  Comment { body: 'this is a reply', link_title: 'Yay, a selfpost!', was_comment: true, ... }\n   * // ]\n   */\n\n\n  getUnreadMessages() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/unread',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets the items in the authenticated user's inbox.\n   * @param {object} [options={}] Filter options. Can also contain options for the resulting Listing.\n   * @param {string} [options.filter] A filter for the inbox items. If provided, it should be one of `unread`, (unread\n   items), `messages` (i.e. PMs), `comments` (comment replies), `selfreply` (selfpost replies), or `mentions` (username\n   mentions).\n   * @returns {Promise} A Listing containing items in the user's inbox\n   * @example\n   *\n   * r.getInbox().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'hi!', was_comment: false, first_message: null, ... },\n   * //  Comment { body: 'this is a reply', link_title: 'Yay, a selfpost!', was_comment: true, ... }\n   * // ]\n   */\n\n\n  getInbox() {\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        filter = _ref6.filter,\n        options = _objectWithoutProperties(_ref6, [\"filter\"]);\n\n    return this._getListing({\n      uri: \"message/\".concat(filter || 'inbox'),\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets the authenticated user's modmail.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing of the user's modmail\n   * @example\n   *\n   * r.getModmail({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: '/u/not_an_aardvark has accepted an invitation to become moderator ... ', ... },\n   * //  PrivateMessage { body: '/u/not_an_aardvark has been invited by /u/actually_an_aardvark to ...', ... }\n   * // ]\n   */\n\n\n  getModmail() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/moderator',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of ModmailConversations from the authenticated user's subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise<Listing<ModmailConversation>>} A Listing containing Subreddits\n   * @example\n   *\n   * r.getNewModmailConversations({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... },\n   * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... }\n   * // ]\n   */\n\n\n  getNewModmailConversations() {\n    var _this6 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'api/mod/conversations',\n      qs: options,\n      _name: 'ModmailConversation',\n      _transform: function (response) {\n        response.after = null;\n        response.before = null;\n        response.children = [];\n\n        for (var conversation of response.conversationIds) {\n          response.conversations[conversation].participant = _this6._newObject('ModmailConversationAuthor', _objectSpread({}, response.conversations[conversation].participant));\n\n          var conversationObjects = objects.ModmailConversation._getConversationObjects(response.conversations[conversation], response);\n\n          var data = _objectSpread({}, conversationObjects, {}, response.conversations[conversation]);\n\n          response.children.push(_this6._newObject('ModmailConversation', data));\n        }\n\n        return _this6._newObject('Listing', response);\n      }\n    });\n  }\n  /**\n   * @summary Create a new modmail discussion between moderators\n   * @param {object} options\n   * @param {string} options.body Body of the discussion\n   * @param {string} options.subject Title or subject\n   * @param {string} options.srName Subreddit name without fullname\n   * @returns {Promise<ModmailConversation>} the created ModmailConversation\n   * @example\n   *\n   * r.createModeratorDiscussion({\n   *   body: 'test body',\n   *   subject: 'test subject',\n   *   srName: 'AskReddit'\n   * }).then(console.log)\n   * // ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... }\n   */\n\n\n  createModmailDiscussion(_ref7) {\n    var _this7 = this;\n\n    var body = _ref7.body,\n        subject = _ref7.subject,\n        srName = _ref7.srName;\n    var parsedFromSr = srName.replace(/^\\/?r\\//, ''); // Convert '/r/subreddit_name' to 'subreddit_name'\n    // _newObject ignores most of the response, no practical way to parse the returned content yet\n\n    return this._post({\n      uri: 'api/mod/conversations',\n      form: {\n        body,\n        subject,\n        srName: parsedFromSr\n      }\n    }).then(function (res) {\n      return _this7._newObject('ModmailConversation', {\n        id: res.conversation.id\n      });\n    });\n  }\n  /**\n   * @summary Get a ModmailConversation by its id\n   * @param {string} id of the ModmailConversation\n   * @returns {Promise<ModmailConversation>} the requested ModmailConversation\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').then(console.log)\n   * // ModmailConversation { messages: [...], objIds: [...], ... }\n   */\n\n\n  getNewModmailConversation(id) {\n    return this._newObject('ModmailConversation', {\n      id\n    });\n  }\n  /**\n   * @summary Marks all conversations in array as read.\n   * @param {ModmailConversation[]} conversations to mark as read\n   * @example\n   *\n   * r.markNewModmailConversationsAsRead(['pics', 'sweden'])\n   */\n\n\n  markNewModmailConversationsAsRead(conversations) {\n    var conversationIds = conversations.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, '');\n    });\n    return this._post({\n      uri: 'api/mod/conversations/read',\n      form: {\n        conversationIds: conversationIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all conversations in array as unread.\n   * @param {ModmailConversation[]} conversations to mark as unread\n   * @example\n   *\n   * r.markNewModmailConversationsAsUnread(['pics', 'sweden'])\n   */\n\n\n  markNewModmailConversationsAsUnread(conversations) {\n    var conversationIds = conversations.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, '');\n    });\n    return this._post({\n      uri: 'api/mod/conversations/unread',\n      form: {\n        conversationIds: conversationIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Gets all moderated subreddits that have new Modmail activated\n   * @returns {Promise<Listing<Subreddit>>} a Listing of ModmailConversations marked as read\n   * @example\n   *\n   * r.getNewModmailSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit { display_name: 'tipofmytongue', ... },\n   * //  Subreddit { display_name: 'EarthPorn', ... },\n   * // ]\n   */\n\n\n  getNewModmailSubreddits() {\n    var _this8 = this;\n\n    return this._get({\n      uri: 'api/mod/conversations/subreddits'\n    }).then(function (response) {\n      return Object.values(response.subreddits).map(function (s) {\n        return _this8._newObject('Subreddit', s);\n      });\n    });\n  }\n  /**\n   * @summary Represents the unread count in a {@link ModmailConversation}. Each of these properties\n   * correspond to the amount of unread conversations of that type.\n   * @typedef {Object} UnreadCount\n   * @property {number} highlighted\n   * @property {number} notifications\n   * @property {number} archived\n   * @property {number} new\n   * @property {number} inprogress\n   * @property {number} mod\n   */\n\n  /**\n   * @summary Retrieves an object of unread Modmail conversations for each state.\n   * @returns {UnreadCount} unreadCount\n   * @example\n   *\n   * r.getUnreadNewModmailConversationsCount().then(console.log)\n   * // => {\n   * //  archived: 1,\n   * //  appeals: 1,\n   * //  highlighted: 0,\n   * //  notifications: 0,\n   * //  join_requests: 0,\n   * //  new: 2,\n   * //  inprogress: 5,\n   * //  mod: 1,\n   * // }\n   */\n\n\n  getUnreadNewModmailConversationsCount() {\n    return this._get({\n      uri: 'api/mod/conversations/unread/count'\n    });\n  }\n  /**\n   * @summary Mark Modmail conversations as read given the subreddit(s) and state.\n   * @param {Subreddit[]|String[]} subreddits\n   * @param {('archived'|'appeals'|'highlighted'|'notifications'|'join_requests'|'new'|'inprogress'|'mod'|'all')} state selected state to mark as read\n   * @returns {Promise<Listing<ModmailConversation>>} a Listing of ModmailConversations marked as read\n   * @example\n   *\n   * r.bulkReadNewModmail(['AskReddit'], 'all').then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { id: '75hxt' },\n   * //  ModmailConversation { id: '75hxg' }\n   * // ]\n   *\n   * r.bulkReadNewModmail([r.getSubreddit('AskReddit')], 'all').then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { id: '75hxt' },\n   * //  ModmailConversation { id: '75hxg' }\n   * // ]\n   */\n\n\n  bulkReadNewModmail(subreddits, state) {\n    var _this9 = this;\n\n    var subredditNames = subreddits.map(function (s) {\n      return typeof s === 'string' ? s.replace(/^\\/?r\\//, '') : s.display_name;\n    });\n    return this._post({\n      uri: 'api/mod/conversations/bulk/read',\n      form: {\n        entity: subredditNames.join(','),\n        state\n      }\n    }).then(function (res) {\n      return _this9._newObject('Listing', {\n        after: null,\n        before: null,\n        children: res.conversation_ids.map(function (id) {\n          return _this9._newObject('ModmailConversation', {\n            id\n          });\n        })\n      });\n    });\n  }\n  /**\n   * @summary Gets the user's sent messages.\n   * @param {object} [options={}] options for the resulting Listing\n   * @returns {Promise} A Listing of the user's sent messages\n   * @example\n   *\n   * r.getSentMessages().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'you have been added as an approved submitter to ...', ... },\n   * //  PrivateMessage { body: 'you have been banned from posting to ...' ... }\n   * // ]\n   */\n\n\n  getSentMessages() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/sent',\n      qs: options\n    });\n  }\n  /**\n   * @summary Marks all of the given messages as read.\n   * @param {PrivateMessage[]|String[]} messages An Array of PrivateMessage or Comment objects. Can also contain strings\n   representing message or comment IDs. If strings are provided, they are assumed to represent PrivateMessages unless a fullname\n   prefix such as `t1_` is specified.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.markMessagesAsRead(['51shsd', '51shxv'])\n   *\n   * // To reference a comment by ID, be sure to use the `t1_` prefix, otherwise snoowrap will be unable to distinguish the\n   * // comment ID from a PrivateMessage ID.\n   * r.markMessagesAsRead(['t5_51shsd', 't1_d3zhb5k'])\n   *\n   * // Alternatively, just pass in a comment object directly.\n   * r.markMessagesAsRead([r.getMessage('51shsd'), r.getComment('d3zhb5k')])\n   */\n\n\n  markMessagesAsRead(messages) {\n    var messageIds = messages.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, 't4_');\n    });\n    return this._post({\n      uri: 'api/read_message',\n      form: {\n        id: messageIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all of the given messages as unread.\n   * @param {PrivateMessage[]|String[]} messages An Array of PrivateMessage or Comment objects. Can also contain strings\n   representing message IDs. If strings are provided, they are assumed to represent PrivateMessages unless a fullname prefix such\n   as `t1_` is included.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.markMessagesAsUnread(['51shsd', '51shxv'])\n   *\n   * // To reference a comment by ID, be sure to use the `t1_` prefix, otherwise snoowrap will be unable to distinguish the\n   * // comment ID from a PrivateMessage ID.\n   * r.markMessagesAsUnread(['t5_51shsd', 't1_d3zhb5k'])\n   *\n   * // Alternatively, just pass in a comment object directly.\n   * r.markMessagesAsRead([r.getMessage('51shsd'), r.getComment('d3zhb5k')])\n   */\n\n\n  markMessagesAsUnread(messages) {\n    var messageIds = messages.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, 't4_');\n    });\n    return this._post({\n      uri: 'api/unread_message',\n      form: {\n        id: messageIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all of the user's messages as read.\n   * @desc **Note:** The reddit.com site imposes a ratelimit of approximately 1 request every 10 minutes on this endpoint.\n   Further requests will cause the API to return a 429 error.\n   * @returns {Promise} A Promise that resolves when the request is complete\n   * @example\n   *\n   * r.readAllMessages().then(function () {\n   *   r.getUnreadMessages().then(console.log)\n   * })\n   * // => Listing []\n   * // (messages marked as 'read' on reddit)\n   */\n\n\n  readAllMessages() {\n    return this._post({\n      uri: 'api/read_all_messages'\n    });\n  }\n  /**\n   * @summary Composes a new private message.\n   * @param {object} options\n   * @param {RedditUser|Subreddit|string} options.to The recipient of the message.\n   * @param {string} options.subject The message subject (100 characters max)\n   * @param {string} options.text The body of the message, in raw markdown text\n   * @param {Subreddit|string} [options.fromSubreddit] If provided, the message is sent as a modmail from the specified\n   subreddit.\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.composeMessage({\n   *   to: 'actually_an_aardvark',\n   *   subject: \"Hi, how's it going?\",\n   *   text: 'Long time no see'\n   * })\n   * // (message created on reddit)\n   */\n\n\n  composeMessage(_ref8) {\n    var captcha = _ref8.captcha,\n        from_subreddit = _ref8.from_subreddit,\n        _ref8$fromSubreddit = _ref8.fromSubreddit,\n        fromSubreddit = _ref8$fromSubreddit === void 0 ? from_subreddit : _ref8$fromSubreddit,\n        captcha_iden = _ref8.captcha_iden,\n        _ref8$captchaIden = _ref8.captchaIden,\n        captchaIden = _ref8$captchaIden === void 0 ? captcha_iden : _ref8$captchaIden,\n        subject = _ref8.subject,\n        text = _ref8.text,\n        to = _ref8.to;\n    var parsedTo = to;\n    var parsedFromSr = fromSubreddit;\n\n    if (to instanceof snoowrap.objects.RedditUser) {\n      parsedTo = to.name;\n    } else if (to instanceof snoowrap.objects.Subreddit) {\n      parsedTo = \"/r/\".concat(to.display_name);\n    }\n\n    if (fromSubreddit instanceof snoowrap.objects.Subreddit) {\n      parsedFromSr = fromSubreddit.display_name;\n    } else if (typeof fromSubreddit === 'string') {\n      parsedFromSr = fromSubreddit.replace(/^\\/?r\\//, ''); // Convert '/r/subreddit_name' to 'subreddit_name'\n    }\n\n    return this._post({\n      uri: 'api/compose',\n      form: {\n        api_type,\n        captcha,\n        iden: captchaIden,\n        from_sr: parsedFromSr,\n        subject,\n        text,\n        to: parsedTo\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).return({});\n  }\n  /**\n   * @summary Gets a list of all oauth scopes supported by the reddit API.\n   * @desc **Note**: This lists every single oauth scope. To get the scope of this requester, use the `scope` property instead.\n   * @returns {Promise} An object containing oauth scopes.\n   * @example\n   *\n   * r.getOauthScopeList().then(console.log)\n   * // => {\n   * //  creddits: {\n   * //    description: 'Spend my reddit gold creddits on giving gold to other users.',\n   * //    id: 'creddits',\n   * //    name: 'Spend reddit gold creddits'\n   * //  },\n   * //  modcontributors: {\n   * //    description: 'Add/remove users to approved submitter lists and ban/unban or mute/unmute users from ...',\n   * //    id: 'modcontributors',\n   * //    name: 'Approve submitters and ban users'\n   * //  },\n   * //  ...\n   * // }\n   */\n\n\n  getOauthScopeList() {\n    return this._get({\n      uri: 'api/v1/scopes'\n    });\n  }\n  /**\n   * @summary Conducts a search of reddit submissions.\n   * @param {object} options Search options. Can also contain options for the resulting Listing.\n   * @param {string} options.query The search query\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. One of\n   `hour, day, week, month, year, all`\n   * @param {Subreddit|string} [options.subreddit] The subreddit to conduct the search on.\n   * @param {boolean} [options.restrictSr=true] Restricts search results to the given subreddit\n   * @param {string} [options.sort] Determines how the results should be sorted. One of `relevance, hot, top, new, comments`\n   * @param {string} [options.syntax='plain'] Specifies a syntax for the search. One of `cloudsearch, lucene, plain`\n   * @returns {Promise} A Listing containing the search results.\n   * @example\n   *\n   * r.search({\n   *   query: 'Cute kittens',\n   *   subreddit: 'aww',\n   *   sort: 'top'\n   * }).then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, ... },\n   * //  Submission { domain: 'imgur.com', banned_by: null, ... },\n   * //  ...\n   * // ]\n   */\n\n\n  search(options) {\n    if (options.subreddit instanceof snoowrap.objects.Subreddit) {\n      options.subreddit = options.subreddit.display_name;\n    }\n\n    (0, _lodash.defaults)(options, {\n      restrictSr: true,\n      syntax: 'plain'\n    });\n    var parsedQuery = (0, _lodash.omit)(_objectSpread({}, options, {\n      t: options.time,\n      q: options.query,\n      restrict_sr: options.restrictSr\n    }), ['time', 'query']);\n    return this._getListing({\n      uri: \"\".concat(options.subreddit ? \"r/\".concat(options.subreddit, \"/\") : '', \"search\"),\n      qs: parsedQuery\n    });\n  }\n  /**\n   * @summary Searches for subreddits given a query.\n   * @param {object} options\n   * @param {string} options.query A search query (50 characters max)\n   * @param {boolean} [options.exact=false] Determines whether the results shouldbe limited to exact matches.\n   * @param {boolean} [options.includeNsfw=true] Determines whether the results should include NSFW subreddits.\n   * @returns {Promise} An Array containing subreddit names\n   * @example\n   *\n   * r.searchSubredditNames({query: 'programming'}).then(console.log)\n   * // => [\n   * //  'programming',\n   * //  'programmingcirclejerk',\n   * //  'programminghorror',\n   * //  ...\n   * // ]\n   */\n\n\n  searchSubredditNames(_ref9) {\n    var _ref9$exact = _ref9.exact,\n        exact = _ref9$exact === void 0 ? false : _ref9$exact,\n        _ref9$include_nsfw = _ref9.include_nsfw,\n        include_nsfw = _ref9$include_nsfw === void 0 ? true : _ref9$include_nsfw,\n        _ref9$includeNsfw = _ref9.includeNsfw,\n        includeNsfw = _ref9$includeNsfw === void 0 ? include_nsfw : _ref9$includeNsfw,\n        query = _ref9.query;\n    return this._post({\n      uri: 'api/search_reddit_names',\n      qs: {\n        exact,\n        include_over_18: includeNsfw,\n        query\n      }\n    }).get('names');\n  }\n\n  _createOrEditSubreddit(_ref10) {\n    var _ref10$allow_images = _ref10.allow_images,\n        allow_images = _ref10$allow_images === void 0 ? true : _ref10$allow_images,\n        _ref10$allow_top = _ref10.allow_top,\n        allow_top = _ref10$allow_top === void 0 ? true : _ref10$allow_top,\n        captcha = _ref10.captcha,\n        captcha_iden = _ref10.captcha_iden,\n        _ref10$collapse_delet = _ref10.collapse_deleted_comments,\n        collapse_deleted_comments = _ref10$collapse_delet === void 0 ? false : _ref10$collapse_delet,\n        _ref10$comment_score_ = _ref10.comment_score_hide_mins,\n        comment_score_hide_mins = _ref10$comment_score_ === void 0 ? 0 : _ref10$comment_score_,\n        description = _ref10.description,\n        _ref10$exclude_banned = _ref10.exclude_banned_modqueue,\n        exclude_banned_modqueue = _ref10$exclude_banned === void 0 ? false : _ref10$exclude_banned,\n        header_title = _ref10['header-title'],\n        _ref10$hide_ads = _ref10.hide_ads,\n        hide_ads = _ref10$hide_ads === void 0 ? false : _ref10$hide_ads,\n        _ref10$lang = _ref10.lang,\n        lang = _ref10$lang === void 0 ? 'en' : _ref10$lang,\n        _ref10$link_type = _ref10.link_type,\n        link_type = _ref10$link_type === void 0 ? 'any' : _ref10$link_type,\n        name = _ref10.name,\n        _ref10$over_ = _ref10.over_18,\n        over_18 = _ref10$over_ === void 0 ? false : _ref10$over_,\n        public_description = _ref10.public_description,\n        _ref10$public_traffic = _ref10.public_traffic,\n        public_traffic = _ref10$public_traffic === void 0 ? false : _ref10$public_traffic,\n        _ref10$show_media = _ref10.show_media,\n        show_media = _ref10$show_media === void 0 ? false : _ref10$show_media,\n        _ref10$show_media_pre = _ref10.show_media_preview,\n        show_media_preview = _ref10$show_media_pre === void 0 ? true : _ref10$show_media_pre,\n        _ref10$spam_comments = _ref10.spam_comments,\n        spam_comments = _ref10$spam_comments === void 0 ? 'high' : _ref10$spam_comments,\n        _ref10$spam_links = _ref10.spam_links,\n        spam_links = _ref10$spam_links === void 0 ? 'high' : _ref10$spam_links,\n        _ref10$spam_selfposts = _ref10.spam_selfposts,\n        spam_selfposts = _ref10$spam_selfposts === void 0 ? 'high' : _ref10$spam_selfposts,\n        _ref10$spoilers_enabl = _ref10.spoilers_enabled,\n        spoilers_enabled = _ref10$spoilers_enabl === void 0 ? false : _ref10$spoilers_enabl,\n        sr = _ref10.sr,\n        _ref10$submit_link_la = _ref10.submit_link_label,\n        submit_link_label = _ref10$submit_link_la === void 0 ? '' : _ref10$submit_link_la,\n        _ref10$submit_text_la = _ref10.submit_text_label,\n        submit_text_label = _ref10$submit_text_la === void 0 ? '' : _ref10$submit_text_la,\n        _ref10$submit_text = _ref10.submit_text,\n        submit_text = _ref10$submit_text === void 0 ? '' : _ref10$submit_text,\n        _ref10$suggested_comm = _ref10.suggested_comment_sort,\n        suggested_comment_sort = _ref10$suggested_comm === void 0 ? 'confidence' : _ref10$suggested_comm,\n        title = _ref10.title,\n        _ref10$type = _ref10.type,\n        type = _ref10$type === void 0 ? 'public' : _ref10$type,\n        wiki_edit_age = _ref10.wiki_edit_age,\n        wiki_edit_karma = _ref10.wiki_edit_karma,\n        _ref10$wikimode = _ref10.wikimode,\n        wikimode = _ref10$wikimode === void 0 ? 'modonly' : _ref10$wikimode,\n        otherKeys = _objectWithoutProperties(_ref10, [\"allow_images\", \"allow_top\", \"captcha\", \"captcha_iden\", \"collapse_deleted_comments\", \"comment_score_hide_mins\", \"description\", \"exclude_banned_modqueue\", \"header-title\", \"hide_ads\", \"lang\", \"link_type\", \"name\", \"over_18\", \"public_description\", \"public_traffic\", \"show_media\", \"show_media_preview\", \"spam_comments\", \"spam_links\", \"spam_selfposts\", \"spoilers_enabled\", \"sr\", \"submit_link_label\", \"submit_text_label\", \"submit_text\", \"suggested_comment_sort\", \"title\", \"type\", \"wiki_edit_age\", \"wiki_edit_karma\", \"wikimode\"]);\n\n    return this._post({\n      uri: 'api/site_admin',\n      form: _objectSpread({\n        allow_images,\n        allow_top,\n        api_type,\n        captcha,\n        collapse_deleted_comments,\n        comment_score_hide_mins,\n        description,\n        exclude_banned_modqueue,\n        'header-title': header_title,\n        hide_ads,\n        iden: captcha_iden,\n        lang,\n        link_type,\n        name,\n        over_18,\n        public_description,\n        public_traffic,\n        show_media,\n        show_media_preview,\n        spam_comments,\n        spam_links,\n        spam_selfposts,\n        spoilers_enabled,\n        sr,\n        submit_link_label,\n        submit_text,\n        submit_text_label,\n        suggested_comment_sort,\n        title,\n        type,\n        wiki_edit_age,\n        wiki_edit_karma,\n        wikimode\n      }, otherKeys)\n    }).then((0, _helpers.handleJsonErrors)(this.getSubreddit(name || sr)));\n  }\n  /**\n   * @summary Creates a new subreddit.\n   * @param {object} options\n   * @param {string} options.name The name of the new subreddit\n   * @param {string} options.title The text that should appear in the header of the subreddit\n   * @param {string} options.public_description The text that appears with this subreddit on the search page, or on the\n   blocked-access page if this subreddit is private. (500 characters max)\n   * @param {string} options.description The sidebar text for the subreddit. (5120 characters max)\n   * @param {string} [options.submit_text=''] The text to show below the submission page (1024 characters max)\n   * @param {boolean} [options.hide_ads=false] Determines whether ads should be hidden on this subreddit. (This is only\n   allowed for gold-only subreddits.)\n   * @param {string} [options.lang='en'] The language of the subreddit (represented as an IETF language tag)\n   * @param {string} [options.type='public'] Determines who should be able to access the subreddit. This should be one of\n   `public, private, restricted, gold_restricted, gold_only, archived, employees_only`.\n   * @param {string} [options.link_type='any'] Determines what types of submissions are allowed on the subreddit. This should\n   be one of `any, link, self`.\n   * @param {string} [options.submit_link_label=undefined] Custom text to display on the button that submits a link. If\n   this is omitted, the default text will be displayed.\n   * @param {string} [options.submit_text_label=undefined] Custom text to display on the button that submits a selfpost. If\n   this is omitted, the default text will be displayed.\n   * @param {string} [options.wikimode='modonly'] Determines who can edit wiki pages on the subreddit. This should be one of\n   `modonly, anyone, disabled`.\n   * @param {number} [options.wiki_edit_karma=0] The minimum amount of subreddit karma needed for someone to edit this\n   subreddit's wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n   * @param {number} [options.wiki_edit_age=0] The minimum account age (in days) needed for someone to edit this subreddit's\n   wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n   * @param {string} [options.spam_links='high'] The spam filter strength for links on this subreddit. This should be one of\n   `low, high, all`.\n   * @param {string} [options.spam_selfposts='high'] The spam filter strength for selfposts on this subreddit. This should be\n   one of `low, high, all`.\n   * @param {string} [options.spam_comments='high'] The spam filter strength for comments on this subreddit. This should be one\n   of `low, high, all`.\n   * @param {boolean} [options.over_18=false] Determines whether this subreddit should be classified as NSFW\n   * @param {boolean} [options.allow_top=true] Determines whether the new subreddit should be able to appear in /r/all and\n   trending subreddits\n   * @param {boolean} [options.show_media=false] Determines whether image thumbnails should be enabled on this subreddit\n   * @param {boolean} [options.show_media_preview=true] Determines whether media previews should be expanded by default on this\n   subreddit\n   * @param {boolean} [options.allow_images=true] Determines whether image uploads and links to image hosting sites should be\n   enabled on this subreddit\n   * @param {boolean} [options.exclude_banned_modqueue=false] Determines whether posts by site-wide banned users should be\n   excluded from the modqueue.\n   * @param {boolean} [options.public_traffic=false] Determines whether the /about/traffic page for this subreddit should be\n   viewable by anyone.\n   * @param {boolean} [options.collapse_deleted_comments=false] Determines whether deleted and removed comments should be\n   collapsed by default\n   * @param {string} [options.suggested_comment_sort=undefined] The suggested comment sort for the subreddit. This should be\n   one of `confidence, top, new, controversial, old, random, qa`.If left blank, there will be no suggested sort,\n   which means that users will see the sort method that is set in their own preferences (usually `confidence`.)\n   * @param {boolean} [options.spoilers_enabled=false] Determines whether users can mark their posts as spoilers\n   * @returns {Promise} A Promise for the newly-created subreddit object.\n   * @example\n   *\n   * r.createSubreddit({\n   *   name: 'snoowrap_testing2',\n   *   title: 'snoowrap testing: the sequel',\n   *   public_description: 'thanks for reading the snoowrap docs!',\n   *   description: 'This text will go on the sidebar',\n   *   type: 'private'\n   * }).then(console.log)\n   * // => Subreddit { display_name: 'snoowrap_testing2' }\n   * // (/r/snoowrap_testing2 created on reddit)\n   */\n\n\n  createSubreddit(options) {\n    return this._createOrEditSubreddit(options);\n  }\n  /**\n   * @summary Searches subreddits by topic.\n   * @param {object} options\n   * @param {string} options.query The search query. (50 characters max)\n   * @returns {Promise} An Array of subreddit objects corresponding to the search results\n   * @deprecated Reddit no longer provides the corresponding API endpoint.\n   * @example\n   *\n   * r.searchSubredditTopics({query: 'movies'}).then(console.log)\n   * // => [\n   * //  Subreddit { display_name: 'tipofmytongue' },\n   * //  Subreddit { display_name: 'remove' },\n   * //  Subreddit { display_name: 'horror' },\n   * //  ...\n   * // ]\n   */\n\n\n  searchSubredditTopics(_ref11) {\n    var _this10 = this;\n\n    var query = _ref11.query;\n    return this._get({\n      uri: 'api/subreddits_by_topic',\n      qs: {\n        query\n      }\n    }).map(function (result) {\n      return _this10.getSubreddit(result.name);\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits that the currently-authenticated user is subscribed to.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getSubscriptions({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'gadgets',\n   * //    title: 'reddit gadget guide',\n   * //    ...\n   * //  },\n   * //  Subreddit {\n   * //    display_name: 'sports',\n   * //    title: 'the sportspage of the Internet',\n   * //    ...\n   * //  }\n   * // ]\n   */\n\n\n  getSubscriptions(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/subscriber',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits in which the currently-authenticated user is an approved submitter.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getContributorSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'snoowrap_testing',\n   * //    title: 'snoowrap',\n   * //    ...\n   * //  }\n   * // ]\n   *\n   */\n\n\n  getContributorSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/contributor',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits in which the currently-authenticated user is a moderator.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getModeratedSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'snoowrap_testing',\n   * //    title: 'snoowrap',\n   * //    ...\n   * //  }\n   * // ]\n   */\n\n\n  getModeratedSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/moderator',\n      qs: options\n    });\n  }\n  /**\n   * @summary Searches subreddits by title and description.\n   * @param {object} options Options for the search. May also contain Listing parameters.\n   * @param {string} options.query The search query\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.searchSubreddits({query: 'cookies'}).then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  searchSubreddits(options) {\n    options.q = options.query;\n    return this._getListing({\n      uri: 'subreddits/search',\n      qs: (0, _lodash.omit)(options, 'query')\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits, arranged by popularity.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getPopularSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getPopularSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/popular',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits, arranged by age.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getNewSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getNewSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/new',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of gold-exclusive subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getGoldSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getGoldSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/gold',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of default subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getDefaultSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getDefaultSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/default',\n      qs: options\n    });\n  }\n  /**\n   * @summary Checks whether a given username is available for registration\n   * @desc **Note:** This function will not work when snoowrap is running in a browser, due to an issue with reddit's CORS\n   settings.\n   * @param {string} name The username in question\n   * @returns {Promise} A Promise that fulfills with a Boolean (`true` or `false`)\n   * @example\n   *\n   * r.checkUsernameAvailability('not_an_aardvark').then(console.log)\n   * // => false\n   * r.checkUsernameAvailability('eqwZAr9qunx7IHqzWVeF').then(console.log)\n   * // => true\n   */\n\n\n  checkUsernameAvailability(name) {\n    // The oauth endpoint listed in reddit's documentation doesn't actually work, so just send an unauthenticated request.\n    return this.unauthenticatedRequest({\n      uri: 'api/username_available.json',\n      qs: {\n        user: name\n      }\n    });\n  }\n  /**\n   * @summary Creates a new LiveThread.\n   * @param {object} options\n   * @param {string} options.title The title of the livethread (100 characters max)\n   * @param {string} [options.description] A descriptions of the thread. 120 characters max\n   * @param {string} [options.resources] Information and useful links related to the thread. 120 characters max\n   * @param {boolean} [options.nsfw=false] Determines whether the thread is Not Safe For Work\n   * @returns {Promise} A Promise that fulfills with the new LiveThread when the request is complete\n   * @example\n   *\n   * r.createLivethread({title: 'My livethread'}).then(console.log)\n   * // => LiveThread { id: 'wpimncm1f01j' }\n   */\n\n\n  createLivethread(_ref12) {\n    var _this11 = this;\n\n    var title = _ref12.title,\n        description = _ref12.description,\n        resources = _ref12.resources,\n        _ref12$nsfw = _ref12.nsfw,\n        nsfw = _ref12$nsfw === void 0 ? false : _ref12$nsfw;\n    return this._post({\n      uri: 'api/live/create',\n      form: {\n        api_type,\n        description,\n        nsfw,\n        resources,\n        title\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).then(function (result) {\n      return _this11.getLivethread(result.json.data.id);\n    });\n  }\n  /**\n   * @summary Gets the \"happening now\" LiveThread, if it exists\n   * @desc This is the LiveThread that is occasionally linked at the top of reddit.com, relating to current events.\n   * @returns {Promise} A Promise that fulfills with the \"happening now\" LiveThread if it exists, or rejects with a 404 error\n   otherwise.\n   * @example r.getCurrentEventsLivethread().then(thread => thread.stream.on('update', console.log))\n   */\n\n\n  getStickiedLivethread() {\n    return this._get({\n      uri: 'api/live/happening_now'\n    });\n  }\n  /**\n   * @summary Gets the user's own multireddits.\n   * @returns {Promise} A Promise for an Array containing the requester's MultiReddits.\n   * @example\n   *\n   * r.getMyMultireddits().then(console.log)\n   * => [ MultiReddit { ... }, MultiReddit { ... }, ... ]\n   */\n\n\n  getMyMultireddits() {\n    return this._get({\n      uri: 'api/multi/mine',\n      qs: {\n        expand_srs: true\n      }\n    });\n  }\n  /**\n   * @summary Creates a new multireddit.\n   * @param {object} options\n   * @param {string} options.name The name of the new multireddit. 50 characters max\n   * @param {string} options.description A description for the new multireddit, in markdown.\n   * @param {Array} options.subreddits An Array of Subreddit objects (or subreddit names) that this multireddit should compose of\n   * @param {string} [options.visibility='private'] The multireddit's visibility setting. One of `private`, `public`, `hidden`.\n   * @param {string} [options.icon_name=''] One of `art and design`, `ask`, `books`, `business`, `cars`, `comics`,\n   `cute animals`, `diy`, `entertainment`, `food and drink`, `funny`, `games`, `grooming`, `health`, `life advice`, `military`,\n   `models pinup`, `music`, `news`, `philosophy`, `pictures and gifs`, `science`, `shopping`, `sports`, `style`, `tech`,\n   `travel`, `unusual stories`, `video`, `None`\n   * @param {string} [options.key_color='#000000'] A six-digit RGB hex color, preceded by '#'\n   * @param {string} [options.weighting_scheme='classic'] One of `classic`, `fresh`\n   * @returns {Promise} A Promise for the newly-created MultiReddit object\n   * @example\n   *\n   * r.createMultireddit({\n   *   name: 'myMulti',\n   *   description: 'An example multireddit',\n   *   subreddits: ['snoowrap', 'snoowrap_testing']\n   * }).then(console.log)\n   * => MultiReddit { display_name: 'myMulti', ... }\n   */\n\n\n  createMultireddit(_ref13) {\n    var name = _ref13.name,\n        description = _ref13.description,\n        subreddits = _ref13.subreddits,\n        _ref13$visibility = _ref13.visibility,\n        visibility = _ref13$visibility === void 0 ? 'private' : _ref13$visibility,\n        _ref13$icon_name = _ref13.icon_name,\n        icon_name = _ref13$icon_name === void 0 ? '' : _ref13$icon_name,\n        _ref13$key_color = _ref13.key_color,\n        key_color = _ref13$key_color === void 0 ? '#000000' : _ref13$key_color,\n        _ref13$weighting_sche = _ref13.weighting_scheme,\n        weighting_scheme = _ref13$weighting_sche === void 0 ? 'classic' : _ref13$weighting_sche;\n    return this._post({\n      uri: 'api/multi',\n      form: {\n        model: JSON.stringify({\n          display_name: name,\n          description_md: description,\n          icon_name,\n          key_color,\n          subreddits: subreddits.map(function (sub) {\n            return {\n              name: typeof sub === 'string' ? sub : sub.display_name\n            };\n          }),\n          visibility,\n          weighting_scheme\n        })\n      }\n    });\n  }\n\n  _revokeToken(token) {\n    return this.credentialedClientRequest({\n      uri: 'api/v1/revoke_token',\n      form: {\n        token\n      },\n      method: 'post'\n    });\n  }\n  /**\n   * @summary Invalidates the current access token.\n   * @returns {Promise} A Promise that fulfills when this request is complete\n   * @desc **Note**: This can only be used if the current requester was supplied with a `client_id` and `client_secret`. If the\n   current requester was supplied with a refresh token, it will automatically create a new access token if any more requests\n   are made after this one.\n   * @example r.revokeAccessToken();\n   */\n\n\n  revokeAccessToken() {\n    var _this12 = this;\n\n    return this._revokeToken(this.accessToken).then(function () {\n      _this12.accessToken = null;\n      _this12.tokenExpiration = null;\n    });\n  }\n  /**\n   * @summary Invalidates the current refresh token.\n   * @returns {Promise} A Promise that fulfills when this request is complete\n   * @desc **Note**: This can only be used if the current requester was supplied with a `client_id` and `client_secret`. All\n   access tokens generated by this refresh token will also be invalidated. This effectively de-authenticates the requester and\n   prevents it from making any more valid requests. This should only be used in a few cases, e.g. if this token has\n   been accidentally leaked to a third party.\n   * @example r.revokeRefreshToken();\n   */\n\n\n  revokeRefreshToken() {\n    var _this13 = this;\n\n    return this._revokeToken(this.refreshToken).then(function () {\n      _this13.refreshToken = null;\n      _this13.accessToken = null; // Revoking a refresh token also revokes any associated access tokens.\n\n      _this13.tokenExpiration = null;\n    });\n  }\n\n  _selectFlair(_ref14) {\n    var _this14 = this;\n\n    var flair_template_id = _ref14.flair_template_id,\n        link = _ref14.link,\n        name = _ref14.name,\n        text = _ref14.text,\n        subredditName = _ref14.subredditName;\n\n    if (!flair_template_id) {\n      throw new errors.InvalidMethodCallError('No flair template ID provided');\n    }\n\n    return _Promise.default.resolve(subredditName).then(function (subName) {\n      return _this14._post({\n        uri: \"r/\".concat(subName, \"/api/selectflair\"),\n        form: {\n          api_type,\n          flair_template_id,\n          link,\n          name,\n          text\n        }\n      });\n    });\n  }\n\n  _assignFlair(_ref15) {\n    var _this15 = this;\n\n    var css_class = _ref15.css_class,\n        _ref15$cssClass = _ref15.cssClass,\n        cssClass = _ref15$cssClass === void 0 ? css_class : _ref15$cssClass,\n        link = _ref15.link,\n        name = _ref15.name,\n        text = _ref15.text,\n        subreddit_name = _ref15.subreddit_name,\n        _ref15$subredditName = _ref15.subredditName,\n        subredditName = _ref15$subredditName === void 0 ? subreddit_name : _ref15$subredditName;\n    return this._promiseWrap(_Promise.default.resolve(subredditName).then(function (displayName) {\n      return _this15._post({\n        uri: \"r/\".concat(displayName, \"/api/flair\"),\n        form: {\n          api_type,\n          name,\n          text,\n          link,\n          css_class: cssClass\n        }\n      });\n    }));\n  }\n\n  _populate(responseTree) {\n    var _this16 = this;\n\n    if (typeof responseTree === 'object' && responseTree !== null) {\n      // Map {kind: 't2', data: {name: 'some_username', ... }} to a RedditUser (e.g.) with the same properties\n      if (Object.keys(responseTree).length === 2 && responseTree.kind && responseTree.data) {\n        return this._newObject(_constants.KINDS[responseTree.kind] || 'RedditContent', this._populate(responseTree.data), true);\n      }\n\n      var result = (Array.isArray(responseTree) ? _lodash.map : _lodash.mapValues)(responseTree, function (value, key) {\n        // Maps {author: 'some_username'} to {author: RedditUser { name: 'some_username' } }\n        if (value !== null && _constants.USER_KEYS.has(key)) {\n          return _this16._newObject('RedditUser', {\n            name: value\n          });\n        }\n\n        if (value !== null && _constants.SUBREDDIT_KEYS.has(key)) {\n          return _this16._newObject('Subreddit', {\n            display_name: value\n          });\n        }\n\n        return _this16._populate(value);\n      });\n\n      if (result.length === 2 && result[0] instanceof snoowrap.objects.Listing && result[0][0] instanceof snoowrap.objects.Submission && result[1] instanceof snoowrap.objects.Listing) {\n        if (result[1]._more && !result[1]._more.link_id) {\n          result[1]._more.link_id = result[0][0].name;\n        }\n\n        result[0][0].comments = result[1];\n        return result[0][0];\n      }\n\n      return result;\n    }\n\n    return responseTree;\n  }\n\n  _getListing(_ref16) {\n    var uri = _ref16.uri,\n        _ref16$qs = _ref16.qs,\n        qs = _ref16$qs === void 0 ? {} : _ref16$qs,\n        options = _objectWithoutProperties(_ref16, [\"uri\", \"qs\"]);\n\n    /* When the response type is expected to be a Listing, add a `count` parameter with a very high number.\n    This ensures that reddit returns a `before` property in the resulting Listing to enable pagination.\n    (Aside from the additional parameter, this function is equivalent to snoowrap.prototype._get) */\n    var mergedQuery = _objectSpread({\n      count: 9999\n    }, qs);\n\n    return qs.limit || !(0, _lodash.isEmpty)(options) ? this._newObject('Listing', _objectSpread({\n      _query: mergedQuery,\n      _uri: uri\n    }, options)).fetchMore(qs.limit || _constants.MAX_LISTING_ITEMS)\n    /* This second case is used as a fallback in case the endpoint unexpectedly ends up returning something other than a\n    Listing (e.g. Submission#getRelated, which used to return a Listing but no longer does due to upstream reddit API\n    changes), in which case using fetch_more() as above will throw an error.\n     This fallback only works if there are no other meta-properties provided for the Listing, such as _transform. If there are\n    other meta-properties,  the function will still end up throwing an error, but there's not really any good way to handle it\n    (predicting upstream changes can only go so far). More importantly, in the limited cases where it's used, the fallback\n    should have no effect on the returned results */\n    : this._get({\n      uri,\n      qs: mergedQuery\n    }).then(function (listing) {\n      if (Array.isArray(listing)) {\n        listing.filter(function (item) {\n          return item.constructor._name === 'Comment';\n        }).forEach(_helpers.addEmptyRepliesListing);\n      }\n\n      return listing;\n    });\n  }\n  /**\n   * @summary In browsers, restores the `window.snoowrap` property to whatever it was before this instance of snoowrap was\n   loaded. This is a no-op in Node.\n   * @returns This instance of the snoowrap constructor\n   * @example var snoowrap = window.snoowrap.noConflict();\n   */\n\n\n  static noConflict() {\n    if (_helpers.isBrowser) {\n      global[_constants.MODULE_NAME] = this._previousSnoowrap;\n    }\n\n    return this;\n  }\n\n};\n\nfunction identity(value) {\n  return value;\n}\n\n(0, _helpers.defineInspectFunc)(snoowrap.prototype, function () {\n  // Hide confidential information (tokens, client IDs, etc.), as well as private properties, from the console.log output.\n  var keysForHiddenValues = ['clientSecret', 'refreshToken', 'accessToken', 'password'];\n  var formatted = (0, _lodash.mapValues)((0, _lodash.omitBy)(this, function (value, key) {\n    return typeof key === 'string' && key.startsWith('_');\n  }), function (value, key) {\n    return (0, _lodash.includes)(keysForHiddenValues, key) ? value && '(redacted)' : value;\n  });\n  return \"\".concat(_constants.MODULE_NAME, \" \").concat(_util.default.inspect(formatted));\n});\nvar classFuncDescriptors = {\n  configurable: true,\n  writable: true\n};\n/* Add the request_handler functions (oauth_request, credentialed_client_request, etc.) to the snoowrap prototype. Use\nObject.defineProperties to ensure that the properties are non-enumerable. */\n\nObject.defineProperties(snoowrap.prototype, (0, _lodash.mapValues)(requestHandler, function (func) {\n  return _objectSpread({\n    value: func\n  }, classFuncDescriptors);\n}));\n\n_constants.HTTP_VERBS.forEach(function (method) {\n  /* Define method shortcuts for each of the HTTP verbs. i.e. `snoowrap.prototype._post` is the same as `oauth_request` except\n  that the HTTP method defaults to `post`, and the result is promise-wrapped. Use Object.defineProperty to ensure that the\n  properties are non-enumerable. */\n  Object.defineProperty(snoowrap.prototype, \"_\".concat(method), _objectSpread({\n    value(options) {\n      return this._promiseWrap(this.oauthRequest(_objectSpread({}, options, {\n        method\n      })));\n    }\n\n  }, classFuncDescriptors));\n});\n/* `objects` will be an object containing getters for each content type, due to the way objects are exported from\nobjects/index.js. To unwrap these getters into direct properties, use lodash.mapValues with an identity function. */\n\n\nsnoowrap.objects = (0, _lodash.mapValues)(objects, function (value) {\n  return value;\n});\n(0, _lodash.forOwn)(_constants.KINDS, function (value) {\n  snoowrap.objects[value] = snoowrap.objects[value] || class extends objects.RedditContent {};\n  Object.defineProperty(snoowrap.objects[value], '_name', {\n    value,\n    configurable: true\n  });\n}); // Alias all functions on snoowrap's prototype and snoowrap's object prototypes in snake_case.\n\n(0, _lodash.values)(snoowrap.objects).concat(snoowrap).map(function (func) {\n  return func.prototype;\n}).forEach(function (funcProto) {\n  Object.getOwnPropertyNames(funcProto).filter(function (name) {\n    return !name.startsWith('_') && name !== (0, _lodash.snakeCase)(name) && typeof funcProto[name] === 'function';\n  }).forEach(function (name) {\n    return Object.defineProperty(funcProto, (0, _lodash.snakeCase)(name), _objectSpread({\n      value: funcProto[name]\n    }, classFuncDescriptors));\n  });\n});\nsnoowrap.errors = errors;\nsnoowrap.version = _constants.VERSION;\n\nif (!module.parent && _helpers.isBrowser) {\n  // check if the code is being run in a browser through browserify, etc.\n  snoowrap._previousSnoowrap = global[_constants.MODULE_NAME];\n  global[_constants.MODULE_NAME] = snoowrap;\n}\n\nmodule.exports = snoowrap;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9zbm9vd3JhcC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHFEQUFROztBQUU5QixzQ0FBc0MsbUJBQU8sQ0FBQyxtRUFBYzs7QUFFNUQsNENBQTRDLG1CQUFPLENBQUMsb0VBQWdCOztBQUVwRSxtQ0FBbUMsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFakQsNkNBQTZDLG1CQUFPLENBQUMsbUZBQXNCOztBQUUzRSxpQkFBaUIsbUJBQU8sQ0FBQyx1RUFBZ0I7O0FBRXpDLHFDQUFxQyxtQkFBTyxDQUFDLGlFQUFhOztBQUUxRCxlQUFlLG1CQUFPLENBQUMsbUVBQWM7O0FBRXJDLDRDQUE0QyxtQkFBTyxDQUFDLCtFQUFvQjs7QUFFeEUsc0NBQXNDLG1CQUFPLENBQUMsK0VBQW9COztBQUVsRSx3Q0FBd0MsNkJBQTZCLGNBQWMsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1QixzREFBc0Qsc0hBQXNILDRCQUE0Qiw0Q0FBNEMsT0FBTyxnQ0FBZ0Msc0JBQXNCOztBQUV0Yyx1Q0FBdUMsdUNBQXVDOztBQUU5RSxzREFBc0QsK0JBQStCLDhEQUE4RCxZQUFZLG9DQUFvQyw2REFBNkQsWUFBWSw2QkFBNkIsT0FBTywyQkFBMkIsMENBQTBDLHdFQUF3RSwrQkFBK0I7O0FBRTVkLDJEQUEyRCwrQkFBK0IsaUJBQWlCLHNDQUFzQyxZQUFZLFlBQVksdUJBQXVCLE9BQU8scUJBQXFCLDBDQUEwQyw2QkFBNkI7O0FBRW5TLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsaUVBQWlFLEdBQUcsa0NBQWtDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLCtDQUErQyw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8seUNBQXlDLG1GQUFtRixPQUFPOztBQUV0Ziw0Q0FBNEMsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFv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O0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC9zbm9vd3JhcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9sb2Rhc2ggPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuXG52YXIgX1Byb21pc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1Byb21pc2UuanNcIikpO1xuXG52YXIgX3Byb21pc2VDaGFpbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9taXNlLWNoYWluc1wiKSk7XG5cbnZhciBfdXRpbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInV0aWxcIikpO1xuXG52YXIgcmVxdWVzdEhhbmRsZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9yZXF1ZXN0X2hhbmRsZXIuanNcIikpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxudmFyIGVycm9ycyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSk7XG5cbnZhciBfaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIik7XG5cbnZhciBfY3JlYXRlX2NvbmZpZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY3JlYXRlX2NvbmZpZy5qc1wiKSk7XG5cbnZhciBvYmplY3RzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vb2JqZWN0cy9pbmRleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGFwaV90eXBlID0gJ2pzb24nO1xuLyoqIFRoZSBjbGFzcyBmb3IgYSBzbm9vd3JhcCByZXF1ZXN0ZXIuXG4gKiBBIHJlcXVlc3RlciBpcyB0aGUgYmFzZSBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSByZWRkaXQuIEVhY2ggcmVxdWVzdGVyIGNvbnRhaW5zIGEgc2luZ2xlIHNldCBvZiBPQXV0aFxuIHRva2Vucy5cblxuIElmIGNvbnN0cnVjdGVkIHdpdGggYSByZWZyZXNoIHRva2VuLCBhIHJlcXVlc3RlciB3aWxsIGJlIGFibGUgdG8gcmVwZWF0ZWRseSBnZW5lcmF0ZSBhY2Nlc3MgdG9rZW5zIGFzIG5lY2Vzc2FyeSwgd2l0aG91dCBhbnlcbiBmdXJ0aGVyIHVzZXIgaW50ZXJ2ZW50aW9uLiBBZnRlciBtYWtpbmcgYXQgbGVhc3Qgb25lIHJlcXVlc3QsIGEgcmVxdWVzdGVyIHdpbGwgaGF2ZSB0aGUgYGFjY2Vzc190b2tlbmAgcHJvcGVydHksIHdoaWNoIHNwZWNpZmllc1xuIHRoZSBhY2Nlc3MgdG9rZW4gY3VycmVudGx5IGluIHVzZS4gSXQgd2lsbCBhbHNvIGhhdmUgYSBmZXcgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHN1Y2ggYXMgYHNjb3BlYCAoYW4gYXJyYXkgb2Ygc2NvcGUgc3RyaW5ncylcbiBhbmQgYHJhdGVsaW1pdFJlbWFpbmluZ2AgKHRoZSBudW1iZXIgb2YgcmVxdWVzdHMgcmVtYWluaW5nIGZvciB0aGUgY3VycmVudCAxMC1taW51dGUgaW50ZXJ2YWwsIGluIGNvbXBsaWFuY2Ugd2l0aCByZWRkaXQnc1xuIFtBUEkgcnVsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWRkaXQvcmVkZGl0L3dpa2kvQVBJKS4pIFRoZXNlIHByb3BlcnRpZXMgcHJpbWFyaWx5IGV4aXN0IGZvciBpbnRlcm5hbCB1c2UsIGJ1dCB0aGV5IGFyZVxuIGV4cG9zZWQgc2luY2UgdGhleSBhcmUgdXNlZnVsIGV4dGVybmFsbHkgYXMgd2VsbC5cbiAqL1xuXG52YXIgc25vb3dyYXAgPSBjbGFzcyBzbm9vd3JhcCB7XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RzIGEgbmV3IHJlcXVlc3Rlci5cbiAgICogQGRlc2MgWW91IHNob3VsZCB1c2UgdGhlIHNub293cmFwIGNvbnN0cnVjdG9yIGlmIHlvdSBhcmUgYWJsZSB0byBhdXRob3JpemUgYSByZWRkaXQgYWNjb3VudCBpbiBhZHZhbmNlIChlLmcuIGZvciBhIE5vZGUuanNcbiAgIHNjcmlwdCB0aGF0IGFsd2F5cyB1c2VzIHRoZSBzYW1lIGFjY291bnQpLiBJZiB5b3UgYXJlbid0IGFibGUgdG8gYXV0aG9yaXplIGluIGFkdmFuY2UgKGUuZy4gYWN0aW5nIHRocm91Z2ggYW4gYXJiaXRyYXJ5IHVzZXInc1xuICAgYWNjb3VudCB3aGlsZSBydW5uaW5nIHNub293cmFwIGluIGEgYnJvd3NlciksIHRoZW4geW91IHNob3VsZCB1c2Uge0BsaW5rIHNub293cmFwLmdldEF1dGhVcmx9IGFuZFxuICAge0BsaW5rIHNub293cmFwLmZyb21BdXRoQ29kZX0gaW5zdGVhZC5cbiAgICpcbiAgICogVG8gZWRpdCBzbm9vd3JhcCBzcGVjaWZpYyBzZXR0aW5ncywgc2VlIHtAbGluayBzbm9vd3JhcCNjb25maWd9LlxuICAgKlxuICAgKiBzbm9vd3JhcCBzdXBwb3J0cyBzZXZlcmFsIGRpZmZlcmVudCBvcHRpb25zIGZvciBwcmUtZXhpc3RpbmcgYXV0aGVudGljYXRpb246XG4gICAqIDEuICpSZWZyZXNoIHRva2VuKjogVG8gYXV0aGVudGljYXRlIHdpdGggYSByZWZyZXNoIHRva2VuLCBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGB1c2VyQWdlbnRgLCBgY2xpZW50SWRgLFxuICAgYGNsaWVudFNlY3JldGAsIGFuZCBgcmVmcmVzaFRva2VuYCB0byB0aGUgc25vb3dyYXAgY29uc3RydWN0b3IuIFlvdSB3aWxsIG5lZWQgdG8gZ2V0IHRoZSByZWZyZXNoIHRva2VuIGZyb20gcmVkZGl0XG4gICBiZWZvcmVoYW5kLiBBIHNjcmlwdCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIHJlZnJlc2ggdG9rZW5zIGZvciB5b3UgY2FuIGJlIGZvdW5kXG4gICBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL25vdC1hbi1hYXJkdmFyay9yZWRkaXQtb2F1dGgtaGVscGVyKS5cbiAgICogMS4gKlVzZXJuYW1lL3Bhc3N3b3JkKjogVG8gYXV0aGVudGljYXRlIHdpdGggYSB1c2VybmFtZSBhbmQgcGFzc3dvcmQsIHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgYHVzZXJBZ2VudGAsXG4gICBgY2xpZW50SWRgLCBgY2xpZW50U2VjcmV0YCwgYHVzZXJuYW1lYCwgYW5kIGBwYXNzd29yZGAgdG8gdGhlIHNub293cmFwIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgdXNlcm5hbWUvcGFzc3dvcmRcbiAgIGF1dGhlbnRpY2F0aW9uIGlzIG9ubHkgcG9zc2libGUgZm9yIGBzY3JpcHRgLXR5cGUgYXBwcy5cbiAgICogMS4gKkFjY2VzcyB0b2tlbio6IFRvIGF1dGhlbnRpY2F0ZSB3aXRoIGFuIGFjY2VzcyB0b2tlbiwgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBgdXNlckFnZW50YCBhbmQgYGFjY2Vzc1Rva2VuYFxuICAgdG8gdGhlIHNub293cmFwIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgYWxsIGFjY2VzcyB0b2tlbnMgZXhwaXJlIG9uZSBob3VyIGFmdGVyIGJlaW5nIGdlbmVyYXRlZCwgc28gdGhpcyBtZXRob2QgaXNcbiAgIG5vdCByZWNvbW1lbmRlZCBmb3IgbG9uZy10ZXJtIHVzZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYXV0aGVudGljYXRpb24gb3B0aW9ucy4gVGhpcyBzaG91bGQgYWx3YXlzIGhhdmUgdGhlIHByb3BlcnR5IGB1c2VyQWdlbnRgLiBJdFxuICAgbXVzdCBhbHNvIGNvbnRhaW4gc29tZSBjb21iaW5hdGlvbiBvZiBjcmVkZW50aWFscyAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51c2VyQWdlbnQgQSB1bmlxdWUgZGVzY3JpcHRpb24gb2Ygd2hhdCB5b3VyIGFwcCBkb2VzLiBUaGlzIGFyZ3VtZW50IGlzIG5vdCBuZWNlc3Nhcnkgd2hlbiBzbm9vd3JhcFxuICAgaXMgcnVubmluZyBpbiBhIGJyb3dzZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jbGllbnRJZF0gVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcCAoYXNzaWduZWQgYnkgcmVkZGl0KVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xpZW50U2VjcmV0XSBUaGUgY2xpZW50IHNlY3JldCBvZiB5b3VyIGFwcCAoYXNzaWduZWQgYnkgcmVkZGl0KS4gSWYgeW91IGFyZSB1c2luZyBhIHJlZnJlc2ggdG9rZW5cbiAgIHdpdGggYW4gaW5zdGFsbGVkIGFwcCAod2hpY2ggZG9lcyBub3QgaGF2ZSBhIGNsaWVudCBzZWNyZXQpLCBwYXNzIGFuIGVtcHR5IHN0cmluZyBhcyB5b3VyIGBjbGllbnRTZWNyZXRgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudXNlcm5hbWVdIFRoZSB1c2VybmFtZSBvZiB0aGUgYWNjb3VudCB0byBhY2Nlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhc3N3b3JkXSBUaGUgcGFzc3dvcmQgb2YgdGhlIGFjY291bnQgdG8gYWNjZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWZyZXNoVG9rZW5dIEEgcmVmcmVzaCB0b2tlbiBmb3IgeW91ciBhcHBcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFjY2Vzc1Rva2VuXSBBbiBhY2Nlc3MgdG9rZW4gZm9yIHlvdXIgYXBwXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIHVzZXJfYWdlbnQgPSBfcmVmLnVzZXJfYWdlbnQsXG4gICAgICAgIF9yZWYkdXNlckFnZW50ID0gX3JlZi51c2VyQWdlbnQsXG4gICAgICAgIHVzZXJBZ2VudCA9IF9yZWYkdXNlckFnZW50ID09PSB2b2lkIDAgPyB1c2VyX2FnZW50IDogX3JlZiR1c2VyQWdlbnQsXG4gICAgICAgIGNsaWVudF9pZCA9IF9yZWYuY2xpZW50X2lkLFxuICAgICAgICBfcmVmJGNsaWVudElkID0gX3JlZi5jbGllbnRJZCxcbiAgICAgICAgY2xpZW50SWQgPSBfcmVmJGNsaWVudElkID09PSB2b2lkIDAgPyBjbGllbnRfaWQgOiBfcmVmJGNsaWVudElkLFxuICAgICAgICBjbGllbnRfc2VjcmV0ID0gX3JlZi5jbGllbnRfc2VjcmV0LFxuICAgICAgICBfcmVmJGNsaWVudFNlY3JldCA9IF9yZWYuY2xpZW50U2VjcmV0LFxuICAgICAgICBjbGllbnRTZWNyZXQgPSBfcmVmJGNsaWVudFNlY3JldCA9PT0gdm9pZCAwID8gY2xpZW50X3NlY3JldCA6IF9yZWYkY2xpZW50U2VjcmV0LFxuICAgICAgICByZWZyZXNoX3Rva2VuID0gX3JlZi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICBfcmVmJHJlZnJlc2hUb2tlbiA9IF9yZWYucmVmcmVzaFRva2VuLFxuICAgICAgICByZWZyZXNoVG9rZW4gPSBfcmVmJHJlZnJlc2hUb2tlbiA9PT0gdm9pZCAwID8gcmVmcmVzaF90b2tlbiA6IF9yZWYkcmVmcmVzaFRva2VuLFxuICAgICAgICBhY2Nlc3NfdG9rZW4gPSBfcmVmLmFjY2Vzc190b2tlbixcbiAgICAgICAgX3JlZiRhY2Nlc3NUb2tlbiA9IF9yZWYuYWNjZXNzVG9rZW4sXG4gICAgICAgIGFjY2Vzc1Rva2VuID0gX3JlZiRhY2Nlc3NUb2tlbiA9PT0gdm9pZCAwID8gYWNjZXNzX3Rva2VuIDogX3JlZiRhY2Nlc3NUb2tlbixcbiAgICAgICAgdXNlcm5hbWUgPSBfcmVmLnVzZXJuYW1lLFxuICAgICAgICBwYXNzd29yZCA9IF9yZWYucGFzc3dvcmQ7XG5cbiAgICBpZiAoIXVzZXJBZ2VudCAmJiAhX2hlbHBlcnMuaXNCcm93c2VyKSB7XG4gICAgICByZXR1cm4gKDAsIF9oZWxwZXJzLnJlcXVpcmVkQXJnKSgndXNlckFnZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCghYWNjZXNzVG9rZW4gfHwgdHlwZW9mIGFjY2Vzc1Rva2VuICE9PSAnc3RyaW5nJykgJiYgKGNsaWVudElkID09PSB1bmRlZmluZWQgfHwgY2xpZW50U2VjcmV0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHJlZnJlc2hUb2tlbiAhPT0gJ3N0cmluZycpICYmIChjbGllbnRJZCA9PT0gdW5kZWZpbmVkIHx8IGNsaWVudFNlY3JldCA9PT0gdW5kZWZpbmVkIHx8IHVzZXJuYW1lID09PSB1bmRlZmluZWQgfHwgcGFzc3dvcmQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuTm9DcmVkZW50aWFsc0Vycm9yKCk7XG4gICAgfVxuXG4gICAgaWYgKF9oZWxwZXJzLmlzQnJvd3Nlcikge1xuICAgICAgdGhpcy51c2VyQWdlbnQgPSBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB9XG5cbiAgICAoMCwgX2xvZGFzaC5kZWZhdWx0cykodGhpcywge1xuICAgICAgdXNlckFnZW50LFxuICAgICAgY2xpZW50SWQsXG4gICAgICBjbGllbnRTZWNyZXQsXG4gICAgICByZWZyZXNoVG9rZW4sXG4gICAgICBhY2Nlc3NUb2tlbixcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmRcbiAgICB9LCB7XG4gICAgICBjbGllbnRJZDogbnVsbCxcbiAgICAgIGNsaWVudFNlY3JldDogbnVsbCxcbiAgICAgIHJlZnJlc2hUb2tlbjogbnVsbCxcbiAgICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxuICAgICAgdXNlcm5hbWU6IG51bGwsXG4gICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgIHJhdGVsaW1pdFJlbWFpbmluZzogbnVsbCxcbiAgICAgIHJhdGVsaW1pdEV4cGlyYXRpb246IG51bGwsXG4gICAgICB0b2tlbkV4cGlyYXRpb246IG51bGwsXG4gICAgICBzY29wZTogbnVsbCxcbiAgICAgIF9jb25maWc6ICgwLCBfY3JlYXRlX2NvbmZpZy5kZWZhdWx0KSgpLFxuICAgICAgX25leHRSZXF1ZXN0VGltZXN0YW1wOiAtSW5maW5pdHlcbiAgICB9KTtcbiAgICAoMCwgX2hlbHBlcnMuYWRkU25ha2VDYXNlU2hhZG93UHJvcHMpKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGFuIGF1dGhvcml6YXRpb24gVVJMLCB3aGljaCBhbGxvd3MgYSB1c2VyIHRvIGF1dGhvcml6ZSBhY2Nlc3MgdG8gdGhlaXIgYWNjb3VudFxuICAgKiBAZGVzYyBUaGlzIGNyZWF0ZSBhIFVSTCB3aGVyZSBhIHVzZXIgY2FuIGF1dGhvcml6ZSBhbiBhcHAgdG8gYWN0IHRocm91Z2ggdGhlaXIgYWNjb3VudC4gSWYgdGhlIHVzZXIgdmlzaXRzIHRoZSByZXR1cm5lZCBVUkxcbiAgIGluIGEgd2ViIGJyb3dzZXIsIHRoZXkgd2lsbCBzZWUgYSBwYWdlIHRoYXQgbG9va3MgbGlrZSBbdGhpc10oaHR0cHM6Ly9pLmd5YXpvLmNvbS8wMzI1NTM0ZjM4Yjc4YzFkYmQ0Yzg0ZDY5MGRkYTZjMi5wbmcpLiBJZlxuICAgdGhlIHVzZXIgY2xpY2tzIFwiQWxsb3dcIiwgdGhleSB3aWxsIGJlIHJlZGlyZWN0ZWQgdG8geW91ciBgcmVkaXJlY3RVcmlgLCB3aXRoIGEgYGNvZGVgIHF1ZXJ5c3RyaW5nIHBhcmFtZXRlciBjb250YWluaW5nIGFuXG4gICAqICphdXRob3JpemF0aW9uIGNvZGUqLiBJZiB0aGlzIGNvZGUgaXMgcGFzc2VkIHRvIHtAbGluayBzbm9vd3JhcC5mcm9tQXV0aENvZGV9LCB5b3UgY2FuIGNyZWF0ZSBhIHJlcXVlc3RlciB0byBtYWtlXG4gICByZXF1ZXN0cyBvbiBiZWhhbGYgb2YgdGhlIHVzZXIuXG4gICAqXG4gICAqIFRoZSBtYWluIHVzZS1jYXNlIGhlcmUgaXMgZm9yIHJ1bm5pbmcgc25vb3dyYXAgaW4gYSBicm93c2VyLiBZb3UgY2FuIGdlbmVyYXRlIGEgVVJMLCBzZW5kIHRoZSB1c2VyIHRoZXJlLCBhbmQgdGhlbiBjb250aW51ZVxuICAgYWZ0ZXIgdGhlIHVzZXIgYXV0aGVudGljYXRlcyBvbiByZWRkaXQgYW5kIGlzIHJlZGlyZWN0ZWQgYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcCAoYXNzaWduZWQgYnkgcmVkZGl0KS4gSWYgeW91ciBjb2RlIGlzIHJ1bm5pbmcgY2xpZW50c2lkZSBpbiBhXG4gICBicm93c2VyLCB1c2luZyBhbiBcIkluc3RhbGxlZFwiIGFwcCB0eXBlIGlzIHJlY29tbWVuZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zLnNjb3BlIEFuIGFycmF5IG9mIHNjb3BlcyAocGVybWlzc2lvbnMgb24gdGhlIHVzZXIncyBhY2NvdW50KSB0byByZXF1ZXN0IG9uIHRoZSBhdXRoZW50aWNhdGlvblxuICAgcGFnZS4gQSBsaXN0IG9mIHBvc3NpYmxlIHNjb3BlcyBjYW4gYmUgZm91bmQgW2hlcmVdKGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vYXBpL3YxL3Njb3BlcykuIFlvdSBjYW4gYWxzbyBnZXQgdGhlbSBvbi10aGUtZmx5XG4gICB3aXRoIHtAbGluayBzbm9vd3JhcCNnZXRPYXV0aFNjb3BlTGlzdH0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJlZGlyZWN0VXJpIFRoZSBVUkwgd2hlcmUgdGhlIHVzZXIgc2hvdWxkIGJlIHJlZGlyZWN0ZWQgYWZ0ZXIgYXV0aGVudGljYXRpbmcuIFRoaXMgKiptdXN0KiogYmUgdGhlXG4gICBzYW1lIGFzIHRoZSByZWRpcmVjdCBVUkkgdGhhdCBpcyBjb25maWd1cmVkIGZvciB0aGUgcmVkZGl0IGFwcC4gKElmIHRoZXJlIGlzIGEgbWlzbWF0Y2gsIHRoZSByZXR1cm5lZCBVUkwgd2lsbCBkaXNwbGF5IGFuXG4gICBlcnJvciBwYWdlIGluc3RlYWQgb2YgYW4gYXV0aGVudGljYXRpb24gZm9ybS4pXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGVybWFuZW50PXRydWVdIElmIGB0cnVlYCwgdGhlIGFwcCB3aWxsIGhhdmUgaW5kZWZpbml0ZSBhY2Nlc3MgdG8gdGhlIHVzZXIncyBhY2NvdW50LiBJZiBgZmFsc2VgLFxuICAgYWNjZXNzIHRvIHRoZSB1c2VyJ3MgYWNjb3VudCB3aWxsIGV4cGlyZSBhZnRlciAxIGhvdXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdGF0ZV0gQSBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCB0byB2ZXJpZnkgYSB1c2VyIGFmdGVyIHRoZXkgYXJlIHJlZGlyZWN0ZWQgYmFjayB0byB0aGUgc2l0ZS4gV2hlblxuICAgdGhlIHVzZXIgaXMgcmVkaXJlY3RlZCBmcm9tIHJlZGRpdCwgdG8gdGhlIHJlZGlyZWN0IFVSSSBhZnRlciBhdXRoZW50aWNhdGluZywgdGhlIHJlc3VsdGluZyBVUkkgd2lsbCBoYXZlIHRoaXMgc2FtZSBgc3RhdGVgXG4gICB2YWx1ZSBpbiB0aGUgcXVlcnlzdHJpbmcuIChTZWUgW2hlcmVdKGh0dHA6Ly93d3cudHdvYm90ZWNobm9sb2dpZXMuY29tL2Jsb2cvMjAxNC8wMi9pbXBvcnRhbmNlLW9mLXN0YXRlLWluLW9hdXRoMi5odG1sKSBmb3JcbiAgIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIHVzZSB0aGUgYHN0YXRlYCB2YWx1ZS4pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmRwb2ludERvbWFpbj0ncmVkZGl0LmNvbSddIFRoZSBlbmRwb2ludCBkb21haW4gZm9yIHRoZSBVUkwuIElmIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0aW5nIG9uXG4gICByZWRkaXQuY29tIChhcyBvcHBvc2VkIHRvIHNvbWUgb3RoZXIgc2l0ZSB3aXRoIGEgcmVkZGl0LWxpa2UgQVBJKSwgeW91IGNhbiBvbWl0IHRoaXMgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgVVJMIHdoZXJlIHRoZSB1c2VyIGNhbiBhdXRoZW50aWNhdGUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgYXV0aGVudGljYXRpb25VcmwgPSBzbm9vd3JhcC5nZXRBdXRoVXJsKHtcbiAgICogICBjbGllbnRJZDogJ2Zvb2JhcmJhenF1dXV4JyxcbiAgICogICBzY29wZTogWydpZGVudGl0eScsICd3aWtpcmVhZCcsICd3aWtpZWRpdCddLFxuICAgKiAgIHJlZGlyZWN0VXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9yZWRkaXRfY2FsbGJhY2snLFxuICAgKiAgIHBlcm1hbmVudDogZmFsc2UsXG4gICAqICAgc3RhdGU6ICdmZTIxMWJlYmM1MmViM2RhOWJlZjhkYjZlNjMxMDRkMycgLy8gYSByYW5kb20gc3RyaW5nLCB0aGlzIGNvdWxkIGJlIHZhbGlkYXRlZCB3aGVuIHRoZSB1c2VyIGlzIHJlZGlyZWN0ZWQgYmFja1xuICAgKiB9KTtcbiAgICogLy8gLS0+ICdodHRwczovL3d3dy5yZWRkaXQuY29tL2FwaS92MS9hdXRob3JpemU/Y2xpZW50X2lkPWZvb2JhcmJheiZyZXNwb25zZV90eXBlPWNvZGUmc3RhdGU9IC4uLidcbiAgICpcbiAgICogd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhdXRoZW50aWNhdGlvblVybDsgLy8gc2VuZCB0aGUgdXNlciB0byB0aGUgYXV0aGVudGljYXRpb24gdXJsXG4gICAqL1xuXG5cbiAgc3RhdGljIGdldEF1dGhVcmwoX3JlZjIpIHtcbiAgICB2YXIgX3JlZjIkY2xpZW50SWQgPSBfcmVmMi5jbGllbnRJZCxcbiAgICAgICAgY2xpZW50SWQgPSBfcmVmMiRjbGllbnRJZCA9PT0gdm9pZCAwID8gKDAsIF9oZWxwZXJzLnJlcXVpcmVkQXJnKSgnY2xpZW50SWQnKSA6IF9yZWYyJGNsaWVudElkLFxuICAgICAgICBfcmVmMiRzY29wZSA9IF9yZWYyLnNjb3BlLFxuICAgICAgICBzY29wZSA9IF9yZWYyJHNjb3BlID09PSB2b2lkIDAgPyAoMCwgX2hlbHBlcnMucmVxdWlyZWRBcmcpKCdzY29wZScpIDogX3JlZjIkc2NvcGUsXG4gICAgICAgIF9yZWYyJHJlZGlyZWN0VXJpID0gX3JlZjIucmVkaXJlY3RVcmksXG4gICAgICAgIHJlZGlyZWN0VXJpID0gX3JlZjIkcmVkaXJlY3RVcmkgPT09IHZvaWQgMCA/ICgwLCBfaGVscGVycy5yZXF1aXJlZEFyZykoJ3JlZGlyZWN0VXJpJykgOiBfcmVmMiRyZWRpcmVjdFVyaSxcbiAgICAgICAgX3JlZjIkcGVybWFuZW50ID0gX3JlZjIucGVybWFuZW50LFxuICAgICAgICBwZXJtYW5lbnQgPSBfcmVmMiRwZXJtYW5lbnQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRwZXJtYW5lbnQsXG4gICAgICAgIF9yZWYyJHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICAgIHN0YXRlID0gX3JlZjIkc3RhdGUgPT09IHZvaWQgMCA/ICdfJyA6IF9yZWYyJHN0YXRlLFxuICAgICAgICBfcmVmMiRlbmRwb2ludERvbWFpbiA9IF9yZWYyLmVuZHBvaW50RG9tYWluLFxuICAgICAgICBlbmRwb2ludERvbWFpbiA9IF9yZWYyJGVuZHBvaW50RG9tYWluID09PSB2b2lkIDAgPyAncmVkZGl0LmNvbScgOiBfcmVmMiRlbmRwb2ludERvbWFpbjtcblxuICAgIGlmICghKEFycmF5LmlzQXJyYXkoc2NvcGUpICYmIHNjb3BlLmxlbmd0aCAmJiBzY29wZS5ldmVyeShmdW5jdGlvbiAoc2NvcGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHNjb3BlVmFsdWUgJiYgdHlwZW9mIHNjb3BlVmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH0pKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBgc2NvcGVgIGFyZ3VtZW50OyBhIG5vbi1lbXB0eSBsaXN0IG9mIE9BdXRoIHNjb3BlcyBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXFxuICAgICAgaHR0cHM6Ly93d3cuXCIuY29uY2F0KGVuZHBvaW50RG9tYWluLCBcIi9hcGkvdjEvYXV0aG9yaXplP1xcbiAgICAgIGNsaWVudF9pZD1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChjbGllbnRJZCksIFwiXFxuICAgICAgJnJlc3BvbnNlX3R5cGU9Y29kZVxcbiAgICAgICZzdGF0ZT1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZSksIFwiXFxuICAgICAgJnJlZGlyZWN0X3VyaT1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChyZWRpcmVjdFVyaSksIFwiXFxuICAgICAgJmR1cmF0aW9uPVwiKS5jb25jYXQocGVybWFuZW50ID8gJ3Blcm1hbmVudCcgOiAndGVtcG9yYXJ5JywgXCJcXG4gICAgICAmc2NvcGU9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoc2NvcGUuam9pbignICcpKSwgXCJcXG4gICAgXCIpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBzbm9vd3JhcCByZXF1ZXN0ZXIgZnJvbSBhbiBhdXRob3JpemF0aW9uIGNvZGUuXG4gICAqIEBkZXNjIEFuIGF1dGhvcml6YXRpb24gY29kZSBpcyB0aGUgYGNvZGVgIHZhbHVlIHRoYXQgYXBwZWFycyBpbiB0aGUgcXVlcnlzdHJpbmcgYWZ0ZXIgYSB1c2VyIGF1dGhlbnRpY2F0ZXMgd2l0aCByZWRkaXQgYW5kXG4gICBpcyByZWRpcmVjdGVkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHtAbGluayBzbm9vd3JhcC5nZXRBdXRoVXJsfS5cbiAgICpcbiAgICogVGhlIG1haW4gdXNlLWNhc2UgZm9yIHRoaXMgZnVuY3Rpb24gaXMgZm9yIHJ1bm5pbmcgc25vb3dyYXAgaW4gYSBicm93c2VyLiBZb3UgY2FuIGdlbmVyYXRlIGEgVVJMIHdpdGhcbiAgIHtAbGluayBzbm9vd3JhcC5nZXRBdXRoVXJsfSBhbmQgc2VuZCB0aGUgdXNlciB0byB0aGF0IFVSTCwgYW5kIHRoZW4gdXNlIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcmVxdWVzdGVyIHdoZW5cbiAgIHRoZSB1c2VyIGlzIHJlZGlyZWN0ZWQgYmFjayB3aXRoIGFuIGF1dGhvcml6YXRpb24gY29kZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29kZSBUaGUgYXV0aG9yaXphdGlvbiBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVzZXJBZ2VudCBBIHVuaXF1ZSBkZXNjcmlwdGlvbiBvZiB3aGF0IHlvdXIgYXBwIGRvZXMuIFRoaXMgYXJndW1lbnQgaXMgbm90IG5lY2Vzc2FyeSB3aGVuIHNub293cmFwXG4gICBpcyBydW5uaW5nIGluIGEgYnJvd3Nlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xpZW50SWQgVGhlIGNsaWVudCBJRCBvZiB5b3VyIGFwcCAoYXNzaWduZWQgYnkgcmVkZGl0KS4gSWYgeW91ciBjb2RlIGlzIHJ1bm5pbmcgY2xpZW50c2lkZSBpbiBhXG4gICBicm93c2VyLCB1c2luZyBhbiBcIkluc3RhbGxlZFwiIGFwcCB0eXBlIGlzIHJlY29tbWVuZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2xpZW50U2VjcmV0XSBUaGUgY2xpZW50IHNlY3JldCBvZiB5b3VyIGFwcC4gSWYgeW91ciBhcHAgaGFzIHRoZSBcIkluc3RhbGxlZFwiIGFwcCB0eXBlLCBvbWl0XG4gICB0aGlzIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucmVkaXJlY3RVcmkgVGhlIHJlZGlyZWN0IFVSSSB0aGF0IGlzIGNvbmZpZ3VyZWQgZm9yIHRoZSByZWRkaXQgYXBwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5kcG9pbnREb21haW49J3JlZGRpdC5jb20nXSBUaGUgZW5kcG9pbnQgZG9tYWluIHRoYXQgdGhlIHJldHVybmVkIHJlcXVlc3RlciBzaG91bGQgYmUgY29uZmlndXJlZFxuICAgdG8gdXNlLiBJZiB0aGUgdXNlciBpcyBhdXRoZW50aWNhdGluZyBvbiByZWRkaXQuY29tIChhcyBvcHBvc2VkIHRvIHNvbWUgb3RoZXIgc2l0ZSB3aXRoIGEgcmVkZGl0LWxpa2UgQVBJKSwgeW91IGNhbiBvbWl0IHRoaXNcbiAgIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzbm9vd3JhcD59IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggYSBgc25vb3dyYXBgIGluc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIC8vIEdldCB0aGUgYGNvZGVgIHF1ZXJ5c3RyaW5nIHBhcmFtIChhc3N1bWluZyB0aGUgdXNlciB3YXMgcmVkaXJlY3RlZCBmcm9tIHJlZGRpdClcbiAgICogdmFyIGNvZGUgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5zZWFyY2hQYXJhbXMuZ2V0KCdjb2RlJyk7XG4gICAqXG4gICAqIHNub293cmFwLmZyb21BdXRoQ29kZSh7XG4gICAqICAgY29kZTogY29kZSxcbiAgICogICB1c2VyQWdlbnQ6ICdNeSBhcHAnLFxuICAgKiAgIGNsaWVudElkOiAnZm9vYmFyYmF6cXV1dXgnLFxuICAgKiAgIHJlZGlyZWN0VXJpOiAnZXhhbXBsZS5jb20nXG4gICAqIH0pLnRoZW4ociA9PiB7XG4gICAqICAgLy8gTm93IHdlIGhhdmUgYSByZXF1ZXN0ZXIgdGhhdCBjYW4gYWNjZXNzIHJlZGRpdCB0aHJvdWdoIHRoZSB1c2VyJ3MgYWNjb3VudFxuICAgKiAgIHJldHVybiByLmdldEhvdCgpLnRoZW4ocG9zdHMgPT4ge1xuICAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggcG9zdHMgZnJvbSB0aGUgZnJvbnQgcGFnZVxuICAgKiAgIH0pO1xuICAgKiB9KVxuICAgKi9cblxuXG4gIHN0YXRpYyBmcm9tQXV0aENvZGUoX3JlZjMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9yZWYzJGNvZGUgPSBfcmVmMy5jb2RlLFxuICAgICAgICBjb2RlID0gX3JlZjMkY29kZSA9PT0gdm9pZCAwID8gKDAsIF9oZWxwZXJzLnJlcXVpcmVkQXJnKSgnY29kZScpIDogX3JlZjMkY29kZSxcbiAgICAgICAgX3JlZjMkdXNlckFnZW50ID0gX3JlZjMudXNlckFnZW50LFxuICAgICAgICB1c2VyQWdlbnQgPSBfcmVmMyR1c2VyQWdlbnQgPT09IHZvaWQgMCA/IF9oZWxwZXJzLmlzQnJvd3NlciA/IGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50IDogKDAsIF9oZWxwZXJzLnJlcXVpcmVkQXJnKSgndXNlckFnZW50JykgOiBfcmVmMyR1c2VyQWdlbnQsXG4gICAgICAgIF9yZWYzJGNsaWVudElkID0gX3JlZjMuY2xpZW50SWQsXG4gICAgICAgIGNsaWVudElkID0gX3JlZjMkY2xpZW50SWQgPT09IHZvaWQgMCA/ICgwLCBfaGVscGVycy5yZXF1aXJlZEFyZykoJ2NsaWVudElkJykgOiBfcmVmMyRjbGllbnRJZCxcbiAgICAgICAgY2xpZW50U2VjcmV0ID0gX3JlZjMuY2xpZW50U2VjcmV0LFxuICAgICAgICBfcmVmMyRyZWRpcmVjdFVyaSA9IF9yZWYzLnJlZGlyZWN0VXJpLFxuICAgICAgICByZWRpcmVjdFVyaSA9IF9yZWYzJHJlZGlyZWN0VXJpID09PSB2b2lkIDAgPyAoMCwgX2hlbHBlcnMucmVxdWlyZWRBcmcpKCdyZWRpcmVjdFVyaScpIDogX3JlZjMkcmVkaXJlY3RVcmksXG4gICAgICAgIF9yZWYzJGVuZHBvaW50RG9tYWluID0gX3JlZjMuZW5kcG9pbnREb21haW4sXG4gICAgICAgIGVuZHBvaW50RG9tYWluID0gX3JlZjMkZW5kcG9pbnREb21haW4gPT09IHZvaWQgMCA/ICdyZWRkaXQuY29tJyA6IF9yZWYzJGVuZHBvaW50RG9tYWluO1xuICAgIHJldHVybiB0aGlzLnByb3RvdHlwZS5jcmVkZW50aWFsZWRDbGllbnRSZXF1ZXN0LmNhbGwoe1xuICAgICAgdXNlckFnZW50LFxuICAgICAgY2xpZW50SWQsXG4gICAgICBjbGllbnRTZWNyZXQsXG4gICAgICAvLyBVc2UgYHRoaXMucHJvdG90eXBlLnJhd1JlcXVlc3RgIGZ1bmN0aW9uIHRvIGFsbG93IGZvciBjdXN0b20gYHJhd1JlcXVlc3RgIG1ldGhvZCB1c2FnZSBpbiBzdWJjbGFzc2VzLlxuICAgICAgcmF3UmVxdWVzdDogdGhpcy5wcm90b3R5cGUucmF3UmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgYmFzZVVybDogXCJodHRwczovL3d3dy5cIi5jb25jYXQoZW5kcG9pbnREb21haW4sIFwiL1wiKSxcbiAgICAgIHVyaTogJ2FwaS92MS9hY2Nlc3NfdG9rZW4nLFxuICAgICAgZm9ybToge1xuICAgICAgICBncmFudF90eXBlOiAnYXV0aG9yaXphdGlvbl9jb2RlJyxcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVkaXJlY3RfdXJpOiByZWRpcmVjdFVyaVxuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5SZXF1ZXN0RXJyb3IoXCJBUEkgRXJyb3I6IFwiLmNvbmNhdChyZXNwb25zZS5lcnJvciwgXCIgLSBcIikuY29uY2F0KHJlc3BvbnNlLmVycm9yX2Rlc2NyaXB0aW9uKSk7XG4gICAgICB9IC8vIFVzZSBgbmV3IHRoaXNgIGluc3RlYWQgb2YgYG5ldyBzbm9vd3JhcGAgdG8gZW5zdXJlIHRoYXQgc3ViY2xhc3MgaW5zdGFuY2VzIGNhbiBiZSByZXR1cm5lZFxuXG5cbiAgICAgIHZhciByZXF1ZXN0ZXIgPSBuZXcgX3RoaXMoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHVzZXJBZ2VudCxcbiAgICAgICAgY2xpZW50SWQsXG4gICAgICAgIGNsaWVudFNlY3JldFxuICAgICAgfSwgcmVzcG9uc2UpKTtcbiAgICAgIHJlcXVlc3Rlci5jb25maWcoe1xuICAgICAgICBlbmRwb2ludERvbWFpblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVxdWVzdGVyO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXR1cm5zIHRoZSBncmFudCB0eXBlcyBhdmFpbGFibGUgZm9yIGFwcC1vbmx5IGF1dGhlbnRpY2F0aW9uXG4gICAqIEBkZXNjIFBlciB0aGUgUmVkZGl0IEFQSSBPQXV0aCBkb2NzLCB0aGVyZSBhcmUgdHdvIGRpZmZlcmVudCBncmFudCB0eXBlcyBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgYXBwIGlzIGFuIGluc3RhbGxlZCBjbGllbnRcbiAgICogb3IgYSBjb25maWRlbnRpYWwgY2xpZW50IHN1Y2ggYXMgYSB3ZWIgYXBwIG9yIHN0cmluZy4gVGhpcyBnZXR0ZXIgcmV0dXJucyB0aGUgcG9zc2libGUgdmFsdWVzIGZvciB0aGUgXCJncmFudF90eXBlXCIgZmllbGRcbiAgICogaW4gYXBwbGljYXRpb24tb25seSBhdXRoLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgZW51bWVyYXRpb24gb2YgcG9zc2libGUgZ3JhbnRfdHlwZSB2YWx1ZXNcbiAgICovXG5cblxuICBzdGF0aWMgZ2V0IGdyYW50VHlwZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQ0xJRU5UX0NSRURFTlRJQUxTOiAnY2xpZW50X2NyZWRlbnRpYWxzJyxcbiAgICAgIElOU1RBTExFRF9DTElFTlQ6ICdodHRwczovL29hdXRoLnJlZGRpdC5jb20vZ3JhbnRzL2luc3RhbGxlZF9jbGllbnQnXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgc25vb3dyYXAgcmVxdWVzdGVyIGZyb20gYSBcInVzZXItbGVzc1wiIEF1dGhvcml6YXRpb24gdG9rZW5cbiAgKiBAZGVzYyBJbiBzb21lIGNhc2VzLCAzcmQgcGFydHkgYXBwIGNsaWVudHMgbWF5IHdpc2ggdG8gbWFrZSBBUEkgcmVxdWVzdHMgd2l0aG91dCBhIHVzZXIgY29udGV4dC4gQXBwIGNsaWVudHMgY2FuIHJlcXVlc3RcbiAgKiBhIFwidXNlci1sZXNzXCIgQXV0aG9yaXphdGlvbiB0b2tlbiB2aWEgZWl0aGVyIHRoZSBzdGFuZGFyZCBjbGllbnRfY3JlZGVudGlhbHMgZ3JhbnQsIG9yIHRoZSByZWRkaXQgc3BlY2lmaWNcbiAgKiBleHRlbnNpb24gdG8gdGhpcyBncmFudCwgaHR0cHM6Ly9vYXV0aC5yZWRkaXQuY29tL2dyYW50cy9pbnN0YWxsZWRfY2xpZW50LiBXaGljaCBncmFudCB0eXBlIGFuIGFwcCB1c2VzIGRlcGVuZHMgb25cbiAgKiB0aGUgYXBwLXR5cGUgYW5kIGl0cyB1c2UgY2FzZS5cbiAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVzZXJBZ2VudCBBIHVuaXF1ZSBkZXNjcmlwdGlvbiBvZiB3aGF0IHlvdXIgYXBwIGRvZXMuIFRoaXMgYXJndW1lbnQgaXMgbm90IG5lY2Vzc2FyeSB3aGVuIHNub293cmFwXG4gIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsaWVudElkIFRoZSBjbGllbnQgSUQgb2YgeW91ciBhcHAgKGFzc2lnbmVkIGJ5IHJlZGRpdCkuIElmIHlvdXIgY29kZSBpcyBydW5uaW5nIGNsaWVudHNpZGUgaW4gYVxuICAqIGJyb3dzZXIsIHVzaW5nIGFuIFwiSW5zdGFsbGVkXCIgYXBwIHR5cGUgaXMgcmVjb21tZW5kZWQuXG4gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNsaWVudFNlY3JldF0gVGhlIGNsaWVudCBzZWNyZXQgb2YgeW91ciBhcHAuIE9ubHkgcmVxdWlyZWQgZm9yIFwiY2xpZW50X2NyZWRlbnRpYWxzXCIgZ3JhbnQgdHlwZS5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGV2aWNlSWRdIEEgdW5pcXVlLCBwZXItZGV2aWNlIElEIGdlbmVyYXRlZCBieSB5b3VyIGNsaWVudC4gT25seSByZXF1aXJlZFxuICAqIGZvciBcIkluc3RhbGxlZFwiIGdyYW50IHR5cGUsIG5lZWRzIHRvIGJlIGJldHdlZW4gMjAtMzAgY2hhcmFjdGVycyBsb25nLiBGcm9tIHRoZSByZWRkaXQgZG9jczogXCJyZWRkaXQgKm1heSogY2hvb3NlIHRvIHVzZVxuICAqIHRoaXMgSUQgdG8gZ2VuZXJhdGUgYWdncmVnYXRlIGRhdGEgYWJvdXQgdXNlciBjb3VudHMuIENsaWVudHMgdGhhdCB3aXNoIHRvIHJlbWFpbiBhbm9ueW1vdXMgc2hvdWxkIHVzZSB0aGUgdmFsdWVcbiAgKiBET19OT1RfVFJBQ0tfVEhJU19ERVZJQ0UuXCJcbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZ3JhbnRUeXBlPXNub293cmFwLmdyYW50VHlwZS5JTlNUQUxMRURfQ0xJRU5UXSBUaGUgdHlwZSBvZiBcInVzZXItbGVzc1wiXG4gICogdG9rZW4gdG8gdXNlIHtAbGluayBzbm9vd3JhcC5ncmFudFR5cGV9XG4gICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wZXJtYW5lbnQ9dHJ1ZV0gSWYgYHRydWVgLCB0aGUgYXBwIHdpbGwgaGF2ZSBpbmRlZmluaXRlIGFjY2Vzcy4gSWYgYGZhbHNlYCxcbiAgYWNjZXNzIHdpbGwgZXhwaXJlIGFmdGVyIDEgaG91ci5cbiAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5kcG9pbnREb21haW49J3JlZGRpdC5jb20nXSBUaGUgZW5kcG9pbnQgZG9tYWluIHRoYXQgdGhlIHJldHVybmVkIHJlcXVlc3RlciBzaG91bGQgYmUgY29uZmlndXJlZFxuICB0byB1c2UuIElmIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0aW5nIG9uIHJlZGRpdC5jb20gKGFzIG9wcG9zZWQgdG8gc29tZSBvdGhlciBzaXRlIHdpdGggYSByZWRkaXQtbGlrZSBBUEkpLCB5b3UgY2FuIG9taXQgdGhpc1xuICB2YWx1ZS5cbiAgKiBAcmV0dXJucyB7UHJvbWlzZTxzbm9vd3JhcD59IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggYSBgc25vb3dyYXBgIGluc3RhbmNlXG4gICogQGV4YW1wbGVcbiAgKlxuICAqIHNub293cmFwLmZyb21BcHBsaWNhdGlvbk9ubHlBdXRoKHtcbiAgKiAgIHVzZXJBZ2VudDogJ015IGFwcCcsXG4gICogICBjbGllbnRJZDogJ2Zvb2JhcmJhenF1dXV4JyxcbiAgKiAgIGRldmljZUlkOiAndW5pcXVlIGlkIGJldHdlZW4gMjAtMzAgY2hhcnMnLFxuICAqICAgZ3JhbnRUeXBlOiBzbm9vd3JhcC5ncmFudFR5cGUuSU5TVEFMTEVEX0NMSUVOVFxuICAqIH0pLnRoZW4ociA9PiB7XG4gICogICAvLyBOb3cgd2UgaGF2ZSBhIHJlcXVlc3RlciB0aGF0IGNhbiBhY2Nlc3MgcmVkZGl0IHRocm91Z2ggYSBcInVzZXItbGVzc1wiIEF1dGggdG9rZW5cbiAgKiAgIHJldHVybiByLmdldEhvdCgpLnRoZW4ocG9zdHMgPT4ge1xuICAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCBwb3N0cyBmcm9tIHRoZSBmcm9udCBwYWdlXG4gICogICB9KTtcbiAgKiB9KVxuICAqXG4gICogc25vb3dyYXAuZnJvbUFwcGxpY2F0aW9uT25seUF1dGgoe1xuICAqICAgdXNlckFnZW50OiAnTXkgYXBwJyxcbiAgKiAgIGNsaWVudElkOiAnZm9vYmFyYmF6cXV1dXgnLFxuICAqICAgY2xpZW50U2VjcmV0OiAneW91ciB3ZWIgYXBwIHNlY3JldCcsXG4gICogICBncmFudFR5cGU6IHNub293cmFwLmdyYW50VHlwZS5DTElFTlRfQ1JFREVOVElBTFNcbiAgKiB9KS50aGVuKHIgPT4ge1xuICAqICAgLy8gTm93IHdlIGhhdmUgYSByZXF1ZXN0ZXIgdGhhdCBjYW4gYWNjZXNzIHJlZGRpdCB0aHJvdWdoIGEgXCJ1c2VyLWxlc3NcIiBBdXRoIHRva2VuXG4gICogICByZXR1cm4gci5nZXRIb3QoKS50aGVuKHBvc3RzID0+IHtcbiAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggcG9zdHMgZnJvbSB0aGUgZnJvbnQgcGFnZVxuICAqICAgfSk7XG4gICogfSlcbiAgKi9cblxuXG4gIHN0YXRpYyBmcm9tQXBwbGljYXRpb25Pbmx5QXV0aChfcmVmNCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF9yZWY0JHVzZXJBZ2VudCA9IF9yZWY0LnVzZXJBZ2VudCxcbiAgICAgICAgdXNlckFnZW50ID0gX3JlZjQkdXNlckFnZW50ID09PSB2b2lkIDAgPyBfaGVscGVycy5pc0Jyb3dzZXIgPyBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCA6ICgwLCBfaGVscGVycy5yZXF1aXJlZEFyZykoJ3VzZXJBZ2VudCcpIDogX3JlZjQkdXNlckFnZW50LFxuICAgICAgICBfcmVmNCRjbGllbnRJZCA9IF9yZWY0LmNsaWVudElkLFxuICAgICAgICBjbGllbnRJZCA9IF9yZWY0JGNsaWVudElkID09PSB2b2lkIDAgPyAoMCwgX2hlbHBlcnMucmVxdWlyZWRBcmcpKCdjbGllbnRJZCcpIDogX3JlZjQkY2xpZW50SWQsXG4gICAgICAgIGNsaWVudFNlY3JldCA9IF9yZWY0LmNsaWVudFNlY3JldCxcbiAgICAgICAgZGV2aWNlSWQgPSBfcmVmNC5kZXZpY2VJZCxcbiAgICAgICAgX3JlZjQkZ3JhbnRUeXBlID0gX3JlZjQuZ3JhbnRUeXBlLFxuICAgICAgICBncmFudFR5cGUgPSBfcmVmNCRncmFudFR5cGUgPT09IHZvaWQgMCA/IHNub293cmFwLmdyYW50VHlwZS5JTlNUQUxMRURfQ0xJRU5UIDogX3JlZjQkZ3JhbnRUeXBlLFxuICAgICAgICBfcmVmNCRwZXJtYW5lbnQgPSBfcmVmNC5wZXJtYW5lbnQsXG4gICAgICAgIHBlcm1hbmVudCA9IF9yZWY0JHBlcm1hbmVudCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY0JHBlcm1hbmVudCxcbiAgICAgICAgX3JlZjQkZW5kcG9pbnREb21haW4gPSBfcmVmNC5lbmRwb2ludERvbWFpbixcbiAgICAgICAgZW5kcG9pbnREb21haW4gPSBfcmVmNCRlbmRwb2ludERvbWFpbiA9PT0gdm9pZCAwID8gJ3JlZGRpdC5jb20nIDogX3JlZjQkZW5kcG9pbnREb21haW47XG4gICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLmNyZWRlbnRpYWxlZENsaWVudFJlcXVlc3QuY2FsbCh7XG4gICAgICBjbGllbnRJZCxcbiAgICAgIGNsaWVudFNlY3JldCxcbiAgICAgIC8vIFVzZSBgdGhpcy5wcm90b3R5cGUucmF3UmVxdWVzdGAgZnVuY3Rpb24gdG8gYWxsb3cgZm9yIGN1c3RvbSBgcmF3UmVxdWVzdGAgbWV0aG9kIHVzYWdlIGluIHN1YmNsYXNzZXMuXG4gICAgICByYXdSZXF1ZXN0OiB0aGlzLnByb3RvdHlwZS5yYXdSZXF1ZXN0XG4gICAgfSwge1xuICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICBiYXNlVXJsOiBcImh0dHBzOi8vd3d3LlwiLmNvbmNhdChlbmRwb2ludERvbWFpbiwgXCIvXCIpLFxuICAgICAgdXJpOiAnYXBpL3YxL2FjY2Vzc190b2tlbicsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGdyYW50X3R5cGU6IGdyYW50VHlwZSxcbiAgICAgICAgZGV2aWNlX2lkOiBkZXZpY2VJZCxcbiAgICAgICAgZHVyYXRpb246IHBlcm1hbmVudCA/ICdwZXJtYW5lbnQnIDogJ3RlbXBvcmFyeSdcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuUmVxdWVzdEVycm9yKFwiQVBJIEVycm9yOiBcIi5jb25jYXQocmVzcG9uc2UuZXJyb3IsIFwiIC0gXCIpLmNvbmNhdChyZXNwb25zZS5lcnJvcl9kZXNjcmlwdGlvbikpO1xuICAgICAgfSAvLyBVc2UgYG5ldyB0aGlzYCBpbnN0ZWFkIG9mIGBuZXcgc25vb3dyYXBgIHRvIGVuc3VyZSB0aGF0IHN1YmNsYXNzIGluc3RhbmNlcyBjYW4gYmUgcmV0dXJuZWRcblxuXG4gICAgICB2YXIgcmVxdWVzdGVyID0gbmV3IF90aGlzMihfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgdXNlckFnZW50LFxuICAgICAgICBjbGllbnRJZCxcbiAgICAgICAgY2xpZW50U2VjcmV0XG4gICAgICB9LCByZXNwb25zZSkpO1xuICAgICAgcmVxdWVzdGVyLmNvbmZpZyh7XG4gICAgICAgIGVuZHBvaW50RG9tYWluXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXF1ZXN0ZXI7XG4gICAgfSk7XG4gIH1cblxuICBfbmV3T2JqZWN0KG9iamVjdFR5cGUsIGNvbnRlbnQpIHtcbiAgICB2YXIgX2hhc0ZldGNoZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogbmV3IHNub293cmFwLm9iamVjdHNbb2JqZWN0VHlwZV0oY29udGVudCwgdGhpcywgX2hhc0ZldGNoZWQpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXRyaWV2ZXMgb3IgbW9kaWZpZXMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBzbm9vd3JhcCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBBIG1hcCBvZiBge1tjb25maWcgcHJvcGVydHkgbmFtZV06IHZhbHVlfWAuIE5vdGUgdGhhdCBhbnkgb21pdHRlZCBjb25maWcgcHJvcGVydGllcyB3aWxsIHNpbXBseVxuICAgcmV0YWluIHdoYXRldmVyIHZhbHVlIHRoZXkgaGFkIHByZXZpb3VzbHkuIChJbiBvdGhlciB3b3JkcywgaWYgeW91IG9ubHkgd2FudCB0byBjaGFuZ2Ugb25lIHByb3BlcnR5LCB5b3Ugb25seSBuZWVkIHRvIHB1dFxuICAgdGhhdCBvbmUgcHJvcGVydHkgaW4gdGhpcyBwYXJhbWV0ZXIuIFRvIGdldCB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIHdpdGhvdXQgbW9kaWZ5aW5nIGFueXRoaW5nLCBzaW1wbHkgb21pdCB0aGlzXG4gICBwYXJhbWV0ZXIuKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5kcG9pbnREb21haW49J3JlZGRpdC5jb20nXSBUaGUgZW5kcG9pbnQgd2hlcmUgcmVxdWVzdHMgc2hvdWxkIGJlIHNlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlcXVlc3REZWxheT0wXSBBIG1pbmltdW0gZGVsYXksIGluIG1pbGxpc2Vjb25kcywgdG8gZW5mb3JjZSBiZXR3ZWVuIEFQSSBjYWxscy4gSWYgbXVsdGlwbGVcbiAgIGFwaSBjYWxscyBhcmUgcmVxdWVzdGVkIGR1cmluZyB0aGlzIHRpbWVzcGFuLCB0aGV5IHdpbGwgYmUgcXVldWVkIGFuZCBzZW50IG9uZSBhdCBhIHRpbWUuIFNldHRpbmcgdGhpcyB0byBtb3JlIHRoYW4gMTAwMCB3aWxsXG4gICBlbnN1cmUgdGhhdCByZWRkaXQncyByYXRlbGltaXQgaXMgbmV2ZXIgcmVhY2hlZCwgYnV0IGl0IHdpbGwgbWFrZSB0aGluZ3MgcnVuIHNsb3dlciB0aGFuIG5lY2Vzc2FyeSBpZiBvbmx5IGEgZmV3IHJlcXVlc3RzXG4gICBhcmUgYmVpbmcgc2VudC4gSWYgdGhpcyBpcyBzZXQgdG8gemVybywgc25vb3dyYXAgd2lsbCBub3QgZW5mb3JjZSBhbnkgZGVsYXkgYmV0d2VlbiBpbmRpdmlkdWFsIHJlcXVlc3RzLiBIb3dldmVyLCBpdCB3aWxsXG4gICBzdGlsbCByZWZ1c2UgdG8gY29udGludWUgaWYgcmVkZGl0J3MgZW5mb3JjZWQgcmF0ZWxpbWl0ICg2MDAgcmVxdWVzdHMgcGVyIDEwIG1pbnV0ZXMpIGlzIGV4Y2VlZGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVxdWVzdFRpbWVvdXQ9MzAwMDBdIEEgdGltZW91dCBmb3IgYWxsIE9BdXRoIHJlcXVlc3RzLCBpbiBtaWxsaXNlY29uZHMuIElmIHRoZSByZWRkaXQgc2VydmVyXG4gICBmYWlscyB0byByZXR1cm4gYSByZXNwb25zZSB3aXRoaW4gdGhpcyBhbW91bnQgb2YgdGltZSwgdGhlIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIGEgdGltZW91dCBlcnJvci5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb250aW51ZUFmdGVyUmF0ZWxpbWl0RXJyb3I9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciBzbm9vd3JhcCBzaG91bGQgcXVldWUgQVBJIGNhbGxzIGlmXG4gICByZWRkaXQncyByYXRlbGltaXQgaXMgZXhjZWVkZWQuIElmIHNldCB0byBgdHJ1ZWAgd2hlbiB0aGUgcmF0ZWxpbWl0IGlzIGV4Y2VlZGVkLCBzbm9vd3JhcCB3aWxsIHF1ZXVlIGFsbCBmdXJ0aGVyIHJlcXVlc3RzLFxuICAgYW5kIHdpbGwgYXR0ZW1wdCB0byBzZW5kIHRoZW0gYWdhaW4gYWZ0ZXIgdGhlIGN1cnJlbnQgcmF0ZWxpbWl0IHBlcmlvZCBleHBpcmVzICh3aGljaCBoYXBwZW5zIGV2ZXJ5IDEwIG1pbnV0ZXMpLiBJZiBzZXRcbiAgIHRvIGBmYWxzZWAsIHNub293cmFwIHdpbGwgc2ltcGx5IHRocm93IGFuIGVycm9yIHdoZW4gcmVkZGl0J3MgcmF0ZWxpbWl0IGlzIGV4Y2VlZGVkLlxuICAgKiBAcGFyYW0ge051bWJlcltdfSBbb3B0aW9ucy5yZXRyeUVycm9yQ29kZXM9WzUwMiwgNTAzLCA1MDQsIDUyMl1dIElmIHJlZGRpdCByZXNwb25kcyB0byBhbiBpZGVtcG90ZW50IHJlcXVlc3Qgd2l0aCBvbmUgb2ZcbiAgIHRoZXNlIGVycm9yIGNvZGVzLCBzbm9vd3JhcCB3aWxsIHJldHJ5IHRoZSByZXF1ZXN0LCB1cCB0byBhIG1heGltdW0gb2YgYG1heF9yZXRyeV9hdHRlbXB0c2AgcmVxdWVzdHMgaW4gdG90YWwuIChUaGVzZVxuICAgZXJyb3JzIHVzdWFsbHkgaW5kaWNhdGUgdGhhdCB0aGVyZSB3YXMgYW4gdGVtcG9yYXJ5IGlzc3VlIG9uIHJlZGRpdCdzIGVuZCwgYW5kIHJldHJ5aW5nIHRoZSByZXF1ZXN0IGhhcyBhIGRlY2VudCBjaGFuY2Ugb2ZcbiAgIHN1Y2Nlc3MuKSBUaGlzIGJlaGF2aW9yIGNhbiBiZSBkaXNhYmxlZCBieSBzaW1wbHkgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGFuIGVtcHR5IGFycmF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmV0cnlBdHRlbXB0cz0zXSBTZWUgYHJldHJ5RXJyb3JDb2Rlc2AuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2FybmluZ3M9dHJ1ZV0gc25vb3dyYXAgbWF5IG9jY2FzaW9uYWxseSBsb2cgd2FybmluZ3MsIHN1Y2ggYXMgZGVwcmVjYXRpb24gbm90aWNlcywgdG8gdGhlXG4gICBjb25zb2xlLiBUaGVzZSBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyB0aGlzIHRvIGBmYWxzZWAuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVidWc9ZmFsc2VdIElmIHNldCB0byB0cnVlLCBzbm9vd3JhcCB3aWxsIHByaW50IG91dCBwb3RlbnRpYWxseS11c2VmdWwgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgcHVycG9zZXMgYXMgaXQgcnVucy5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmxvZ2dlcj1jb25zb2xlXSBCeSBkZWZhdWx0LCBzbm9vd3JhcCB3aWxsIGxvZyBhbnkgd2FybmluZ3MgYW5kIGRlYnVnIG91dHB1dCB0byB0aGUgY29uc29sZS5cbiAgIEEgY3VzdG9tIGxvZ2dlciBvYmplY3QgbWF5IGJlIHN1cHBsaWVkIHZpYSB0aGlzIG9wdGlvbjsgaXQgbXVzdCBleHBvc2UgYHdhcm5gLCBgaW5mb2AsIGBkZWJ1Z2AsIGFuZCBgdHJhY2VgIGZ1bmN0aW9ucy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcm94aWVzPXRydWVdIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIGRpc2FibGVzIHNub293cmFwJ3MgbWV0aG9kLWNoYWluaW5nIGZlYXR1cmUuIFRoaXMgY2F1c2VzXG4gICB0aGUgc3ludGF4IGZvciB1c2luZyBzbm9vd3JhcCB0byBiZWNvbWUgYSBiaXQgaGVhdmllciwgYnV0IGFsbG93cyBmb3IgY29uc2lzdGVuY3kgYmV0d2VlbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IHRoZSBFUzZcbiAgIGBQcm94eWAgb2JqZWN0IGFuZCBlbnZpcm9ubWVudHMgdGhhdCBkb24ndC4gVGhpcyBvcHRpb24gaXMgYSBuby1vcCBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBgUHJveHlgIG9iamVjdCxcbiAgIHNpbmNlIG1ldGhvZCBjaGFpbmluZyBpcyBhbHdheXMgZGlzYWJsZWQgaW4gdGhvc2UgZW52aXJvbm1lbnRzLiBOb3RlLCBjaGFuZ2luZyB0aGlzIHNldHRpbmcgbXVzdCBiZSBkb25lIGJlZm9yZSBtYWtpbmdcbiAgIGFueSByZXF1ZXN0cy5cbiAgICogQHJldHVybnMge29iamVjdH0gQW4gdXBkYXRlZCBPYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWVzXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuY29uZmlnKHtyZXF1ZXN0RGVsYXk6IDEwMDAsIHdhcm5pbmdzOiBmYWxzZX0pO1xuICAgKiAvLyBzZXRzIHRoZSByZXF1ZXN0IGRlbGF5IHRvIDEwMDAgbWlsbGlzZWNvbmRzLCBhbmQgc3VwcHJlc3NlcyB3YXJuaW5ncy5cbiAgICovXG5cblxuICBjb25maWcoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGludmFsaWRLZXkgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiAhKGtleSBpbiBfdGhpczMuX2NvbmZpZyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgY29uZmlnIG9wdGlvbiAnXCIuY29uY2F0KGludmFsaWRLZXksIFwiJ1wiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5fY29uZmlnLCBvcHRpb25zKTtcbiAgfVxuXG4gIF93YXJuKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcud2FybmluZ3MpIHtcbiAgICAgIHZhciBfdGhpcyRfY29uZmlnJGxvZ2dlcjtcblxuICAgICAgKF90aGlzJF9jb25maWckbG9nZ2VyID0gdGhpcy5fY29uZmlnLmxvZ2dlcikud2Fybi5hcHBseShfdGhpcyRfY29uZmlnJGxvZ2dlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBfZGVidWcoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5kZWJ1Zykge1xuICAgICAgdmFyIF90aGlzJF9jb25maWckbG9nZ2VyMjtcblxuICAgICAgKF90aGlzJF9jb25maWckbG9nZ2VyMiA9IHRoaXMuX2NvbmZpZy5sb2dnZXIpLmRlYnVnLmFwcGx5KF90aGlzJF9jb25maWckbG9nZ2VyMiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX3Byb21pc2VXcmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucHJveGllcyA/IF9wcm9taXNlQ2hhaW5zLmRlZmF1bHQgOiBpZGVudGl0eTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBpbmZvcm1hdGlvbiBvbiBhIHJlZGRpdCB1c2VyIHdpdGggYSBnaXZlbiBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSB1c2VyJ3MgdXNlcm5hbWVcbiAgICogQHJldHVybnMge1JlZGRpdFVzZXJ9IEFuIHVuZmV0Y2hlZCBSZWRkaXRVc2VyIG9iamVjdCBmb3IgdGhlIHJlcXVlc3RlZCB1c2VyXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0VXNlcignbm90X2FuX2FhcmR2YXJrJylcbiAgICogLy8gPT4gUmVkZGl0VXNlciB7IG5hbWU6ICdub3RfYW5fYWFyZHZhcmsnIH1cbiAgICogci5nZXRVc2VyKCdub3RfYW5fYWFyZHZhcmsnKS5saW5rX2thcm1hLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IDZcbiAgICovXG5cblxuICBnZXRVc2VyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV3T2JqZWN0KCdSZWRkaXRVc2VyJywge1xuICAgICAgbmFtZTogKG5hbWUgKyAnJykucmVwbGFjZSgvXlxcLz91XFwvLywgJycpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgaW5mb3JtYXRpb24gb24gYSBjb21tZW50IHdpdGggYSBnaXZlbiBpZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRJZCAtIFRoZSBiYXNlMzYgaWQgb2YgdGhlIGNvbW1lbnRcbiAgICogQHJldHVybnMge0NvbW1lbnR9IEFuIHVuZmV0Y2hlZCBDb21tZW50IG9iamVjdCBmb3IgdGhlIHJlcXVlc3RlZCBjb21tZW50XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0Q29tbWVudCgnYzBiNnh4MCcpXG4gICAqIC8vID0+IENvbW1lbnQgeyBuYW1lOiAndDFfYzBiNnh4MCcgfVxuICAgKiByLmdldENvbW1lbnQoJ2MwYjZ4eDAnKS5hdXRob3IubmFtZS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiAnS2hhcm9zJ1xuICAgKi9cblxuXG4gIGdldENvbW1lbnQoY29tbWVudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuX25ld09iamVjdCgnQ29tbWVudCcsIHtcbiAgICAgIG5hbWU6ICgwLCBfaGVscGVycy5hZGRGdWxsbmFtZVByZWZpeCkoY29tbWVudElkLCAndDFfJylcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBpbmZvcm1hdGlvbiBvbiBhIGdpdmVuIHN1YnJlZGRpdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpc3BsYXlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN1YnJlZGRpdCAoZS5nLiAnQXNrUmVkZGl0JylcbiAgICogQHJldHVybnMge1N1YnJlZGRpdH0gQW4gdW5mZXRjaGVkIFN1YnJlZGRpdCBvYmplY3QgZm9yIHRoZSByZXF1ZXN0ZWQgc3VicmVkZGl0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0U3VicmVkZGl0KCdBc2tSZWRkaXQnKVxuICAgKiAvLyA9PiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdBc2tSZWRkaXQnIH1cbiAgICogci5nZXRTdWJyZWRkaXQoJ0Fza1JlZGRpdCcpLmNyZWF0ZWRfdXRjLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IDEyMDEyMzMxMzVcbiAgICovXG5cblxuICBnZXRTdWJyZWRkaXQoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV3T2JqZWN0KCdTdWJyZWRkaXQnLCB7XG4gICAgICBkaXNwbGF5X25hbWU6IGRpc3BsYXlOYW1lLnJlcGxhY2UoL15cXC8/clxcLy8sICcnKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGluZm9ybWF0aW9uIG9uIGEgZ2l2ZW4gc3VibWlzc2lvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1Ym1pc3Npb25JZCAtIFRoZSBiYXNlMzYgaWQgb2YgdGhlIHN1Ym1pc3Npb25cbiAgICogQHJldHVybnMge1N1Ym1pc3Npb259IEFuIHVuZmV0Y2hlZCBTdWJtaXNzaW9uIG9iamVjdCBmb3IgdGhlIHJlcXVlc3RlZCBzdWJtaXNzaW9uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0U3VibWlzc2lvbignMm5wNjk0JylcbiAgICogLy8gPT4gU3VibWlzc2lvbiB7IG5hbWU6ICd0M18ybnA2OTQnIH1cbiAgICogci5nZXRTdWJtaXNzaW9uKCcybnA2OTQnKS50aXRsZS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiAnV2hhdCB0YXN0eSBmb29kIHdvdWxkIGJlIGRpc3R1c3RpbmcgaWYgZWF0ZW4gb3ZlciByaWNlPydcbiAgICovXG5cblxuICBnZXRTdWJtaXNzaW9uKHN1Ym1pc3Npb25JZCkge1xuICAgIHJldHVybiB0aGlzLl9uZXdPYmplY3QoJ1N1Ym1pc3Npb24nLCB7XG4gICAgICBuYW1lOiAoMCwgX2hlbHBlcnMuYWRkRnVsbG5hbWVQcmVmaXgpKHN1Ym1pc3Npb25JZCwgJ3QzXycpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYSBwcml2YXRlIG1lc3NhZ2UgYnkgSUQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlSWQgVGhlIGJhc2UzNiBJRCBvZiB0aGUgbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7UHJpdmF0ZU1lc3NhZ2V9IEFuIHVuZmV0Y2hlZCBQcml2YXRlTWVzc2FnZSBvYmplY3QgZm9yIHRoZSByZXF1ZXN0ZWQgbWVzc2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE1lc3NhZ2UoJzUxc2hudycpXG4gICAqIC8vID0+IFByaXZhdGVNZXNzYWdlIHsgbmFtZTogJ3Q0XzUxc2hudycgfVxuICAgKiByLmdldE1lc3NhZ2UoJzUxc2hudycpLnN1YmplY3QudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gJ0V4YW1wbGUnXG4gICAqIC8vIFNlZSBoZXJlIGZvciBhIHNjcmVlbnNob3Qgb2YgdGhlIFBNIGluIHF1ZXN0aW9uIGh0dHBzOi8vaS5neWF6by5jb20vMjRmM2I5N2U1NWI2ZmY4ZTNhNzRjYjAyNmE1OGIxNjcucG5nXG4gICAqL1xuXG5cbiAgZ2V0TWVzc2FnZShtZXNzYWdlSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV3T2JqZWN0KCdQcml2YXRlTWVzc2FnZScsIHtcbiAgICAgIG5hbWU6ICgwLCBfaGVscGVycy5hZGRGdWxsbmFtZVByZWZpeCkobWVzc2FnZUlkLCAndDRfJylcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIGxpdmV0aHJlYWQgYnkgSUQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aHJlYWRJZCBUaGUgYmFzZTM2IElEIG9mIHRoZSBsaXZldGhyZWFkXG4gICAqIEByZXR1cm5zIHtMaXZlVGhyZWFkfSBBbiB1bmZldGNoZWQgTGl2ZVRocmVhZCBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKVxuICAgKiAvLyA9PiBMaXZlVGhyZWFkIHsgaWQ6ICd3aHJkeG84ZGc5bjAnIH1cbiAgICogci5nZXRMaXZldGhyZWFkKCd3aHJkeG84ZGc5bjAnKS5uc2Z3LnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgZ2V0TGl2ZXRocmVhZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiB0aGlzLl9uZXdPYmplY3QoJ0xpdmVUaHJlYWQnLCB7XG4gICAgICBpZDogKDAsIF9oZWxwZXJzLmFkZEZ1bGxuYW1lUHJlZml4KSh0aHJlYWRJZCwgJ0xpdmVVcGRhdGVFdmVudF8nKS5zbGljZSgxNilcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBpbmZvcm1hdGlvbiBvbiB0aGUgcmVxdWVzdGVyJ3Mgb3duIHVzZXIgcHJvZmlsZS5cbiAgICogQHJldHVybnMge1JlZGRpdFVzZXJ9IEEgUmVkZGl0VXNlciBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgcmVxdWVzdGVyJ3MgcHJvZmlsZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE1lKCkudGhlbihjb25zb2xlLmxvZyk7XG4gICAqIC8vID0+IFJlZGRpdFVzZXIgeyBpc19lbXBsb3llZTogZmFsc2UsIGhhc19tYWlsOiBmYWxzZSwgbmFtZTogJ3Nub293cmFwX3Rlc3RpbmcnLCAuLi4gfVxuICAgKi9cblxuXG4gIGdldE1lKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6ICdhcGkvdjEvbWUnXG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBfdGhpczQuX293blVzZXJJbmZvID0gX3RoaXM0Ll9uZXdPYmplY3QoJ1JlZGRpdFVzZXInLCByZXN1bHQsIHRydWUpO1xuICAgICAgcmV0dXJuIF90aGlzNC5fb3duVXNlckluZm87XG4gICAgfSk7XG4gIH1cblxuICBfZ2V0TXlOYW1lKCkge1xuICAgIHJldHVybiBfUHJvbWlzZS5kZWZhdWx0LnJlc29sdmUodGhpcy5fb3duVXNlckluZm8gPyB0aGlzLl9vd25Vc2VySW5mby5uYW1lIDogdGhpcy5nZXRNZSgpLmdldCgnbmFtZScpKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBhIGRpc3RyaWJ1dGlvbiBvZiB0aGUgcmVxdWVzdGVyJ3Mgb3duIGthcm1hIGRpc3RyaWJ1dGlvbiBieSBzdWJyZWRkaXQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgZm9yIGFuIG9iamVjdCB3aXRoIGthcm1hIGluZm9ybWF0aW9uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0S2FybWEoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBbXG4gICAqIC8vICB7IHNyOiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdyZWRkaXRkZXYnIH0sIGNvbW1lbnRfa2FybWE6IDE2LCBsaW5rX2thcm1hOiAxIH0sXG4gICAqIC8vICB7IHNyOiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdwcm9ncmFtbWluZycgfSwgY29tbWVudF9rYXJtYTogMiwgbGlua19rYXJtYTogMSB9LFxuICAgKiAvLyAgLi4uXG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRLYXJtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogJ2FwaS92MS9tZS9rYXJtYSdcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBpbmZvcm1hdGlvbiBvbiB0aGUgdXNlcidzIGN1cnJlbnQgcHJlZmVyZW5jZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgZm9yIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VyJ3MgY3VycmVudCBwcmVmZXJlbmNlc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldFByZWZlcmVuY2VzKCkudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4geyBkZWZhdWx0X3RoZW1lX3NyOiBudWxsLCB0aHJlYWRlZF9tZXNzYWdlczogdHJ1ZSwgaGlkZV9kb3duczogZmFsc2UsIC4uLiB9XG4gICAqL1xuXG5cbiAgZ2V0UHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6ICdhcGkvdjEvbWUvcHJlZnMnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFVwZGF0ZXMgdGhlIHVzZXIncyBjdXJyZW50IHByZWZlcmVuY2VzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlZFByZWZlcmVuY2VzIEFuIG9iamVjdCBvZiB0aGUgZm9ybSB7W3NvbWUgcHJlZmVyZW5jZSBuYW1lXTogJ3NvbWUgdmFsdWUnLCAuLi59LiBBbnkgcHJlZmVyZW5jZVxuICAgKiBub3QgaW5jbHVkZWQgaW4gdGhpcyBvYmplY3Qgd2lsbCBzaW1wbHkgcmV0YWluIGl0cyBjdXJyZW50IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLnVwZGF0ZVByZWZlcmVuY2VzKHt0aHJlYWRlZF9tZXNzYWdlczogZmFsc2UsIGhpZGVfZG93bnM6IHRydWV9KVxuICAgKiAvLyA9PiB7IGRlZmF1bHRfdGhlbWVfc3I6IG51bGwsIHRocmVhZGVkX21lc3NhZ2VzOiBmYWxzZSxoaWRlX2Rvd25zOiB0cnVlLCAuLi4gfVxuICAgKiAvLyAocHJlZmVyZW5jZXMgdXBkYXRlZCBvbiByZWRkaXQpXG4gICAqL1xuXG5cbiAgdXBkYXRlUHJlZmVyZW5jZXModXBkYXRlZFByZWZlcmVuY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGNoKHtcbiAgICAgIHVyaTogJ2FwaS92MS9tZS9wcmVmcycsXG4gICAgICBib2R5OiB1cGRhdGVkUHJlZmVyZW5jZXNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyB0aGUgY3VycmVudGx5LWF1dGhlbnRpY2F0ZWQgdXNlcidzIHRyb3BoaWVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBUcm9waHlMaXN0IGNvbnRhaW5pbmcgdGhlIHVzZXIncyB0cm9waGllc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE15VHJvcGhpZXMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBUcm9waHlMaXN0IHsgdHJvcGhpZXM6IFtcbiAgICogLy8gICBUcm9waHkgeyBpY29uXzcwOiAnaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tL3JlZGRpdHN0YXRpYy9hd2FyZC92ZXJpZmllZF9lbWFpbC03MC5wbmcnLFxuICAgKiAvLyAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAqIC8vICAgICB1cmw6IG51bGwsXG4gICAqIC8vICAgICBpY29uXzQwOiAnaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tL3JlZGRpdHN0YXRpYy9hd2FyZC92ZXJpZmllZF9lbWFpbC00MC5wbmcnLFxuICAgKiAvLyAgICAgYXdhcmRfaWQ6ICdvJyxcbiAgICogLy8gICAgIGlkOiAnMTZmbjI5JyxcbiAgICogLy8gICAgIG5hbWU6ICdWZXJpZmllZCBFbWFpbCdcbiAgICogLy8gICB9XG4gICAqIC8vIF0gfVxuICAgKi9cblxuXG4gIGdldE15VHJvcGhpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6ICdhcGkvdjEvbWUvdHJvcGhpZXMnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgdGhlIGxpc3Qgb2YgdGhlIGN1cnJlbnRseS1hdXRoZW50aWNhdGVkIHVzZXIncyBmcmllbmRzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIGxpc3Qgb2YgZnJpZW5kc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldEZyaWVuZHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBbIFsgUmVkZGl0VXNlciB7IGRhdGU6IDE0NTc5Mjc5NjMsIG5hbWU6ICdub3RfYW5fYWFyZHZhcmsnLCBpZDogJ3QyX2s4M21kJyB9IF0sIFtdIF1cbiAgICovXG5cblxuICBnZXRGcmllbmRzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiAncHJlZnMvZnJpZW5kcydcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyB0aGUgbGlzdCBvZiBwZW9wbGUgdGhhdCB0aGUgY3VycmVudGx5LWF1dGhlbnRpY2F0ZWQgdXNlciBoYXMgYmxvY2tlZC5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBsaXN0IG9mIGJsb2NrZWQgdXNlcnNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRCbG9ja2VkVXNlcnMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBbIFJlZGRpdFVzZXIgeyBkYXRlOiAxNDU3OTI4MTIwLCBuYW1lOiAnYWN0dWFsbHlfYW5fYWFyZHZhcmsnLCBpZDogJ3QyX3EzNTE5JyB9IF1cbiAgICovXG5cblxuICBnZXRCbG9ja2VkVXNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6ICdwcmVmcy9ibG9ja2VkJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGN1cnJlbnRseS1hdXRoZW50aWNhdGVkIHVzZXIgbmVlZHMgdG8gZmlsbCBvdXQgYSBjYXB0Y2hhIGluIG9yZGVyIHRvIHN1Ym1pdCBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIGJvb2xlYW4gdmFsdWVcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5jaGVja0NhcHRjaGFSZXF1aXJlbWVudCgpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuXG5cbiAgY2hlY2tDYXB0Y2hhUmVxdWlyZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6ICdhcGkvbmVlZHNfY2FwdGNoYSdcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyB0aGUgaWRlbnRpZmllciAoYSBoZXggc3RyaW5nKSBmb3IgYSBuZXcgY2FwdGNoYSBpbWFnZS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmdcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXROZXdDYXB0Y2hhSWRlbnRpZmllcigpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+ICdvNU0xOHV5NG1rMElXNGhzMGZ1MkdOUGRYYjFEeGU5ZCdcbiAgICovXG5cblxuICBnZXROZXdDYXB0Y2hhSWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvbmV3X2NhcHRjaGEnLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZVxuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgcmV0dXJuIHJlcy5qc29uLmRhdGEuaWRlbjtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBhbiBpbWFnZSBmb3IgYSBnaXZlbiBjYXB0Y2hhIGlkZW50aWZpZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBjYXB0Y2hhIGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHN0cmluZyBjb250YWluaW5nIHJhdyBpbWFnZSBkYXRhIGluIFBORyBmb3JtYXRcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRDYXB0Y2hhSW1hZ2UoJ281TTE4dXk0bWswSVc0aHMwZnUyR05QZFhiMUR4ZTlkJykudGhlbihjb25zb2xlLmxvZylcbiAgIC8vID0+IChBIGxvbmcsIGluY29oZXJlbnQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaW1hZ2UgaW4gUE5HIGZvcm1hdClcbiAgICovXG5cblxuICBnZXRDYXB0Y2hhSW1hZ2UoaWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiBcImNhcHRjaGEvXCIuY29uY2F0KGlkZW50aWZpZXIpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYW4gYXJyYXkgb2YgY2F0ZWdvcmllcyB0aGF0IGl0ZW1zIGNhbiBiZSBzYXZlZCBpbi4gKFJlcXVpcmVzIHJlZGRpdCBnb2xkKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQW4gYXJyYXkgb2YgY2F0ZWdvcmllc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldFNhdmVkQ2F0ZWdvcmllcygpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IFsgeyBjYXRlZ29yeTogJ2N1dGUgY2F0IHBpY3R1cmVzJyB9LCB7IGNhdGVnb3J5OiAnaW50ZXJlc3RpbmcgYXJ0aWNsZXMnIH0gXVxuICAgKi9cblxuXG4gIGdldFNhdmVkQ2F0ZWdvcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogJ2FwaS9zYXZlZF9jYXRlZ29yaWVzJ1xuICAgIH0pLmdldCgnY2F0ZWdvcmllcycpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBNYXJrcyBhIGxpc3Qgb2Ygc3VibWlzc2lvbnMgYXMgJ3Zpc2l0ZWQnLlxuICAgKiBAZGVzYyAqKk5vdGUqKjogVGhpcyBlbmRwb2ludCBvbmx5IHdvcmtzIGlmIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaXMgc3Vic2NyaWJlZCB0byByZWRkaXQgZ29sZC5cbiAgICogQHBhcmFtIHtTdWJtaXNzaW9uW119IGxpbmtzIEEgbGlzdCBvZiBTdWJtaXNzaW9uIG9iamVjdHMgdG8gbWFya1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgc3VibWlzc2lvbnMgPSBbci5nZXRTdWJtaXNzaW9uKCc0YTl1NTQnKSwgci5nZXRTdWJtaXNzaW9uKCc0YTk1bmInKV1cbiAgICogci5tYXJrQXNWaXNpdGVkKHN1Ym1pc3Npb25zKVxuICAgKiAvLyAodGhlIGxpbmtzIHdpbGwgbm93IGFwcGVhciBwdXJwbGUgb24gcmVkZGl0KVxuICAgKi9cblxuXG4gIG1hcmtBc1Zpc2l0ZWQobGlua3MpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvc3RvcmVfdmlzaXRzJyxcbiAgICAgIGxpbmtzOiAoMCwgX2xvZGFzaC5tYXApKGxpbmtzLCAnbmFtZScpLmpvaW4oJywnKVxuICAgIH0pO1xuICB9XG5cbiAgX3N1Ym1pdChfcmVmNSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdmFyIGNhcHRjaGFfcmVzcG9uc2UgPSBfcmVmNS5jYXB0Y2hhX3Jlc3BvbnNlLFxuICAgICAgICBfcmVmNSRjYXB0Y2hhUmVzcG9uc2UgPSBfcmVmNS5jYXB0Y2hhUmVzcG9uc2UsXG4gICAgICAgIGNhcHRjaGFSZXNwb25zZSA9IF9yZWY1JGNhcHRjaGFSZXNwb25zZSA9PT0gdm9pZCAwID8gY2FwdGNoYV9yZXNwb25zZSA6IF9yZWY1JGNhcHRjaGFSZXNwb25zZSxcbiAgICAgICAgY2FwdGNoYV9pZGVuID0gX3JlZjUuY2FwdGNoYV9pZGVuLFxuICAgICAgICBfcmVmNSRjYXB0Y2hhSWRlbiA9IF9yZWY1LmNhcHRjaGFJZGVuLFxuICAgICAgICBjYXB0Y2hhSWRlbiA9IF9yZWY1JGNhcHRjaGFJZGVuID09PSB2b2lkIDAgPyBjYXB0Y2hhX2lkZW4gOiBfcmVmNSRjYXB0Y2hhSWRlbixcbiAgICAgICAga2luZCA9IF9yZWY1LmtpbmQsXG4gICAgICAgIF9yZWY1JHJlc3VibWl0ID0gX3JlZjUucmVzdWJtaXQsXG4gICAgICAgIHJlc3VibWl0ID0gX3JlZjUkcmVzdWJtaXQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmNSRyZXN1Ym1pdCxcbiAgICAgICAgX3JlZjUkc2VuZF9yZXBsaWVzID0gX3JlZjUuc2VuZF9yZXBsaWVzLFxuICAgICAgICBzZW5kX3JlcGxpZXMgPSBfcmVmNSRzZW5kX3JlcGxpZXMgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmNSRzZW5kX3JlcGxpZXMsXG4gICAgICAgIF9yZWY1JHNlbmRSZXBsaWVzID0gX3JlZjUuc2VuZFJlcGxpZXMsXG4gICAgICAgIHNlbmRSZXBsaWVzID0gX3JlZjUkc2VuZFJlcGxpZXMgPT09IHZvaWQgMCA/IHNlbmRfcmVwbGllcyA6IF9yZWY1JHNlbmRSZXBsaWVzLFxuICAgICAgICBjcm9zc3Bvc3RfZnVsbG5hbWUgPSBfcmVmNS5jcm9zc3Bvc3RfZnVsbG5hbWUsXG4gICAgICAgIHRleHQgPSBfcmVmNS50ZXh0LFxuICAgICAgICB0aXRsZSA9IF9yZWY1LnRpdGxlLFxuICAgICAgICB1cmwgPSBfcmVmNS51cmwsXG4gICAgICAgIHN1YnJlZGRpdF9uYW1lID0gX3JlZjUuc3VicmVkZGl0X25hbWUsXG4gICAgICAgIF9yZWY1JHN1YnJlZGRpdE5hbWUgPSBfcmVmNS5zdWJyZWRkaXROYW1lLFxuICAgICAgICBzdWJyZWRkaXROYW1lID0gX3JlZjUkc3VicmVkZGl0TmFtZSA9PT0gdm9pZCAwID8gc3VicmVkZGl0X25hbWUgOiBfcmVmNSRzdWJyZWRkaXROYW1lLFxuICAgICAgICBuc2Z3ID0gX3JlZjUubnNmdyxcbiAgICAgICAgc3BvaWxlciA9IF9yZWY1LnNwb2lsZXIsXG4gICAgICAgIGZsYWlySWQgPSBfcmVmNS5mbGFpcklkLFxuICAgICAgICBmbGFpclRleHQgPSBfcmVmNS5mbGFpclRleHQsXG4gICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjUsIFtcImNhcHRjaGFfcmVzcG9uc2VcIiwgXCJjYXB0Y2hhUmVzcG9uc2VcIiwgXCJjYXB0Y2hhX2lkZW5cIiwgXCJjYXB0Y2hhSWRlblwiLCBcImtpbmRcIiwgXCJyZXN1Ym1pdFwiLCBcInNlbmRfcmVwbGllc1wiLCBcInNlbmRSZXBsaWVzXCIsIFwiY3Jvc3Nwb3N0X2Z1bGxuYW1lXCIsIFwidGV4dFwiLCBcInRpdGxlXCIsIFwidXJsXCIsIFwic3VicmVkZGl0X25hbWVcIiwgXCJzdWJyZWRkaXROYW1lXCIsIFwibnNmd1wiLCBcInNwb2lsZXJcIiwgXCJmbGFpcklkXCIsIFwiZmxhaXJUZXh0XCJdKTtcblxuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9zdWJtaXQnLFxuICAgICAgZm9ybTogX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGFwaV90eXBlLFxuICAgICAgICBjYXB0Y2hhOiBjYXB0Y2hhUmVzcG9uc2UsXG4gICAgICAgIGlkZW46IGNhcHRjaGFJZGVuLFxuICAgICAgICBzZW5kcmVwbGllczogc2VuZFJlcGxpZXMsXG4gICAgICAgIHNyOiBzdWJyZWRkaXROYW1lLFxuICAgICAgICBraW5kLFxuICAgICAgICByZXN1Ym1pdCxcbiAgICAgICAgY3Jvc3Nwb3N0X2Z1bGxuYW1lLFxuICAgICAgICB0ZXh0LFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdXJsLFxuICAgICAgICBzcG9pbGVyLFxuICAgICAgICBuc2Z3LFxuICAgICAgICBmbGFpcl9pZDogZmxhaXJJZCxcbiAgICAgICAgZmxhaXJfdGV4dDogZmxhaXJUZXh0XG4gICAgICB9LCBvcHRpb25zKVxuICAgIH0pLnRhcCgoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIF90aGlzNS5nZXRTdWJtaXNzaW9uKHJlc3VsdC5qc29uLmRhdGEuaWQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgbmV3IHNlbGZwb3N0IG9uIHRoZSBnaXZlbiBzdWJyZWRkaXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXQgdGhlIHN1Ym1pc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3VicmVkZGl0TmFtZSBUaGUgbmFtZSBvZiB0aGUgc3VicmVkZGl0IHRoYXQgdGhlIHBvc3Qgc2hvdWxkIGJlIHN1Ym1pdHRlZCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSBUaGUgdGl0bGUgb2YgdGhlIHN1Ym1pc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRleHRdIFRoZSBzZWxmdGV4dCBvZiB0aGUgc3VibWlzc2lvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRSZXBsaWVzPXRydWVdIERldGVybWluZXMgd2hldGhlciBpbmJveCByZXBsaWVzIHNob3VsZCBiZSBlbmFibGVkIGZvciB0aGlzIHN1Ym1pc3Npb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhcHRjaGFJZGVuXSBBIGNhcHRjaGEgaWRlbnRpZmllci4gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBpZiB0aGUgYXV0aGVudGljYXRlZCBhY2NvdW50XG4gICByZXF1aXJlcyBhIGNhcHRjaGEgdG8gc3VibWl0IHBvc3RzIGFuZCBjb21tZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhcHRjaGFSZXNwb25zZV0gVGhlIHJlc3BvbnNlIHRvIHRoZSBjYXB0Y2hhIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBuZXdseS1jcmVhdGVkIFN1Ym1pc3Npb24gb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuc3VibWl0U2VsZnBvc3Qoe1xuICAgKiAgIHN1YnJlZGRpdE5hbWU6ICdzbm9vd3JhcF90ZXN0aW5nJyxcbiAgICogICB0aXRsZTogJ1RoaXMgaXMgYSBzZWxmcG9zdCcsXG4gICAqICAgdGV4dDogJ1RoaXMgaXMgdGhlIHRleHQgYm9keSBvZiB0aGUgc2VsZnBvc3QnXG4gICAqIH0pLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IFN1Ym1pc3Npb24geyBuYW1lOiAndDNfNGFibXN6JyB9XG4gICAqIC8vIChuZXcgc2VsZnBvc3QgY3JlYXRlZCBvbiByZWRkaXQpXG4gICAqL1xuXG5cbiAgc3VibWl0U2VsZnBvc3Qob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9zdWJtaXQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAga2luZDogJ3NlbGYnXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgbmV3IGxpbmsgc3VibWlzc2lvbiBvbiB0aGUgZ2l2ZW4gc3VicmVkZGl0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1YnJlZGRpdE5hbWUgVGhlIG5hbWUgb2YgdGhlIHN1YnJlZGRpdCB0aGF0IHRoZSBwb3N0IHNob3VsZCBiZSBzdWJtaXR0ZWQgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgVGhlIHRpdGxlIG9mIHRoZSBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybCBUaGUgdXJsIHRoYXQgdGhlIGxpbmsgc3VibWlzc2lvbiBzaG91bGQgcG9pbnQgdG9cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kUmVwbGllcz10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgaW5ib3ggcmVwbGllcyBzaG91bGQgYmUgZW5hYmxlZCBmb3IgdGhpcyBzdWJtaXNzaW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzdWJtaXQ9dHJ1ZV0gSWYgdGhpcyBpcyBmYWxzZSBhbmQgc2FtZSBsaW5rIGhhcyBhbHJlYWR5IGJlZW4gc3VibWl0dGVkIHRvIHRoaXMgc3VicmVkZGl0IGluXG4gICB0aGUgcGFzdCwgcmVkZGl0IHdpbGwgcmV0dXJuIGFuIGVycm9yLiBUaGlzIGNvdWxkIGJlIHVzZWQgdG8gYXZvaWQgYWNjaWRlbnRhbCByZXBvc3RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FwdGNoYUlkZW5dIEEgY2FwdGNoYSBpZGVudGlmaWVyLiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIHRoZSBhdXRoZW50aWNhdGVkIGFjY291bnRcbiAgIHJlcXVpcmVzIGEgY2FwdGNoYSB0byBzdWJtaXQgcG9zdHMgYW5kIGNvbW1lbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FwdGNoYVJlc3BvbnNlXSBUaGUgcmVzcG9uc2UgdG8gdGhlIGNhcHRjaGEgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIG5ld2x5LWNyZWF0ZWQgU3VibWlzc2lvbiBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5zdWJtaXRMaW5rKHtcbiAgICogICBzdWJyZWRkaXROYW1lOiAnc25vb3dyYXBfdGVzdGluZycsXG4gICAqICAgdGl0bGU6ICdJIGZvdW5kIGEgY29vbCB3ZWJzaXRlIScsXG4gICAqICAgdXJsOiAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuICAgKiB9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBTdWJtaXNzaW9uIHsgbmFtZTogJ3QzXzRhYm5mZScgfVxuICAgKiAvLyAobmV3IGxpbmtwb3N0IGNyZWF0ZWQgb24gcmVkZGl0KVxuICAgKi9cblxuXG4gIHN1Ym1pdExpbmsob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9zdWJtaXQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAga2luZDogJ2xpbmsnXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDcmVhdGVzIGEgbmV3IGNyb3NzcG9zdCBzdWJtaXNzaW9uIG9uIHRoZSBnaXZlbiBzdWJyZWRkaXRcbiAgICogQGRlc2MgKipOT1RFKio6IFRvIGNyZWF0ZSBhIGNyb3NzcG9zdCwgdGhlIGF1dGhlbnRpY2F0ZWQgYWNjb3VudCBtdXN0IGJlIHN1YnNjcmliZWQgdG8gdGhlIHN1YnJlZGRpdCB3aGVyZVxuICAgKiB0aGUgY3Jvc3Nwb3N0IGlzIGJlaW5nIHN1Ym1pdHRlZCwgYW5kIHRoYXQgc3VicmVkZGl0IGJlIGNvbmZpZ3VyZWQgdG8gYWxsb3cgY3Jvc3Nwb3N0cy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgc3VibWlzc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdWJyZWRkaXROYW1lIFRoZSBuYW1lIG9mIHRoZSBzdWJyZWRkaXQgdGhhdCB0aGUgY3Jvc3Nwb3N0IHNob3VsZCBiZSBzdWJtaXR0ZWQgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgVGhlIHRpdGxlIG9mIHRoZSBjcm9zc3Bvc3RcbiAgICogQHBhcmFtIHsoc3RyaW5nfFN1Ym1pc3Npb24pfSBvcHRpb25zLm9yaWdpbmFsUG9zdCBBIFN1Ym1pc3Npb24gb2JqZWN0IG9yIGEgcG9zdCBJRCBmb3IgdGhlIG9yaWdpbmFsIHBvc3Qgd2hpY2hcbiAgIGlzIGJlaW5nIGNyb3NzcG9zdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VuZFJlcGxpZXM9dHJ1ZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIGluYm94IHJlcGxpZXMgc2hvdWxkIGJlIGVuYWJsZWQgZm9yIHRoaXMgc3VibWlzc2lvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3VibWl0PXRydWVdIElmIHRoaXMgaXMgZmFsc2UgYW5kIHNhbWUgbGluayBoYXMgYWxyZWFkeSBiZWVuIHN1Ym1pdHRlZCB0byB0aGlzIHN1YnJlZGRpdCBpblxuICAgdGhlIHBhc3QsIHJlZGRpdCB3aWxsIHJldHVybiBhbiBlcnJvci4gVGhpcyBjb3VsZCBiZSB1c2VkIHRvIGF2b2lkIGFjY2lkZW50YWwgcmVwb3N0cy5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBuZXdseS1jcmVhdGVkIFN1Ym1pc3Npb24gb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGF3YWl0IHIuc3VibWl0Q3Jvc3Nwb3N0KHsgdGl0bGU6ICdJIGZvdW5kIGFuIGludGVyZXN0aW5nIHBvc3QnLCBvcmlnaW5hbFBvc3Q6ICc2dnRoczAnLCBzdWJyZWRkaXROYW1lOiAnc25vb3dyYXAnIH0pXG4gICAqL1xuXG5cbiAgc3VibWl0Q3Jvc3Nwb3N0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fc3VibWl0KF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6ICdjcm9zc3Bvc3QnLFxuICAgICAgY3Jvc3Nwb3N0X2Z1bGxuYW1lOiBvcHRpb25zLm9yaWdpbmFsUG9zdCBpbnN0YW5jZW9mIHNub293cmFwLm9iamVjdHMuU3VibWlzc2lvbiA/IG9wdGlvbnMub3JpZ2luYWxQb3N0Lm5hbWUgOiAoMCwgX2hlbHBlcnMuYWRkRnVsbG5hbWVQcmVmaXgpKG9wdGlvbnMub3JpZ2luYWxQb3N0LCAndDNfJylcbiAgICB9KSk7XG4gIH1cblxuICBfZ2V0U29ydGVkRnJvbnRwYWdlKHNvcnRUeXBlLCBzdWJyZWRkaXROYW1lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIC8vIEhhbmRsZSB0aGluZ3MgcHJvcGVybHkgaWYgb25seSBhIHRpbWUgcGFyYW1ldGVyIGlzIHByb3ZpZGVkIGJ1dCBub3QgdGhlIHN1YnJlZGRpdCBuYW1lXG4gICAgdmFyIG9wdHMgPSBvcHRpb25zO1xuICAgIHZhciBzdWJOYW1lID0gc3VicmVkZGl0TmFtZTtcblxuICAgIGlmICh0eXBlb2Ygc3VicmVkZGl0TmFtZSA9PT0gJ29iamVjdCcgJiYgKDAsIF9sb2Rhc2guaXNFbXB0eSkoKDAsIF9sb2Rhc2gub21pdEJ5KShvcHRzLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uID09PSB1bmRlZmluZWQ7XG4gICAgfSkpKSB7XG4gICAgICAvKiBJbiB0aGlzIGNhc2UsIFwic3VicmVkZGl0TmFtZVwiIGVuZHMgdXAgcmVmZXJyaW5nIHRvIHRoZSBzZWNvbmQgYXJndW1lbnQsIHdoaWNoIGlzIG5vdCBhY3R1YWxseSBhIG5hbWUgc2luY2UgdGhlIHVzZXJcbiAgICAgIGRlY2lkZWQgdG8gb21pdCB0aGF0IHBhcmFtZXRlci4gKi9cbiAgICAgIG9wdHMgPSBzdWJyZWRkaXROYW1lO1xuICAgICAgc3ViTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkT3B0aW9ucyA9ICgwLCBfbG9kYXNoLm9taXQpKF9vYmplY3RTcHJlYWQoe30sIG9wdHMsIHtcbiAgICAgIHQ6IG9wdHMudGltZSB8fCBvcHRzLnRcbiAgICB9KSwgJ3RpbWUnKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IChzdWJOYW1lID8gXCJyL1wiLmNvbmNhdChzdWJOYW1lLCBcIi9cIikgOiAnJykgKyBzb3J0VHlwZSxcbiAgICAgIHFzOiBwYXJzZWRPcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYSBMaXN0aW5nIG9mIGhvdCBwb3N0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdWJyZWRkaXROYW1lXSBUaGUgc3VicmVkZGl0IHRvIGdldCBwb3N0cyBmcm9tLiBJZiBub3QgcHJvdmlkZWQsIHBvc3RzIGFyZSBmZXRjaGVkIGZyb21cbiAgIHRoZSBmcm9udCBwYWdlIG9mIHJlZGRpdC5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIHRoZSByZXRyaWV2ZWQgc3VibWlzc2lvbnNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRIb3QoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdpbWd1ci5jb20nLCBiYW5uZWRfYnk6IG51bGwsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAncGljcycgfSwgLi4uIH0sXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAnaS5pbWd1ci5jb20nLCBiYW5uZWRfYnk6IG51bGwsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAnZnVubnknIH0sIC4uLiB9LFxuICAgKiAvLyAgLi4uXG4gICAqIC8vIF1cbiAgICpcbiAgICogci5nZXRIb3QoJ2dpZnMnKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdpLmltZ3VyLmNvbScsIGJhbm5lZF9ieTogbnVsbCwgc3VicmVkZGl0OiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdnaWZzJyB9LCAuLi4gfSxcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdpLmltZ3VyLmNvbScsIGJhbm5lZF9ieTogbnVsbCwgc3VicmVkZGl0OiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdnaWZzJyB9LCAuLi4gfSxcbiAgICogLy8gIC4uLlxuICAgKiAvLyBdXG4gICAqXG4gICAqIHIuZ2V0SG90KCdyZWRkaXRkZXYnLCB7bGltaXQ6IDF9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgIC8vICAgU3VibWlzc2lvbiB7IGRvbWFpbjogJ3NlbGYucmVkZGl0ZGV2JywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3JlZGRpdGRldicgfSwgLi4ufVxuICAgKiAvLyBdXG4gICAqL1xuXG5cbiAgZ2V0SG90KHN1YnJlZGRpdE5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRnJvbnRwYWdlKCdob3QnLCBzdWJyZWRkaXROYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBhIExpc3Rpbmcgb2YgYmVzdCBwb3N0cy5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdGluZz59IEEgTGlzdGluZyBjb250YWluaW5nIHRoZSByZXRyaWV2ZWQgc3VibWlzc2lvbnNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRCZXN0KCkudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAnaW1ndXIuY29tJywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3BpY3MnIH0sIC4uLiB9LFxuICAgKiAvLyAgU3VibWlzc2lvbiB7IGRvbWFpbjogJ2kuaW1ndXIuY29tJywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ2Z1bm55JyB9LCAuLi4gfSxcbiAgICogLy8gIC4uLlxuICAgKiAvLyBdXG4gICAqXG4gICAqIHIuZ2V0QmVzdCh7bGltaXQ6IDF9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgIC8vICAgU3VibWlzc2lvbiB7IGRvbWFpbjogJ3NlbGYucmVkZGl0ZGV2JywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3JlZGRpdGRldicgfSwgLi4ufVxuICAgKiAvLyBdXG4gICAqL1xuXG5cbiAgZ2V0QmVzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZEZyb250cGFnZSgnYmVzdCcsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYSBMaXN0aW5nIG9mIG5ldyBwb3N0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdWJyZWRkaXROYW1lXSBUaGUgc3VicmVkZGl0IHRvIGdldCBwb3N0cyBmcm9tLiBJZiBub3QgcHJvdmlkZWQsIHBvc3RzIGFyZSBmZXRjaGVkIGZyb21cbiAgIHRoZSBmcm9udCBwYWdlIG9mIHJlZGRpdC5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIHRoZSByZXRyaWV2ZWQgc3VibWlzc2lvbnNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXROZXcoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdzZWxmLkpva2VzJywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ0pva2VzJyB9LCAuLi4gfSxcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdzZWxmLkFza1JlZGRpdCcsIGJhbm5lZF9ieTogbnVsbCwgc3VicmVkZGl0OiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdBc2tSZWRkaXQnIH0sIC4uLiB9LFxuICAgKiAvLyAgLi4uXG4gICAqIC8vIF1cbiAgICpcbiAgICovXG5cblxuICBnZXROZXcoc3VicmVkZGl0TmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWRGcm9udHBhZ2UoJ25ldycsIHN1YnJlZGRpdE5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiBuZXcgY29tbWVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VicmVkZGl0TmFtZV0gVGhlIHN1YnJlZGRpdCB0byBnZXQgY29tbWVudHMgZnJvbS4gSWYgbm90IHByb3ZpZGVkLCBwb3N0cyBhcmUgZmV0Y2hlZCBmcm9tXG4gICB0aGUgZnJvbnQgcGFnZSBvZiByZWRkaXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyB0aGUgcmV0cmlldmVkIGNvbW1lbnRzXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0TmV3Q29tbWVudHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIENvbW1lbnQgeyBsaW5rX3RpdGxlOiAnV2hhdCBhbWF6aW5nIGJvb2sgc2hvdWxkIGJlIG1hZGUgaW50byBhIG1vdmllLCBidXQgaGFzblxcJ3QgYmVlbiB5ZXQ/JywgLi4uIH1cbiAgICogLy8gIENvbW1lbnQgeyBsaW5rX3RpdGxlOiAnSG93IGZhciBiYWNrIGluIHRpbWUgY291bGQgeW91IGdvIGFuZCBzdGlsbCB1bmRlcnN0YW5kIEVuZ2xpc2g/JywgLi4uIH1cbiAgICogLy8gXVxuICAgKi9cblxuXG4gIGdldE5ld0NvbW1lbnRzKHN1YnJlZGRpdE5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRnJvbnRwYWdlKCdjb21tZW50cycsIHN1YnJlZGRpdE5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiAgQHN1bW1hcnkgR2V0IGxpc3Qgb2YgY29udGVudCBieSBJRHMuIFJldHVybnMgYSBsaXN0aW5nIG9mIHRoZSByZXF1ZXN0ZWQgY29udGVudC5cbiAgICogIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN1Ym1pc3Npb258Q29tbWVudD59IGlkcyBBbiBhcnJheSBvZiBjb250ZW50IElEcy4gQ2FuIGluY2x1ZGUgdGhlIGlkIGl0c2VsZiwgb3IgYSBTdWJtaXNzaW9uIG9yIENvbW1lbnQgb2JqZWN0LlxuICBjYW4gZ2V0IGEgcG9zdCBhbmQgYSBjb21tZW50ICAgKiAgQHJldHVybnMge1Byb21pc2U8TGlzdGluZzxTdWJtaXNzaW9ufENvbW1lbnQ+Pn0gQSBsaXN0aW5nIG9mIGNvbnRlbnQgcmVxdWVzdGVkLCBjYW4gYmUgYW55IGNsYXNzIGZldGNoYWJsZSBieSBBUEkuIGUuZy4gQ29tbWVudCwgU3VibWlzc2lvblxuICAgKiAgQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRDb250ZW50QnlJZHMoWyd0M185bDl2b2YnLCd0M185bGEzNDEnXSkudGhlbihjb25zb2xlLmxvZyk7XG4gICAqIC8vID0+IExpc3RpbmcgW1xuICAgKiAvLyAgU3VibWlzc2lvbiB7IGFwcHJvdmVkX2F0X3V0YzogbnVsbCwgLi4uIH1cbiAgICogLy8gIFN1Ym1pc3Npb24geyBhcHByb3ZlZF9hdF91dGM6IG51bGwsIC4uLiB9XG4gICAqIC8vIF1cbiAgICpcbiAgICogci5nZXRDb250ZW50QnlJZHMoW3IuZ2V0U3VibWlzc2lvbignOWw5dm9mJyksIHIuZ2V0U3VibWlzc2lvbignOWxhMzQxJyldKS50aGVuKGNvbnNvbGUubG9nKTtcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgYXBwcm92ZWRfYXRfdXRjOiBudWxsLCAuLi4gfVxuICAgKiAvLyAgU3VibWlzc2lvbiB7IGFwcHJvdmVkX2F0X3V0YzogbnVsbCwgLi4uIH1cbiAgICogLy8gXVxuICAqL1xuXG5cbiAgZ2V0Q29udGVudEJ5SWRzKGlkcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBBcmd1bWVudCBuZWVkcyB0byBiZSBhbiBhcnJheS4nKTtcbiAgICB9XG5cbiAgICB2YXIgcHJlZml4ZWRJZHMgPSBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKGlkIGluc3RhbmNlb2Ygc25vb3dyYXAub2JqZWN0cy5TdWJtaXNzaW9uIHx8IGlkIGluc3RhbmNlb2Ygc25vb3dyYXAub2JqZWN0cy5Db21tZW50KSB7XG4gICAgICAgIHJldHVybiBpZC5uYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghL3QoMXwzKV8vZy50ZXN0KGlkcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBJZHMgbmVlZCB0byBpbmNsdWRlIFN1Ym1pc3Npb24gb3IgQ29tbWVudCBwcmVmaXgsIGUuZy4gdDFfLCB0M18uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nLCBTdWJtaXNzaW9uLCBvciBDb21tZW50LicpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiAnL2FwaS9pbmZvJyxcbiAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICBxczoge1xuICAgICAgICBpZDogcHJlZml4ZWRJZHMuam9pbignLCcpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYSBzaW5nbGUgcmFuZG9tIFN1Ym1pc3Npb24uXG4gICAqIEBkZXNjICoqTm90ZSoqOiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IHdvcmsgd2hlbiBzbm9vd3JhcCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciwgYmVjYXVzZSB0aGUgcmVkZGl0IHNlcnZlciBzZW5kcyBhXG4gICByZWRpcmVjdCB3aGljaCBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgYSBDT1JTIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VicmVkZGl0TmFtZV0gVGhlIHN1YnJlZGRpdCB0byBnZXQgdGhlIHJhbmRvbSBzdWJtaXNzaW9uLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBwb3N0IGlzIGZldGNoZWQgZnJvbVxuICAgdGhlIGZyb250IHBhZ2Ugb2YgcmVkZGl0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHJldHJpZXZlZCBTdWJtaXNzaW9uIG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldFJhbmRvbVN1Ym1pc3Npb24oJ2F3dycpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IFN1Ym1pc3Npb24geyBkb21haW46ICdpLmltZ3VyLmNvbScsIGJhbm5lZF9ieTogbnVsbCwgc3VicmVkZGl0OiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdhd3cnIH0sIC4uLiB9XG4gICAqL1xuXG5cbiAgZ2V0UmFuZG9tU3VibWlzc2lvbihzdWJyZWRkaXROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6IFwiXCIuY29uY2F0KHN1YnJlZGRpdE5hbWUgPyBcInIvXCIuY29uY2F0KHN1YnJlZGRpdE5hbWUsIFwiL1wiKSA6ICcnLCBcInJhbmRvbVwiKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiB0b3AgcG9zdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VicmVkZGl0TmFtZV0gVGhlIHN1YnJlZGRpdCB0byBnZXQgcG9zdHMgZnJvbS4gSWYgbm90IHByb3ZpZGVkLCBwb3N0cyBhcmUgZmV0Y2hlZCBmcm9tXG4gICB0aGUgZnJvbnQgcGFnZSBvZiByZWRkaXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aW1lXSBEZXNjcmliZXMgdGhlIHRpbWVzcGFuIHRoYXQgcG9zdHMgc2hvdWxkIGJlIHJldHJpZXZlZCBmcm9tLiBTaG91bGQgYmUgb25lIG9mXG4gICBgaG91ciwgZGF5LCB3ZWVrLCBtb250aCwgeWVhciwgYWxsYFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgdGhlIHJldHJpZXZlZCBzdWJtaXNzaW9uc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldFRvcCh7dGltZTogJ2FsbCcsIGxpbWl0OiAyfSkudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAnc2VsZi5Bc2tSZWRkaXQnLCBiYW5uZWRfYnk6IG51bGwsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAnQXNrUmVkZGl0JyB9LCAuLi4gfSxcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdpbWd1ci5jb20nLCBiYW5uZWRfYnk6IG51bGwsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAnZnVubnknIH0sIC4uLiB9XG4gICAqIC8vIF1cbiAgICpcbiAgICogci5nZXRUb3AoJ0Fza1JlZGRpdCcpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IExpc3RpbmcgW1xuICAgKiAvLyAgU3VibWlzc2lvbiB7IGRvbWFpbjogJ3NlbGYuQXNrUmVkZGl0JywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ0Fza1JlZGRpdCcgfSwgLi4uIH0sXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAnc2VsZi5Bc2tSZWRkaXQnLCBiYW5uZWRfYnk6IG51bGwsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAnQXNrUmVkZGl0JyB9LCAuLi4gfSxcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdzZWxmLkFza1JlZGRpdCcsIGJhbm5lZF9ieTogbnVsbCwgc3VicmVkZGl0OiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdBc2tSZWRkaXQnIH0sIC4uLiB9LFxuICAgKiAvLyAgLi4uXG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRUb3Aoc3VicmVkZGl0TmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWRGcm9udHBhZ2UoJ3RvcCcsIHN1YnJlZGRpdE5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgTGlzdGluZyBvZiBjb250cm92ZXJzaWFsIHBvc3RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1YnJlZGRpdE5hbWVdIFRoZSBzdWJyZWRkaXQgdG8gZ2V0IHBvc3RzIGZyb20uIElmIG5vdCBwcm92aWRlZCwgcG9zdHMgYXJlIGZldGNoZWQgZnJvbVxuICAgdGhlIGZyb250IHBhZ2Ugb2YgcmVkZGl0LlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGltZV0gRGVzY3JpYmVzIHRoZSB0aW1lc3BhbiB0aGF0IHBvc3RzIHNob3VsZCBiZSByZXRyaWV2ZWQgZnJvbS4gU2hvdWxkIGJlIG9uZSBvZlxuICAgYGhvdXIsIGRheSwgd2VlaywgbW9udGgsIHllYXIsIGFsbGBcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIHRoZSByZXRyaWV2ZWQgc3VibWlzc2lvbnNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRDb250cm92ZXJzaWFsKCd0ZWNobm9sb2d5JykudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAndGhlbmV4dHdlYi5jb20nLCBiYW5uZWRfYnk6IG51bGwsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAndGVjaG5vbG9neScgfSwgLi4uIH0sXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAncGNtYWcuY29tJywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3RlY2hub2xvZ3knIH0sIC4uLiB9XG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRDb250cm92ZXJzaWFsKHN1YnJlZGRpdE5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRnJvbnRwYWdlKCdjb250cm92ZXJzaWFsJywgc3VicmVkZGl0TmFtZSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYSBMaXN0aW5nIG9mIGNvbnRyb3ZlcnNpYWwgcG9zdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VicmVkZGl0TmFtZV0gVGhlIHN1YnJlZGRpdCB0byBnZXQgcG9zdHMgZnJvbS4gSWYgbm90IHByb3ZpZGVkLCBwb3N0cyBhcmUgZmV0Y2hlZCBmcm9tXG4gICB0aGUgZnJvbnQgcGFnZSBvZiByZWRkaXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyB0aGUgcmV0cmlldmVkIHN1Ym1pc3Npb25zXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0UmlzaW5nKCd0ZWNobm9sb2d5JykudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAndGhlbmV4dHdlYi5jb20nLCBiYW5uZWRfYnk6IG51bGwsIHN1YnJlZGRpdDogU3VicmVkZGl0IHsgZGlzcGxheV9uYW1lOiAndGVjaG5vbG9neScgfSwgLi4uIH0sXG4gICAqIC8vICBTdWJtaXNzaW9uIHsgZG9tYWluOiAncGNtYWcuY29tJywgYmFubmVkX2J5OiBudWxsLCBzdWJyZWRkaXQ6IFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3RlY2hub2xvZ3knIH0sIC4uLiB9XG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRSaXNpbmcoc3VicmVkZGl0TmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWRGcm9udHBhZ2UoJ3Jpc2luZycsIHN1YnJlZGRpdE5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIncyB1bnJlYWQgbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyB1bnJlYWQgaXRlbXMgaW4gdGhlIHVzZXIncyBpbmJveFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldFVucmVhZE1lc3NhZ2VzKCkudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBQcml2YXRlTWVzc2FnZSB7IGJvZHk6ICdoaSEnLCB3YXNfY29tbWVudDogZmFsc2UsIGZpcnN0X21lc3NhZ2U6IG51bGwsIC4uLiB9LFxuICAgKiAvLyAgQ29tbWVudCB7IGJvZHk6ICd0aGlzIGlzIGEgcmVwbHknLCBsaW5rX3RpdGxlOiAnWWF5LCBhIHNlbGZwb3N0IScsIHdhc19jb21tZW50OiB0cnVlLCAuLi4gfVxuICAgKiAvLyBdXG4gICAqL1xuXG5cbiAgZ2V0VW5yZWFkTWVzc2FnZXMoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogJ21lc3NhZ2UvdW5yZWFkJyxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgdGhlIGl0ZW1zIGluIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIncyBpbmJveC5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBGaWx0ZXIgb3B0aW9ucy4gQ2FuIGFsc28gY29udGFpbiBvcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5maWx0ZXJdIEEgZmlsdGVyIGZvciB0aGUgaW5ib3ggaXRlbXMuIElmIHByb3ZpZGVkLCBpdCBzaG91bGQgYmUgb25lIG9mIGB1bnJlYWRgLCAodW5yZWFkXG4gICBpdGVtcyksIGBtZXNzYWdlc2AgKGkuZS4gUE1zKSwgYGNvbW1lbnRzYCAoY29tbWVudCByZXBsaWVzKSwgYHNlbGZyZXBseWAgKHNlbGZwb3N0IHJlcGxpZXMpLCBvciBgbWVudGlvbnNgICh1c2VybmFtZVxuICAgbWVudGlvbnMpLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgaXRlbXMgaW4gdGhlIHVzZXIncyBpbmJveFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldEluYm94KCkudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBQcml2YXRlTWVzc2FnZSB7IGJvZHk6ICdoaSEnLCB3YXNfY29tbWVudDogZmFsc2UsIGZpcnN0X21lc3NhZ2U6IG51bGwsIC4uLiB9LFxuICAgKiAvLyAgQ29tbWVudCB7IGJvZHk6ICd0aGlzIGlzIGEgcmVwbHknLCBsaW5rX3RpdGxlOiAnWWF5LCBhIHNlbGZwb3N0IScsIHdhc19jb21tZW50OiB0cnVlLCAuLi4gfVxuICAgKiAvLyBdXG4gICAqL1xuXG5cbiAgZ2V0SW5ib3goKSB7XG4gICAgdmFyIF9yZWY2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgZmlsdGVyID0gX3JlZjYuZmlsdGVyLFxuICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY2LCBbXCJmaWx0ZXJcIl0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiBcIm1lc3NhZ2UvXCIuY29uY2F0KGZpbHRlciB8fCAnaW5ib3gnKSxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlcidzIG1vZG1haWwuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3Rpbmcgb2YgdGhlIHVzZXIncyBtb2RtYWlsXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0TW9kbWFpbCh7bGltaXQ6IDJ9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIFByaXZhdGVNZXNzYWdlIHsgYm9keTogJy91L25vdF9hbl9hYXJkdmFyayBoYXMgYWNjZXB0ZWQgYW4gaW52aXRhdGlvbiB0byBiZWNvbWUgbW9kZXJhdG9yIC4uLiAnLCAuLi4gfSxcbiAgICogLy8gIFByaXZhdGVNZXNzYWdlIHsgYm9keTogJy91L25vdF9hbl9hYXJkdmFyayBoYXMgYmVlbiBpbnZpdGVkIGJ5IC91L2FjdHVhbGx5X2FuX2FhcmR2YXJrIHRvIC4uLicsIC4uLiB9XG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRNb2RtYWlsKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6ICdtZXNzYWdlL21vZGVyYXRvcicsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiBNb2RtYWlsQ29udmVyc2F0aW9ucyBmcm9tIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIncyBzdWJyZWRkaXRzLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0aW5nPE1vZG1haWxDb252ZXJzYXRpb24+Pn0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VicmVkZGl0c1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE5ld01vZG1haWxDb252ZXJzYXRpb25zKHtsaW1pdDogMn0pLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IExpc3RpbmcgW1xuICAgKiAvLyAgTW9kbWFpbENvbnZlcnNhdGlvbiB7IG1lc3NhZ2VzOiBbLi4uXSwgb2JqSWRzOiBbLi4uXSwgc3ViamVjdDogJ3Rlc3Qgc3ViamVjdCcsIC4uLiB9LFxuICAgKiAvLyAgTW9kbWFpbENvbnZlcnNhdGlvbiB7IG1lc3NhZ2VzOiBbLi4uXSwgb2JqSWRzOiBbLi4uXSwgc3ViamVjdDogJ3Rlc3Qgc3ViamVjdCcsIC4uLiB9XG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXROZXdNb2RtYWlsQ29udmVyc2F0aW9ucygpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6ICdhcGkvbW9kL2NvbnZlcnNhdGlvbnMnLFxuICAgICAgcXM6IG9wdGlvbnMsXG4gICAgICBfbmFtZTogJ01vZG1haWxDb252ZXJzYXRpb24nLFxuICAgICAgX3RyYW5zZm9ybTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLmFmdGVyID0gbnVsbDtcbiAgICAgICAgcmVzcG9uc2UuYmVmb3JlID0gbnVsbDtcbiAgICAgICAgcmVzcG9uc2UuY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBjb252ZXJzYXRpb24gb2YgcmVzcG9uc2UuY29udmVyc2F0aW9uSWRzKSB7XG4gICAgICAgICAgcmVzcG9uc2UuY29udmVyc2F0aW9uc1tjb252ZXJzYXRpb25dLnBhcnRpY2lwYW50ID0gX3RoaXM2Ll9uZXdPYmplY3QoJ01vZG1haWxDb252ZXJzYXRpb25BdXRob3InLCBfb2JqZWN0U3ByZWFkKHt9LCByZXNwb25zZS5jb252ZXJzYXRpb25zW2NvbnZlcnNhdGlvbl0ucGFydGljaXBhbnQpKTtcblxuICAgICAgICAgIHZhciBjb252ZXJzYXRpb25PYmplY3RzID0gb2JqZWN0cy5Nb2RtYWlsQ29udmVyc2F0aW9uLl9nZXRDb252ZXJzYXRpb25PYmplY3RzKHJlc3BvbnNlLmNvbnZlcnNhdGlvbnNbY29udmVyc2F0aW9uXSwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgdmFyIGRhdGEgPSBfb2JqZWN0U3ByZWFkKHt9LCBjb252ZXJzYXRpb25PYmplY3RzLCB7fSwgcmVzcG9uc2UuY29udmVyc2F0aW9uc1tjb252ZXJzYXRpb25dKTtcblxuICAgICAgICAgIHJlc3BvbnNlLmNoaWxkcmVuLnB1c2goX3RoaXM2Ll9uZXdPYmplY3QoJ01vZG1haWxDb252ZXJzYXRpb24nLCBkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXM2Ll9uZXdPYmplY3QoJ0xpc3RpbmcnLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBtb2RtYWlsIGRpc2N1c3Npb24gYmV0d2VlbiBtb2RlcmF0b3JzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJvZHkgQm9keSBvZiB0aGUgZGlzY3Vzc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdWJqZWN0IFRpdGxlIG9yIHN1YmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3JOYW1lIFN1YnJlZGRpdCBuYW1lIHdpdGhvdXQgZnVsbG5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kbWFpbENvbnZlcnNhdGlvbj59IHRoZSBjcmVhdGVkIE1vZG1haWxDb252ZXJzYXRpb25cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5jcmVhdGVNb2RlcmF0b3JEaXNjdXNzaW9uKHtcbiAgICogICBib2R5OiAndGVzdCBib2R5JyxcbiAgICogICBzdWJqZWN0OiAndGVzdCBzdWJqZWN0JyxcbiAgICogICBzck5hbWU6ICdBc2tSZWRkaXQnXG4gICAqIH0pLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vIE1vZG1haWxDb252ZXJzYXRpb24geyBtZXNzYWdlczogWy4uLl0sIG9iaklkczogWy4uLl0sIHN1YmplY3Q6ICd0ZXN0IHN1YmplY3QnLCAuLi4gfVxuICAgKi9cblxuXG4gIGNyZWF0ZU1vZG1haWxEaXNjdXNzaW9uKF9yZWY3KSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICB2YXIgYm9keSA9IF9yZWY3LmJvZHksXG4gICAgICAgIHN1YmplY3QgPSBfcmVmNy5zdWJqZWN0LFxuICAgICAgICBzck5hbWUgPSBfcmVmNy5zck5hbWU7XG4gICAgdmFyIHBhcnNlZEZyb21TciA9IHNyTmFtZS5yZXBsYWNlKC9eXFwvP3JcXC8vLCAnJyk7IC8vIENvbnZlcnQgJy9yL3N1YnJlZGRpdF9uYW1lJyB0byAnc3VicmVkZGl0X25hbWUnXG4gICAgLy8gX25ld09iamVjdCBpZ25vcmVzIG1vc3Qgb2YgdGhlIHJlc3BvbnNlLCBubyBwcmFjdGljYWwgd2F5IHRvIHBhcnNlIHRoZSByZXR1cm5lZCBjb250ZW50IHlldFxuXG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL21vZC9jb252ZXJzYXRpb25zJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgc3ViamVjdCxcbiAgICAgICAgc3JOYW1lOiBwYXJzZWRGcm9tU3JcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJldHVybiBfdGhpczcuX25ld09iamVjdCgnTW9kbWFpbENvbnZlcnNhdGlvbicsIHtcbiAgICAgICAgaWQ6IHJlcy5jb252ZXJzYXRpb24uaWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXQgYSBNb2RtYWlsQ29udmVyc2F0aW9uIGJ5IGl0cyBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgb2YgdGhlIE1vZG1haWxDb252ZXJzYXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8TW9kbWFpbENvbnZlcnNhdGlvbj59IHRoZSByZXF1ZXN0ZWQgTW9kbWFpbENvbnZlcnNhdGlvblxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE5ld01vZG1haWxDb252ZXJzYXRpb24oJzc1aHh0JykudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gTW9kbWFpbENvbnZlcnNhdGlvbiB7IG1lc3NhZ2VzOiBbLi4uXSwgb2JqSWRzOiBbLi4uXSwgLi4uIH1cbiAgICovXG5cblxuICBnZXROZXdNb2RtYWlsQ29udmVyc2F0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX25ld09iamVjdCgnTW9kbWFpbENvbnZlcnNhdGlvbicsIHtcbiAgICAgIGlkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE1hcmtzIGFsbCBjb252ZXJzYXRpb25zIGluIGFycmF5IGFzIHJlYWQuXG4gICAqIEBwYXJhbSB7TW9kbWFpbENvbnZlcnNhdGlvbltdfSBjb252ZXJzYXRpb25zIHRvIG1hcmsgYXMgcmVhZFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLm1hcmtOZXdNb2RtYWlsQ29udmVyc2F0aW9uc0FzUmVhZChbJ3BpY3MnLCAnc3dlZGVuJ10pXG4gICAqL1xuXG5cbiAgbWFya05ld01vZG1haWxDb252ZXJzYXRpb25zQXNSZWFkKGNvbnZlcnNhdGlvbnMpIHtcbiAgICB2YXIgY29udmVyc2F0aW9uSWRzID0gY29udmVyc2F0aW9ucy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiAoMCwgX2hlbHBlcnMuYWRkRnVsbG5hbWVQcmVmaXgpKG1lc3NhZ2UsICcnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvbW9kL2NvbnZlcnNhdGlvbnMvcmVhZCcsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGNvbnZlcnNhdGlvbklkczogY29udmVyc2F0aW9uSWRzLmpvaW4oJywnKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBNYXJrcyBhbGwgY29udmVyc2F0aW9ucyBpbiBhcnJheSBhcyB1bnJlYWQuXG4gICAqIEBwYXJhbSB7TW9kbWFpbENvbnZlcnNhdGlvbltdfSBjb252ZXJzYXRpb25zIHRvIG1hcmsgYXMgdW5yZWFkXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIubWFya05ld01vZG1haWxDb252ZXJzYXRpb25zQXNVbnJlYWQoWydwaWNzJywgJ3N3ZWRlbiddKVxuICAgKi9cblxuXG4gIG1hcmtOZXdNb2RtYWlsQ29udmVyc2F0aW9uc0FzVW5yZWFkKGNvbnZlcnNhdGlvbnMpIHtcbiAgICB2YXIgY29udmVyc2F0aW9uSWRzID0gY29udmVyc2F0aW9ucy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiAoMCwgX2hlbHBlcnMuYWRkRnVsbG5hbWVQcmVmaXgpKG1lc3NhZ2UsICcnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvbW9kL2NvbnZlcnNhdGlvbnMvdW5yZWFkJyxcbiAgICAgIGZvcm06IHtcbiAgICAgICAgY29udmVyc2F0aW9uSWRzOiBjb252ZXJzYXRpb25JZHMuam9pbignLCcpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYWxsIG1vZGVyYXRlZCBzdWJyZWRkaXRzIHRoYXQgaGF2ZSBuZXcgTW9kbWFpbCBhY3RpdmF0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdGluZzxTdWJyZWRkaXQ+Pn0gYSBMaXN0aW5nIG9mIE1vZG1haWxDb252ZXJzYXRpb25zIG1hcmtlZCBhcyByZWFkXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0TmV3TW9kbWFpbFN1YnJlZGRpdHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3RpcG9mbXl0b25ndWUnLCAuLi4gfSxcbiAgICogLy8gIFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ0VhcnRoUG9ybicsIC4uLiB9LFxuICAgKiAvLyBdXG4gICAqL1xuXG5cbiAgZ2V0TmV3TW9kbWFpbFN1YnJlZGRpdHMoKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogJ2FwaS9tb2QvY29udmVyc2F0aW9ucy9zdWJyZWRkaXRzJ1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXNwb25zZS5zdWJyZWRkaXRzKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOC5fbmV3T2JqZWN0KCdTdWJyZWRkaXQnLCBzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBSZXByZXNlbnRzIHRoZSB1bnJlYWQgY291bnQgaW4gYSB7QGxpbmsgTW9kbWFpbENvbnZlcnNhdGlvbn0uIEVhY2ggb2YgdGhlc2UgcHJvcGVydGllc1xuICAgKiBjb3JyZXNwb25kIHRvIHRoZSBhbW91bnQgb2YgdW5yZWFkIGNvbnZlcnNhdGlvbnMgb2YgdGhhdCB0eXBlLlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBVbnJlYWRDb3VudFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGlnaGxpZ2h0ZWRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5vdGlmaWNhdGlvbnNcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFyY2hpdmVkXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZXdcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlucHJvZ3Jlc3NcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1vZFxuICAgKi9cblxuICAvKipcbiAgICogQHN1bW1hcnkgUmV0cmlldmVzIGFuIG9iamVjdCBvZiB1bnJlYWQgTW9kbWFpbCBjb252ZXJzYXRpb25zIGZvciBlYWNoIHN0YXRlLlxuICAgKiBAcmV0dXJucyB7VW5yZWFkQ291bnR9IHVucmVhZENvdW50XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0VW5yZWFkTmV3TW9kbWFpbENvbnZlcnNhdGlvbnNDb3VudCgpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IHtcbiAgICogLy8gIGFyY2hpdmVkOiAxLFxuICAgKiAvLyAgYXBwZWFsczogMSxcbiAgICogLy8gIGhpZ2hsaWdodGVkOiAwLFxuICAgKiAvLyAgbm90aWZpY2F0aW9uczogMCxcbiAgICogLy8gIGpvaW5fcmVxdWVzdHM6IDAsXG4gICAqIC8vICBuZXc6IDIsXG4gICAqIC8vICBpbnByb2dyZXNzOiA1LFxuICAgKiAvLyAgbW9kOiAxLFxuICAgKiAvLyB9XG4gICAqL1xuXG5cbiAgZ2V0VW5yZWFkTmV3TW9kbWFpbENvbnZlcnNhdGlvbnNDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogJ2FwaS9tb2QvY29udmVyc2F0aW9ucy91bnJlYWQvY291bnQnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IE1hcmsgTW9kbWFpbCBjb252ZXJzYXRpb25zIGFzIHJlYWQgZ2l2ZW4gdGhlIHN1YnJlZGRpdChzKSBhbmQgc3RhdGUuXG4gICAqIEBwYXJhbSB7U3VicmVkZGl0W118U3RyaW5nW119IHN1YnJlZGRpdHNcbiAgICogQHBhcmFtIHsoJ2FyY2hpdmVkJ3wnYXBwZWFscyd8J2hpZ2hsaWdodGVkJ3wnbm90aWZpY2F0aW9ucyd8J2pvaW5fcmVxdWVzdHMnfCduZXcnfCdpbnByb2dyZXNzJ3wnbW9kJ3wnYWxsJyl9IHN0YXRlIHNlbGVjdGVkIHN0YXRlIHRvIG1hcmsgYXMgcmVhZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0aW5nPE1vZG1haWxDb252ZXJzYXRpb24+Pn0gYSBMaXN0aW5nIG9mIE1vZG1haWxDb252ZXJzYXRpb25zIG1hcmtlZCBhcyByZWFkXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuYnVsa1JlYWROZXdNb2RtYWlsKFsnQXNrUmVkZGl0J10sICdhbGwnKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIE1vZG1haWxDb252ZXJzYXRpb24geyBpZDogJzc1aHh0JyB9LFxuICAgKiAvLyAgTW9kbWFpbENvbnZlcnNhdGlvbiB7IGlkOiAnNzVoeGcnIH1cbiAgICogLy8gXVxuICAgKlxuICAgKiByLmJ1bGtSZWFkTmV3TW9kbWFpbChbci5nZXRTdWJyZWRkaXQoJ0Fza1JlZGRpdCcpXSwgJ2FsbCcpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IExpc3RpbmcgW1xuICAgKiAvLyAgTW9kbWFpbENvbnZlcnNhdGlvbiB7IGlkOiAnNzVoeHQnIH0sXG4gICAqIC8vICBNb2RtYWlsQ29udmVyc2F0aW9uIHsgaWQ6ICc3NWh4ZycgfVxuICAgKiAvLyBdXG4gICAqL1xuXG5cbiAgYnVsa1JlYWROZXdNb2RtYWlsKHN1YnJlZGRpdHMsIHN0YXRlKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICB2YXIgc3VicmVkZGl0TmFtZXMgPSBzdWJyZWRkaXRzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyA/IHMucmVwbGFjZSgvXlxcLz9yXFwvLywgJycpIDogcy5kaXNwbGF5X25hbWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL21vZC9jb252ZXJzYXRpb25zL2J1bGsvcmVhZCcsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGVudGl0eTogc3VicmVkZGl0TmFtZXMuam9pbignLCcpLFxuICAgICAgICBzdGF0ZVxuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgcmV0dXJuIF90aGlzOS5fbmV3T2JqZWN0KCdMaXN0aW5nJywge1xuICAgICAgICBhZnRlcjogbnVsbCxcbiAgICAgICAgYmVmb3JlOiBudWxsLFxuICAgICAgICBjaGlsZHJlbjogcmVzLmNvbnZlcnNhdGlvbl9pZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczkuX25ld09iamVjdCgnTW9kbWFpbENvbnZlcnNhdGlvbicsIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyB0aGUgdXNlcidzIHNlbnQgbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gb3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3Rpbmcgb2YgdGhlIHVzZXIncyBzZW50IG1lc3NhZ2VzXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0U2VudE1lc3NhZ2VzKCkudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbXG4gICAqIC8vICBQcml2YXRlTWVzc2FnZSB7IGJvZHk6ICd5b3UgaGF2ZSBiZWVuIGFkZGVkIGFzIGFuIGFwcHJvdmVkIHN1Ym1pdHRlciB0byAuLi4nLCAuLi4gfSxcbiAgICogLy8gIFByaXZhdGVNZXNzYWdlIHsgYm9keTogJ3lvdSBoYXZlIGJlZW4gYmFubmVkIGZyb20gcG9zdGluZyB0byAuLi4nIC4uLiB9XG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRTZW50TWVzc2FnZXMoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogJ21lc3NhZ2Uvc2VudCcsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBNYXJrcyBhbGwgb2YgdGhlIGdpdmVuIG1lc3NhZ2VzIGFzIHJlYWQuXG4gICAqIEBwYXJhbSB7UHJpdmF0ZU1lc3NhZ2VbXXxTdHJpbmdbXX0gbWVzc2FnZXMgQW4gQXJyYXkgb2YgUHJpdmF0ZU1lc3NhZ2Ugb3IgQ29tbWVudCBvYmplY3RzLiBDYW4gYWxzbyBjb250YWluIHN0cmluZ3NcbiAgIHJlcHJlc2VudGluZyBtZXNzYWdlIG9yIGNvbW1lbnQgSURzLiBJZiBzdHJpbmdzIGFyZSBwcm92aWRlZCwgdGhleSBhcmUgYXNzdW1lZCB0byByZXByZXNlbnQgUHJpdmF0ZU1lc3NhZ2VzIHVubGVzcyBhIGZ1bGxuYW1lXG4gICBwcmVmaXggc3VjaCBhcyBgdDFfYCBpcyBzcGVjaWZpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIubWFya01lc3NhZ2VzQXNSZWFkKFsnNTFzaHNkJywgJzUxc2h4diddKVxuICAgKlxuICAgKiAvLyBUbyByZWZlcmVuY2UgYSBjb21tZW50IGJ5IElELCBiZSBzdXJlIHRvIHVzZSB0aGUgYHQxX2AgcHJlZml4LCBvdGhlcndpc2Ugc25vb3dyYXAgd2lsbCBiZSB1bmFibGUgdG8gZGlzdGluZ3Vpc2ggdGhlXG4gICAqIC8vIGNvbW1lbnQgSUQgZnJvbSBhIFByaXZhdGVNZXNzYWdlIElELlxuICAgKiByLm1hcmtNZXNzYWdlc0FzUmVhZChbJ3Q1XzUxc2hzZCcsICd0MV9kM3poYjVrJ10pXG4gICAqXG4gICAqIC8vIEFsdGVybmF0aXZlbHksIGp1c3QgcGFzcyBpbiBhIGNvbW1lbnQgb2JqZWN0IGRpcmVjdGx5LlxuICAgKiByLm1hcmtNZXNzYWdlc0FzUmVhZChbci5nZXRNZXNzYWdlKCc1MXNoc2QnKSwgci5nZXRDb21tZW50KCdkM3poYjVrJyldKVxuICAgKi9cblxuXG4gIG1hcmtNZXNzYWdlc0FzUmVhZChtZXNzYWdlcykge1xuICAgIHZhciBtZXNzYWdlSWRzID0gbWVzc2FnZXMubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gKDAsIF9oZWxwZXJzLmFkZEZ1bGxuYW1lUHJlZml4KShtZXNzYWdlLCAndDRfJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3JlYWRfbWVzc2FnZScsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGlkOiBtZXNzYWdlSWRzLmpvaW4oJywnKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBNYXJrcyBhbGwgb2YgdGhlIGdpdmVuIG1lc3NhZ2VzIGFzIHVucmVhZC5cbiAgICogQHBhcmFtIHtQcml2YXRlTWVzc2FnZVtdfFN0cmluZ1tdfSBtZXNzYWdlcyBBbiBBcnJheSBvZiBQcml2YXRlTWVzc2FnZSBvciBDb21tZW50IG9iamVjdHMuIENhbiBhbHNvIGNvbnRhaW4gc3RyaW5nc1xuICAgcmVwcmVzZW50aW5nIG1lc3NhZ2UgSURzLiBJZiBzdHJpbmdzIGFyZSBwcm92aWRlZCwgdGhleSBhcmUgYXNzdW1lZCB0byByZXByZXNlbnQgUHJpdmF0ZU1lc3NhZ2VzIHVubGVzcyBhIGZ1bGxuYW1lIHByZWZpeCBzdWNoXG4gICBhcyBgdDFfYCBpcyBpbmNsdWRlZC5cbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdoZW4gdGhlIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5tYXJrTWVzc2FnZXNBc1VucmVhZChbJzUxc2hzZCcsICc1MXNoeHYnXSlcbiAgICpcbiAgICogLy8gVG8gcmVmZXJlbmNlIGEgY29tbWVudCBieSBJRCwgYmUgc3VyZSB0byB1c2UgdGhlIGB0MV9gIHByZWZpeCwgb3RoZXJ3aXNlIHNub293cmFwIHdpbGwgYmUgdW5hYmxlIHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAgKiAvLyBjb21tZW50IElEIGZyb20gYSBQcml2YXRlTWVzc2FnZSBJRC5cbiAgICogci5tYXJrTWVzc2FnZXNBc1VucmVhZChbJ3Q1XzUxc2hzZCcsICd0MV9kM3poYjVrJ10pXG4gICAqXG4gICAqIC8vIEFsdGVybmF0aXZlbHksIGp1c3QgcGFzcyBpbiBhIGNvbW1lbnQgb2JqZWN0IGRpcmVjdGx5LlxuICAgKiByLm1hcmtNZXNzYWdlc0FzUmVhZChbci5nZXRNZXNzYWdlKCc1MXNoc2QnKSwgci5nZXRDb21tZW50KCdkM3poYjVrJyldKVxuICAgKi9cblxuXG4gIG1hcmtNZXNzYWdlc0FzVW5yZWFkKG1lc3NhZ2VzKSB7XG4gICAgdmFyIG1lc3NhZ2VJZHMgPSBtZXNzYWdlcy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiAoMCwgX2hlbHBlcnMuYWRkRnVsbG5hbWVQcmVmaXgpKG1lc3NhZ2UsICd0NF8nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvdW5yZWFkX21lc3NhZ2UnLFxuICAgICAgZm9ybToge1xuICAgICAgICBpZDogbWVzc2FnZUlkcy5qb2luKCcsJylcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgTWFya3MgYWxsIG9mIHRoZSB1c2VyJ3MgbWVzc2FnZXMgYXMgcmVhZC5cbiAgICogQGRlc2MgKipOb3RlOioqIFRoZSByZWRkaXQuY29tIHNpdGUgaW1wb3NlcyBhIHJhdGVsaW1pdCBvZiBhcHByb3hpbWF0ZWx5IDEgcmVxdWVzdCBldmVyeSAxMCBtaW51dGVzIG9uIHRoaXMgZW5kcG9pbnQuXG4gICBGdXJ0aGVyIHJlcXVlc3RzIHdpbGwgY2F1c2UgdGhlIEFQSSB0byByZXR1cm4gYSA0MjkgZXJyb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIucmVhZEFsbE1lc3NhZ2VzKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAqICAgci5nZXRVbnJlYWRNZXNzYWdlcygpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIH0pXG4gICAqIC8vID0+IExpc3RpbmcgW11cbiAgICogLy8gKG1lc3NhZ2VzIG1hcmtlZCBhcyAncmVhZCcgb24gcmVkZGl0KVxuICAgKi9cblxuXG4gIHJlYWRBbGxNZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdCh7XG4gICAgICB1cmk6ICdhcGkvcmVhZF9hbGxfbWVzc2FnZXMnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IENvbXBvc2VzIGEgbmV3IHByaXZhdGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtSZWRkaXRVc2VyfFN1YnJlZGRpdHxzdHJpbmd9IG9wdGlvbnMudG8gVGhlIHJlY2lwaWVudCBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ViamVjdCBUaGUgbWVzc2FnZSBzdWJqZWN0ICgxMDAgY2hhcmFjdGVycyBtYXgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRleHQgVGhlIGJvZHkgb2YgdGhlIG1lc3NhZ2UsIGluIHJhdyBtYXJrZG93biB0ZXh0XG4gICAqIEBwYXJhbSB7U3VicmVkZGl0fHN0cmluZ30gW29wdGlvbnMuZnJvbVN1YnJlZGRpdF0gSWYgcHJvdmlkZWQsIHRoZSBtZXNzYWdlIGlzIHNlbnQgYXMgYSBtb2RtYWlsIGZyb20gdGhlIHNwZWNpZmllZFxuICAgc3VicmVkZGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FwdGNoYUlkZW5dIEEgY2FwdGNoYSBpZGVudGlmaWVyLiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIHRoZSBhdXRoZW50aWNhdGVkIGFjY291bnRcbiAgIHJlcXVpcmVzIGEgY2FwdGNoYSB0byBzdWJtaXQgcG9zdHMgYW5kIGNvbW1lbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY2FwdGNoYVJlc3BvbnNlXSBUaGUgcmVzcG9uc2UgdG8gdGhlIGNhcHRjaGEgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmNvbXBvc2VNZXNzYWdlKHtcbiAgICogICB0bzogJ2FjdHVhbGx5X2FuX2FhcmR2YXJrJyxcbiAgICogICBzdWJqZWN0OiBcIkhpLCBob3cncyBpdCBnb2luZz9cIixcbiAgICogICB0ZXh0OiAnTG9uZyB0aW1lIG5vIHNlZSdcbiAgICogfSlcbiAgICogLy8gKG1lc3NhZ2UgY3JlYXRlZCBvbiByZWRkaXQpXG4gICAqL1xuXG5cbiAgY29tcG9zZU1lc3NhZ2UoX3JlZjgpIHtcbiAgICB2YXIgY2FwdGNoYSA9IF9yZWY4LmNhcHRjaGEsXG4gICAgICAgIGZyb21fc3VicmVkZGl0ID0gX3JlZjguZnJvbV9zdWJyZWRkaXQsXG4gICAgICAgIF9yZWY4JGZyb21TdWJyZWRkaXQgPSBfcmVmOC5mcm9tU3VicmVkZGl0LFxuICAgICAgICBmcm9tU3VicmVkZGl0ID0gX3JlZjgkZnJvbVN1YnJlZGRpdCA9PT0gdm9pZCAwID8gZnJvbV9zdWJyZWRkaXQgOiBfcmVmOCRmcm9tU3VicmVkZGl0LFxuICAgICAgICBjYXB0Y2hhX2lkZW4gPSBfcmVmOC5jYXB0Y2hhX2lkZW4sXG4gICAgICAgIF9yZWY4JGNhcHRjaGFJZGVuID0gX3JlZjguY2FwdGNoYUlkZW4sXG4gICAgICAgIGNhcHRjaGFJZGVuID0gX3JlZjgkY2FwdGNoYUlkZW4gPT09IHZvaWQgMCA/IGNhcHRjaGFfaWRlbiA6IF9yZWY4JGNhcHRjaGFJZGVuLFxuICAgICAgICBzdWJqZWN0ID0gX3JlZjguc3ViamVjdCxcbiAgICAgICAgdGV4dCA9IF9yZWY4LnRleHQsXG4gICAgICAgIHRvID0gX3JlZjgudG87XG4gICAgdmFyIHBhcnNlZFRvID0gdG87XG4gICAgdmFyIHBhcnNlZEZyb21TciA9IGZyb21TdWJyZWRkaXQ7XG5cbiAgICBpZiAodG8gaW5zdGFuY2VvZiBzbm9vd3JhcC5vYmplY3RzLlJlZGRpdFVzZXIpIHtcbiAgICAgIHBhcnNlZFRvID0gdG8ubmFtZTtcbiAgICB9IGVsc2UgaWYgKHRvIGluc3RhbmNlb2Ygc25vb3dyYXAub2JqZWN0cy5TdWJyZWRkaXQpIHtcbiAgICAgIHBhcnNlZFRvID0gXCIvci9cIi5jb25jYXQodG8uZGlzcGxheV9uYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZnJvbVN1YnJlZGRpdCBpbnN0YW5jZW9mIHNub293cmFwLm9iamVjdHMuU3VicmVkZGl0KSB7XG4gICAgICBwYXJzZWRGcm9tU3IgPSBmcm9tU3VicmVkZGl0LmRpc3BsYXlfbmFtZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmcm9tU3VicmVkZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyc2VkRnJvbVNyID0gZnJvbVN1YnJlZGRpdC5yZXBsYWNlKC9eXFwvP3JcXC8vLCAnJyk7IC8vIENvbnZlcnQgJy9yL3N1YnJlZGRpdF9uYW1lJyB0byAnc3VicmVkZGl0X25hbWUnXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL2NvbXBvc2UnLFxuICAgICAgZm9ybToge1xuICAgICAgICBhcGlfdHlwZSxcbiAgICAgICAgY2FwdGNoYSxcbiAgICAgICAgaWRlbjogY2FwdGNoYUlkZW4sXG4gICAgICAgIGZyb21fc3I6IHBhcnNlZEZyb21TcixcbiAgICAgICAgc3ViamVjdCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdG86IHBhcnNlZFRvXG4gICAgICB9XG4gICAgfSkudGFwKCgwLCBfaGVscGVycy5oYW5kbGVKc29uRXJyb3JzKSh0aGlzKSkucmV0dXJuKHt9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2YgYWxsIG9hdXRoIHNjb3BlcyBzdXBwb3J0ZWQgYnkgdGhlIHJlZGRpdCBBUEkuXG4gICAqIEBkZXNjICoqTm90ZSoqOiBUaGlzIGxpc3RzIGV2ZXJ5IHNpbmdsZSBvYXV0aCBzY29wZS4gVG8gZ2V0IHRoZSBzY29wZSBvZiB0aGlzIHJlcXVlc3RlciwgdXNlIHRoZSBgc2NvcGVgIHByb3BlcnR5IGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBbiBvYmplY3QgY29udGFpbmluZyBvYXV0aCBzY29wZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0T2F1dGhTY29wZUxpc3QoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiB7XG4gICAqIC8vICBjcmVkZGl0czoge1xuICAgKiAvLyAgICBkZXNjcmlwdGlvbjogJ1NwZW5kIG15IHJlZGRpdCBnb2xkIGNyZWRkaXRzIG9uIGdpdmluZyBnb2xkIHRvIG90aGVyIHVzZXJzLicsXG4gICAqIC8vICAgIGlkOiAnY3JlZGRpdHMnLFxuICAgKiAvLyAgICBuYW1lOiAnU3BlbmQgcmVkZGl0IGdvbGQgY3JlZGRpdHMnXG4gICAqIC8vICB9LFxuICAgKiAvLyAgbW9kY29udHJpYnV0b3JzOiB7XG4gICAqIC8vICAgIGRlc2NyaXB0aW9uOiAnQWRkL3JlbW92ZSB1c2VycyB0byBhcHByb3ZlZCBzdWJtaXR0ZXIgbGlzdHMgYW5kIGJhbi91bmJhbiBvciBtdXRlL3VubXV0ZSB1c2VycyBmcm9tIC4uLicsXG4gICAqIC8vICAgIGlkOiAnbW9kY29udHJpYnV0b3JzJyxcbiAgICogLy8gICAgbmFtZTogJ0FwcHJvdmUgc3VibWl0dGVycyBhbmQgYmFuIHVzZXJzJ1xuICAgKiAvLyAgfSxcbiAgICogLy8gIC4uLlxuICAgKiAvLyB9XG4gICAqL1xuXG5cbiAgZ2V0T2F1dGhTY29wZUxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6ICdhcGkvdjEvc2NvcGVzJ1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDb25kdWN0cyBhIHNlYXJjaCBvZiByZWRkaXQgc3VibWlzc2lvbnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFNlYXJjaCBvcHRpb25zLiBDYW4gYWxzbyBjb250YWluIG9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucXVlcnkgVGhlIHNlYXJjaCBxdWVyeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGltZV0gRGVzY3JpYmVzIHRoZSB0aW1lc3BhbiB0aGF0IHBvc3RzIHNob3VsZCBiZSByZXRyaWV2ZWQgZnJvbS4gT25lIG9mXG4gICBgaG91ciwgZGF5LCB3ZWVrLCBtb250aCwgeWVhciwgYWxsYFxuICAgKiBAcGFyYW0ge1N1YnJlZGRpdHxzdHJpbmd9IFtvcHRpb25zLnN1YnJlZGRpdF0gVGhlIHN1YnJlZGRpdCB0byBjb25kdWN0IHRoZSBzZWFyY2ggb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzdHJpY3RTcj10cnVlXSBSZXN0cmljdHMgc2VhcmNoIHJlc3VsdHMgdG8gdGhlIGdpdmVuIHN1YnJlZGRpdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc29ydF0gRGV0ZXJtaW5lcyBob3cgdGhlIHJlc3VsdHMgc2hvdWxkIGJlIHNvcnRlZC4gT25lIG9mIGByZWxldmFuY2UsIGhvdCwgdG9wLCBuZXcsIGNvbW1lbnRzYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3ludGF4PSdwbGFpbiddIFNwZWNpZmllcyBhIHN5bnRheCBmb3IgdGhlIHNlYXJjaC4gT25lIG9mIGBjbG91ZHNlYXJjaCwgbHVjZW5lLCBwbGFpbmBcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIHRoZSBzZWFyY2ggcmVzdWx0cy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5zZWFyY2goe1xuICAgKiAgIHF1ZXJ5OiAnQ3V0ZSBraXR0ZW5zJyxcbiAgICogICBzdWJyZWRkaXQ6ICdhd3cnLFxuICAgKiAgIHNvcnQ6ICd0b3AnXG4gICAqIH0pLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IExpc3RpbmcgW1xuICAgKiAvLyAgU3VibWlzc2lvbiB7IGRvbWFpbjogJ2kuaW1ndXIuY29tJywgYmFubmVkX2J5OiBudWxsLCAuLi4gfSxcbiAgICogLy8gIFN1Ym1pc3Npb24geyBkb21haW46ICdpbWd1ci5jb20nLCBiYW5uZWRfYnk6IG51bGwsIC4uLiB9LFxuICAgKiAvLyAgLi4uXG4gICAqIC8vIF1cbiAgICovXG5cblxuICBzZWFyY2gob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnN1YnJlZGRpdCBpbnN0YW5jZW9mIHNub293cmFwLm9iamVjdHMuU3VicmVkZGl0KSB7XG4gICAgICBvcHRpb25zLnN1YnJlZGRpdCA9IG9wdGlvbnMuc3VicmVkZGl0LmRpc3BsYXlfbmFtZTtcbiAgICB9XG5cbiAgICAoMCwgX2xvZGFzaC5kZWZhdWx0cykob3B0aW9ucywge1xuICAgICAgcmVzdHJpY3RTcjogdHJ1ZSxcbiAgICAgIHN5bnRheDogJ3BsYWluJ1xuICAgIH0pO1xuICAgIHZhciBwYXJzZWRRdWVyeSA9ICgwLCBfbG9kYXNoLm9taXQpKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIHQ6IG9wdGlvbnMudGltZSxcbiAgICAgIHE6IG9wdGlvbnMucXVlcnksXG4gICAgICByZXN0cmljdF9zcjogb3B0aW9ucy5yZXN0cmljdFNyXG4gICAgfSksIFsndGltZScsICdxdWVyeSddKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6IFwiXCIuY29uY2F0KG9wdGlvbnMuc3VicmVkZGl0ID8gXCJyL1wiLmNvbmNhdChvcHRpb25zLnN1YnJlZGRpdCwgXCIvXCIpIDogJycsIFwic2VhcmNoXCIpLFxuICAgICAgcXM6IHBhcnNlZFF1ZXJ5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFNlYXJjaGVzIGZvciBzdWJyZWRkaXRzIGdpdmVuIGEgcXVlcnkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnF1ZXJ5IEEgc2VhcmNoIHF1ZXJ5ICg1MCBjaGFyYWN0ZXJzIG1heClcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5leGFjdD1mYWxzZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSByZXN1bHRzIHNob3VsZGJlIGxpbWl0ZWQgdG8gZXhhY3QgbWF0Y2hlcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbmNsdWRlTnNmdz10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHJlc3VsdHMgc2hvdWxkIGluY2x1ZGUgTlNGVyBzdWJyZWRkaXRzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQW4gQXJyYXkgY29udGFpbmluZyBzdWJyZWRkaXQgbmFtZXNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5zZWFyY2hTdWJyZWRkaXROYW1lcyh7cXVlcnk6ICdwcm9ncmFtbWluZyd9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBbXG4gICAqIC8vICAncHJvZ3JhbW1pbmcnLFxuICAgKiAvLyAgJ3Byb2dyYW1taW5nY2lyY2xlamVyaycsXG4gICAqIC8vICAncHJvZ3JhbW1pbmdob3Jyb3InLFxuICAgKiAvLyAgLi4uXG4gICAqIC8vIF1cbiAgICovXG5cblxuICBzZWFyY2hTdWJyZWRkaXROYW1lcyhfcmVmOSkge1xuICAgIHZhciBfcmVmOSRleGFjdCA9IF9yZWY5LmV4YWN0LFxuICAgICAgICBleGFjdCA9IF9yZWY5JGV4YWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY5JGV4YWN0LFxuICAgICAgICBfcmVmOSRpbmNsdWRlX25zZncgPSBfcmVmOS5pbmNsdWRlX25zZncsXG4gICAgICAgIGluY2x1ZGVfbnNmdyA9IF9yZWY5JGluY2x1ZGVfbnNmdyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY5JGluY2x1ZGVfbnNmdyxcbiAgICAgICAgX3JlZjkkaW5jbHVkZU5zZncgPSBfcmVmOS5pbmNsdWRlTnNmdyxcbiAgICAgICAgaW5jbHVkZU5zZncgPSBfcmVmOSRpbmNsdWRlTnNmdyA9PT0gdm9pZCAwID8gaW5jbHVkZV9uc2Z3IDogX3JlZjkkaW5jbHVkZU5zZncsXG4gICAgICAgIHF1ZXJ5ID0gX3JlZjkucXVlcnk7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3Qoe1xuICAgICAgdXJpOiAnYXBpL3NlYXJjaF9yZWRkaXRfbmFtZXMnLFxuICAgICAgcXM6IHtcbiAgICAgICAgZXhhY3QsXG4gICAgICAgIGluY2x1ZGVfb3Zlcl8xODogaW5jbHVkZU5zZncsXG4gICAgICAgIHF1ZXJ5XG4gICAgICB9XG4gICAgfSkuZ2V0KCduYW1lcycpO1xuICB9XG5cbiAgX2NyZWF0ZU9yRWRpdFN1YnJlZGRpdChfcmVmMTApIHtcbiAgICB2YXIgX3JlZjEwJGFsbG93X2ltYWdlcyA9IF9yZWYxMC5hbGxvd19pbWFnZXMsXG4gICAgICAgIGFsbG93X2ltYWdlcyA9IF9yZWYxMCRhbGxvd19pbWFnZXMgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMTAkYWxsb3dfaW1hZ2VzLFxuICAgICAgICBfcmVmMTAkYWxsb3dfdG9wID0gX3JlZjEwLmFsbG93X3RvcCxcbiAgICAgICAgYWxsb3dfdG9wID0gX3JlZjEwJGFsbG93X3RvcCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYxMCRhbGxvd190b3AsXG4gICAgICAgIGNhcHRjaGEgPSBfcmVmMTAuY2FwdGNoYSxcbiAgICAgICAgY2FwdGNoYV9pZGVuID0gX3JlZjEwLmNhcHRjaGFfaWRlbixcbiAgICAgICAgX3JlZjEwJGNvbGxhcHNlX2RlbGV0ID0gX3JlZjEwLmNvbGxhcHNlX2RlbGV0ZWRfY29tbWVudHMsXG4gICAgICAgIGNvbGxhcHNlX2RlbGV0ZWRfY29tbWVudHMgPSBfcmVmMTAkY29sbGFwc2VfZGVsZXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjEwJGNvbGxhcHNlX2RlbGV0LFxuICAgICAgICBfcmVmMTAkY29tbWVudF9zY29yZV8gPSBfcmVmMTAuY29tbWVudF9zY29yZV9oaWRlX21pbnMsXG4gICAgICAgIGNvbW1lbnRfc2NvcmVfaGlkZV9taW5zID0gX3JlZjEwJGNvbW1lbnRfc2NvcmVfID09PSB2b2lkIDAgPyAwIDogX3JlZjEwJGNvbW1lbnRfc2NvcmVfLFxuICAgICAgICBkZXNjcmlwdGlvbiA9IF9yZWYxMC5kZXNjcmlwdGlvbixcbiAgICAgICAgX3JlZjEwJGV4Y2x1ZGVfYmFubmVkID0gX3JlZjEwLmV4Y2x1ZGVfYmFubmVkX21vZHF1ZXVlLFxuICAgICAgICBleGNsdWRlX2Jhbm5lZF9tb2RxdWV1ZSA9IF9yZWYxMCRleGNsdWRlX2Jhbm5lZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTAkZXhjbHVkZV9iYW5uZWQsXG4gICAgICAgIGhlYWRlcl90aXRsZSA9IF9yZWYxMFsnaGVhZGVyLXRpdGxlJ10sXG4gICAgICAgIF9yZWYxMCRoaWRlX2FkcyA9IF9yZWYxMC5oaWRlX2FkcyxcbiAgICAgICAgaGlkZV9hZHMgPSBfcmVmMTAkaGlkZV9hZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjEwJGhpZGVfYWRzLFxuICAgICAgICBfcmVmMTAkbGFuZyA9IF9yZWYxMC5sYW5nLFxuICAgICAgICBsYW5nID0gX3JlZjEwJGxhbmcgPT09IHZvaWQgMCA/ICdlbicgOiBfcmVmMTAkbGFuZyxcbiAgICAgICAgX3JlZjEwJGxpbmtfdHlwZSA9IF9yZWYxMC5saW5rX3R5cGUsXG4gICAgICAgIGxpbmtfdHlwZSA9IF9yZWYxMCRsaW5rX3R5cGUgPT09IHZvaWQgMCA/ICdhbnknIDogX3JlZjEwJGxpbmtfdHlwZSxcbiAgICAgICAgbmFtZSA9IF9yZWYxMC5uYW1lLFxuICAgICAgICBfcmVmMTAkb3Zlcl8gPSBfcmVmMTAub3Zlcl8xOCxcbiAgICAgICAgb3Zlcl8xOCA9IF9yZWYxMCRvdmVyXyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTAkb3Zlcl8sXG4gICAgICAgIHB1YmxpY19kZXNjcmlwdGlvbiA9IF9yZWYxMC5wdWJsaWNfZGVzY3JpcHRpb24sXG4gICAgICAgIF9yZWYxMCRwdWJsaWNfdHJhZmZpYyA9IF9yZWYxMC5wdWJsaWNfdHJhZmZpYyxcbiAgICAgICAgcHVibGljX3RyYWZmaWMgPSBfcmVmMTAkcHVibGljX3RyYWZmaWMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjEwJHB1YmxpY190cmFmZmljLFxuICAgICAgICBfcmVmMTAkc2hvd19tZWRpYSA9IF9yZWYxMC5zaG93X21lZGlhLFxuICAgICAgICBzaG93X21lZGlhID0gX3JlZjEwJHNob3dfbWVkaWEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjEwJHNob3dfbWVkaWEsXG4gICAgICAgIF9yZWYxMCRzaG93X21lZGlhX3ByZSA9IF9yZWYxMC5zaG93X21lZGlhX3ByZXZpZXcsXG4gICAgICAgIHNob3dfbWVkaWFfcHJldmlldyA9IF9yZWYxMCRzaG93X21lZGlhX3ByZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYxMCRzaG93X21lZGlhX3ByZSxcbiAgICAgICAgX3JlZjEwJHNwYW1fY29tbWVudHMgPSBfcmVmMTAuc3BhbV9jb21tZW50cyxcbiAgICAgICAgc3BhbV9jb21tZW50cyA9IF9yZWYxMCRzcGFtX2NvbW1lbnRzID09PSB2b2lkIDAgPyAnaGlnaCcgOiBfcmVmMTAkc3BhbV9jb21tZW50cyxcbiAgICAgICAgX3JlZjEwJHNwYW1fbGlua3MgPSBfcmVmMTAuc3BhbV9saW5rcyxcbiAgICAgICAgc3BhbV9saW5rcyA9IF9yZWYxMCRzcGFtX2xpbmtzID09PSB2b2lkIDAgPyAnaGlnaCcgOiBfcmVmMTAkc3BhbV9saW5rcyxcbiAgICAgICAgX3JlZjEwJHNwYW1fc2VsZnBvc3RzID0gX3JlZjEwLnNwYW1fc2VsZnBvc3RzLFxuICAgICAgICBzcGFtX3NlbGZwb3N0cyA9IF9yZWYxMCRzcGFtX3NlbGZwb3N0cyA9PT0gdm9pZCAwID8gJ2hpZ2gnIDogX3JlZjEwJHNwYW1fc2VsZnBvc3RzLFxuICAgICAgICBfcmVmMTAkc3BvaWxlcnNfZW5hYmwgPSBfcmVmMTAuc3BvaWxlcnNfZW5hYmxlZCxcbiAgICAgICAgc3BvaWxlcnNfZW5hYmxlZCA9IF9yZWYxMCRzcG9pbGVyc19lbmFibCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTAkc3BvaWxlcnNfZW5hYmwsXG4gICAgICAgIHNyID0gX3JlZjEwLnNyLFxuICAgICAgICBfcmVmMTAkc3VibWl0X2xpbmtfbGEgPSBfcmVmMTAuc3VibWl0X2xpbmtfbGFiZWwsXG4gICAgICAgIHN1Ym1pdF9saW5rX2xhYmVsID0gX3JlZjEwJHN1Ym1pdF9saW5rX2xhID09PSB2b2lkIDAgPyAnJyA6IF9yZWYxMCRzdWJtaXRfbGlua19sYSxcbiAgICAgICAgX3JlZjEwJHN1Ym1pdF90ZXh0X2xhID0gX3JlZjEwLnN1Ym1pdF90ZXh0X2xhYmVsLFxuICAgICAgICBzdWJtaXRfdGV4dF9sYWJlbCA9IF9yZWYxMCRzdWJtaXRfdGV4dF9sYSA9PT0gdm9pZCAwID8gJycgOiBfcmVmMTAkc3VibWl0X3RleHRfbGEsXG4gICAgICAgIF9yZWYxMCRzdWJtaXRfdGV4dCA9IF9yZWYxMC5zdWJtaXRfdGV4dCxcbiAgICAgICAgc3VibWl0X3RleHQgPSBfcmVmMTAkc3VibWl0X3RleHQgPT09IHZvaWQgMCA/ICcnIDogX3JlZjEwJHN1Ym1pdF90ZXh0LFxuICAgICAgICBfcmVmMTAkc3VnZ2VzdGVkX2NvbW0gPSBfcmVmMTAuc3VnZ2VzdGVkX2NvbW1lbnRfc29ydCxcbiAgICAgICAgc3VnZ2VzdGVkX2NvbW1lbnRfc29ydCA9IF9yZWYxMCRzdWdnZXN0ZWRfY29tbSA9PT0gdm9pZCAwID8gJ2NvbmZpZGVuY2UnIDogX3JlZjEwJHN1Z2dlc3RlZF9jb21tLFxuICAgICAgICB0aXRsZSA9IF9yZWYxMC50aXRsZSxcbiAgICAgICAgX3JlZjEwJHR5cGUgPSBfcmVmMTAudHlwZSxcbiAgICAgICAgdHlwZSA9IF9yZWYxMCR0eXBlID09PSB2b2lkIDAgPyAncHVibGljJyA6IF9yZWYxMCR0eXBlLFxuICAgICAgICB3aWtpX2VkaXRfYWdlID0gX3JlZjEwLndpa2lfZWRpdF9hZ2UsXG4gICAgICAgIHdpa2lfZWRpdF9rYXJtYSA9IF9yZWYxMC53aWtpX2VkaXRfa2FybWEsXG4gICAgICAgIF9yZWYxMCR3aWtpbW9kZSA9IF9yZWYxMC53aWtpbW9kZSxcbiAgICAgICAgd2lraW1vZGUgPSBfcmVmMTAkd2lraW1vZGUgPT09IHZvaWQgMCA/ICdtb2Rvbmx5JyA6IF9yZWYxMCR3aWtpbW9kZSxcbiAgICAgICAgb3RoZXJLZXlzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYxMCwgW1wiYWxsb3dfaW1hZ2VzXCIsIFwiYWxsb3dfdG9wXCIsIFwiY2FwdGNoYVwiLCBcImNhcHRjaGFfaWRlblwiLCBcImNvbGxhcHNlX2RlbGV0ZWRfY29tbWVudHNcIiwgXCJjb21tZW50X3Njb3JlX2hpZGVfbWluc1wiLCBcImRlc2NyaXB0aW9uXCIsIFwiZXhjbHVkZV9iYW5uZWRfbW9kcXVldWVcIiwgXCJoZWFkZXItdGl0bGVcIiwgXCJoaWRlX2Fkc1wiLCBcImxhbmdcIiwgXCJsaW5rX3R5cGVcIiwgXCJuYW1lXCIsIFwib3Zlcl8xOFwiLCBcInB1YmxpY19kZXNjcmlwdGlvblwiLCBcInB1YmxpY190cmFmZmljXCIsIFwic2hvd19tZWRpYVwiLCBcInNob3dfbWVkaWFfcHJldmlld1wiLCBcInNwYW1fY29tbWVudHNcIiwgXCJzcGFtX2xpbmtzXCIsIFwic3BhbV9zZWxmcG9zdHNcIiwgXCJzcG9pbGVyc19lbmFibGVkXCIsIFwic3JcIiwgXCJzdWJtaXRfbGlua19sYWJlbFwiLCBcInN1Ym1pdF90ZXh0X2xhYmVsXCIsIFwic3VibWl0X3RleHRcIiwgXCJzdWdnZXN0ZWRfY29tbWVudF9zb3J0XCIsIFwidGl0bGVcIiwgXCJ0eXBlXCIsIFwid2lraV9lZGl0X2FnZVwiLCBcIndpa2lfZWRpdF9rYXJtYVwiLCBcIndpa2ltb2RlXCJdKTtcblxuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9zaXRlX2FkbWluJyxcbiAgICAgIGZvcm06IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBhbGxvd19pbWFnZXMsXG4gICAgICAgIGFsbG93X3RvcCxcbiAgICAgICAgYXBpX3R5cGUsXG4gICAgICAgIGNhcHRjaGEsXG4gICAgICAgIGNvbGxhcHNlX2RlbGV0ZWRfY29tbWVudHMsXG4gICAgICAgIGNvbW1lbnRfc2NvcmVfaGlkZV9taW5zLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgZXhjbHVkZV9iYW5uZWRfbW9kcXVldWUsXG4gICAgICAgICdoZWFkZXItdGl0bGUnOiBoZWFkZXJfdGl0bGUsXG4gICAgICAgIGhpZGVfYWRzLFxuICAgICAgICBpZGVuOiBjYXB0Y2hhX2lkZW4sXG4gICAgICAgIGxhbmcsXG4gICAgICAgIGxpbmtfdHlwZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3Zlcl8xOCxcbiAgICAgICAgcHVibGljX2Rlc2NyaXB0aW9uLFxuICAgICAgICBwdWJsaWNfdHJhZmZpYyxcbiAgICAgICAgc2hvd19tZWRpYSxcbiAgICAgICAgc2hvd19tZWRpYV9wcmV2aWV3LFxuICAgICAgICBzcGFtX2NvbW1lbnRzLFxuICAgICAgICBzcGFtX2xpbmtzLFxuICAgICAgICBzcGFtX3NlbGZwb3N0cyxcbiAgICAgICAgc3BvaWxlcnNfZW5hYmxlZCxcbiAgICAgICAgc3IsXG4gICAgICAgIHN1Ym1pdF9saW5rX2xhYmVsLFxuICAgICAgICBzdWJtaXRfdGV4dCxcbiAgICAgICAgc3VibWl0X3RleHRfbGFiZWwsXG4gICAgICAgIHN1Z2dlc3RlZF9jb21tZW50X3NvcnQsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICB0eXBlLFxuICAgICAgICB3aWtpX2VkaXRfYWdlLFxuICAgICAgICB3aWtpX2VkaXRfa2FybWEsXG4gICAgICAgIHdpa2ltb2RlXG4gICAgICB9LCBvdGhlcktleXMpXG4gICAgfSkudGhlbigoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcy5nZXRTdWJyZWRkaXQobmFtZSB8fCBzcikpKTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIG5ldyBzdWJyZWRkaXQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBzdWJyZWRkaXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgVGhlIHRleHQgdGhhdCBzaG91bGQgYXBwZWFyIGluIHRoZSBoZWFkZXIgb2YgdGhlIHN1YnJlZGRpdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5wdWJsaWNfZGVzY3JpcHRpb24gVGhlIHRleHQgdGhhdCBhcHBlYXJzIHdpdGggdGhpcyBzdWJyZWRkaXQgb24gdGhlIHNlYXJjaCBwYWdlLCBvciBvbiB0aGVcbiAgIGJsb2NrZWQtYWNjZXNzIHBhZ2UgaWYgdGhpcyBzdWJyZWRkaXQgaXMgcHJpdmF0ZS4gKDUwMCBjaGFyYWN0ZXJzIG1heClcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZGVzY3JpcHRpb24gVGhlIHNpZGViYXIgdGV4dCBmb3IgdGhlIHN1YnJlZGRpdC4gKDUxMjAgY2hhcmFjdGVycyBtYXgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdWJtaXRfdGV4dD0nJ10gVGhlIHRleHQgdG8gc2hvdyBiZWxvdyB0aGUgc3VibWlzc2lvbiBwYWdlICgxMDI0IGNoYXJhY3RlcnMgbWF4KVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhpZGVfYWRzPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgYWRzIHNob3VsZCBiZSBoaWRkZW4gb24gdGhpcyBzdWJyZWRkaXQuIChUaGlzIGlzIG9ubHlcbiAgIGFsbG93ZWQgZm9yIGdvbGQtb25seSBzdWJyZWRkaXRzLilcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmc9J2VuJ10gVGhlIGxhbmd1YWdlIG9mIHRoZSBzdWJyZWRkaXQgKHJlcHJlc2VudGVkIGFzIGFuIElFVEYgbGFuZ3VhZ2UgdGFnKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZT0ncHVibGljJ10gRGV0ZXJtaW5lcyB3aG8gc2hvdWxkIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBzdWJyZWRkaXQuIFRoaXMgc2hvdWxkIGJlIG9uZSBvZlxuICAgYHB1YmxpYywgcHJpdmF0ZSwgcmVzdHJpY3RlZCwgZ29sZF9yZXN0cmljdGVkLCBnb2xkX29ubHksIGFyY2hpdmVkLCBlbXBsb3llZXNfb25seWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5saW5rX3R5cGU9J2FueSddIERldGVybWluZXMgd2hhdCB0eXBlcyBvZiBzdWJtaXNzaW9ucyBhcmUgYWxsb3dlZCBvbiB0aGUgc3VicmVkZGl0LiBUaGlzIHNob3VsZFxuICAgYmUgb25lIG9mIGBhbnksIGxpbmssIHNlbGZgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3VibWl0X2xpbmtfbGFiZWw9dW5kZWZpbmVkXSBDdXN0b20gdGV4dCB0byBkaXNwbGF5IG9uIHRoZSBidXR0b24gdGhhdCBzdWJtaXRzIGEgbGluay4gSWZcbiAgIHRoaXMgaXMgb21pdHRlZCwgdGhlIGRlZmF1bHQgdGV4dCB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN1Ym1pdF90ZXh0X2xhYmVsPXVuZGVmaW5lZF0gQ3VzdG9tIHRleHQgdG8gZGlzcGxheSBvbiB0aGUgYnV0dG9uIHRoYXQgc3VibWl0cyBhIHNlbGZwb3N0LiBJZlxuICAgdGhpcyBpcyBvbWl0dGVkLCB0aGUgZGVmYXVsdCB0ZXh0IHdpbGwgYmUgZGlzcGxheWVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud2lraW1vZGU9J21vZG9ubHknXSBEZXRlcm1pbmVzIHdobyBjYW4gZWRpdCB3aWtpIHBhZ2VzIG9uIHRoZSBzdWJyZWRkaXQuIFRoaXMgc2hvdWxkIGJlIG9uZSBvZlxuICAgYG1vZG9ubHksIGFueW9uZSwgZGlzYWJsZWRgLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lraV9lZGl0X2thcm1hPTBdIFRoZSBtaW5pbXVtIGFtb3VudCBvZiBzdWJyZWRkaXQga2FybWEgbmVlZGVkIGZvciBzb21lb25lIHRvIGVkaXQgdGhpc1xuICAgc3VicmVkZGl0J3Mgd2lraS4gKFRoaXMgaXMgb25seSByZWxldmFudCBpZiBgb3B0aW9ucy53aWtpbW9kZWAgaXMgc2V0IHRvIGBhbnlvbmVgLilcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpa2lfZWRpdF9hZ2U9MF0gVGhlIG1pbmltdW0gYWNjb3VudCBhZ2UgKGluIGRheXMpIG5lZWRlZCBmb3Igc29tZW9uZSB0byBlZGl0IHRoaXMgc3VicmVkZGl0J3NcbiAgIHdpa2kuIChUaGlzIGlzIG9ubHkgcmVsZXZhbnQgaWYgYG9wdGlvbnMud2lraW1vZGVgIGlzIHNldCB0byBgYW55b25lYC4pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcGFtX2xpbmtzPSdoaWdoJ10gVGhlIHNwYW0gZmlsdGVyIHN0cmVuZ3RoIGZvciBsaW5rcyBvbiB0aGlzIHN1YnJlZGRpdC4gVGhpcyBzaG91bGQgYmUgb25lIG9mXG4gICBgbG93LCBoaWdoLCBhbGxgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3BhbV9zZWxmcG9zdHM9J2hpZ2gnXSBUaGUgc3BhbSBmaWx0ZXIgc3RyZW5ndGggZm9yIHNlbGZwb3N0cyBvbiB0aGlzIHN1YnJlZGRpdC4gVGhpcyBzaG91bGQgYmVcbiAgIG9uZSBvZiBgbG93LCBoaWdoLCBhbGxgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3BhbV9jb21tZW50cz0naGlnaCddIFRoZSBzcGFtIGZpbHRlciBzdHJlbmd0aCBmb3IgY29tbWVudHMgb24gdGhpcyBzdWJyZWRkaXQuIFRoaXMgc2hvdWxkIGJlIG9uZVxuICAgb2YgYGxvdywgaGlnaCwgYWxsYC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vdmVyXzE4PWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBzdWJyZWRkaXQgc2hvdWxkIGJlIGNsYXNzaWZpZWQgYXMgTlNGV1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFsbG93X3RvcD10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5ldyBzdWJyZWRkaXQgc2hvdWxkIGJlIGFibGUgdG8gYXBwZWFyIGluIC9yL2FsbCBhbmRcbiAgIHRyZW5kaW5nIHN1YnJlZGRpdHNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zaG93X21lZGlhPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgaW1hZ2UgdGh1bWJuYWlscyBzaG91bGQgYmUgZW5hYmxlZCBvbiB0aGlzIHN1YnJlZGRpdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3dfbWVkaWFfcHJldmlldz10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgbWVkaWEgcHJldmlld3Mgc2hvdWxkIGJlIGV4cGFuZGVkIGJ5IGRlZmF1bHQgb24gdGhpc1xuICAgc3VicmVkZGl0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dfaW1hZ2VzPXRydWVdIERldGVybWluZXMgd2hldGhlciBpbWFnZSB1cGxvYWRzIGFuZCBsaW5rcyB0byBpbWFnZSBob3N0aW5nIHNpdGVzIHNob3VsZCBiZVxuICAgZW5hYmxlZCBvbiB0aGlzIHN1YnJlZGRpdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmV4Y2x1ZGVfYmFubmVkX21vZHF1ZXVlPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgcG9zdHMgYnkgc2l0ZS13aWRlIGJhbm5lZCB1c2VycyBzaG91bGQgYmVcbiAgIGV4Y2x1ZGVkIGZyb20gdGhlIG1vZHF1ZXVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnB1YmxpY190cmFmZmljPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIC9hYm91dC90cmFmZmljIHBhZ2UgZm9yIHRoaXMgc3VicmVkZGl0IHNob3VsZCBiZVxuICAgdmlld2FibGUgYnkgYW55b25lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbGxhcHNlX2RlbGV0ZWRfY29tbWVudHM9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciBkZWxldGVkIGFuZCByZW1vdmVkIGNvbW1lbnRzIHNob3VsZCBiZVxuICAgY29sbGFwc2VkIGJ5IGRlZmF1bHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN1Z2dlc3RlZF9jb21tZW50X3NvcnQ9dW5kZWZpbmVkXSBUaGUgc3VnZ2VzdGVkIGNvbW1lbnQgc29ydCBmb3IgdGhlIHN1YnJlZGRpdC4gVGhpcyBzaG91bGQgYmVcbiAgIG9uZSBvZiBgY29uZmlkZW5jZSwgdG9wLCBuZXcsIGNvbnRyb3ZlcnNpYWwsIG9sZCwgcmFuZG9tLCBxYWAuSWYgbGVmdCBibGFuaywgdGhlcmUgd2lsbCBiZSBubyBzdWdnZXN0ZWQgc29ydCxcbiAgIHdoaWNoIG1lYW5zIHRoYXQgdXNlcnMgd2lsbCBzZWUgdGhlIHNvcnQgbWV0aG9kIHRoYXQgaXMgc2V0IGluIHRoZWlyIG93biBwcmVmZXJlbmNlcyAodXN1YWxseSBgY29uZmlkZW5jZWAuKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNwb2lsZXJzX2VuYWJsZWQ9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciB1c2VycyBjYW4gbWFyayB0aGVpciBwb3N0cyBhcyBzcG9pbGVyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIGZvciB0aGUgbmV3bHktY3JlYXRlZCBzdWJyZWRkaXQgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmNyZWF0ZVN1YnJlZGRpdCh7XG4gICAqICAgbmFtZTogJ3Nub293cmFwX3Rlc3RpbmcyJyxcbiAgICogICB0aXRsZTogJ3Nub293cmFwIHRlc3Rpbmc6IHRoZSBzZXF1ZWwnLFxuICAgKiAgIHB1YmxpY19kZXNjcmlwdGlvbjogJ3RoYW5rcyBmb3IgcmVhZGluZyB0aGUgc25vb3dyYXAgZG9jcyEnLFxuICAgKiAgIGRlc2NyaXB0aW9uOiAnVGhpcyB0ZXh0IHdpbGwgZ28gb24gdGhlIHNpZGViYXInLFxuICAgKiAgIHR5cGU6ICdwcml2YXRlJ1xuICAgKiB9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdzbm9vd3JhcF90ZXN0aW5nMicgfVxuICAgKiAvLyAoL3Ivc25vb3dyYXBfdGVzdGluZzIgY3JlYXRlZCBvbiByZWRkaXQpXG4gICAqL1xuXG5cbiAgY3JlYXRlU3VicmVkZGl0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlT3JFZGl0U3VicmVkZGl0KG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBTZWFyY2hlcyBzdWJyZWRkaXRzIGJ5IHRvcGljLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5xdWVyeSBUaGUgc2VhcmNoIHF1ZXJ5LiAoNTAgY2hhcmFjdGVycyBtYXgpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBbiBBcnJheSBvZiBzdWJyZWRkaXQgb2JqZWN0cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBzZWFyY2ggcmVzdWx0c1xuICAgKiBAZGVwcmVjYXRlZCBSZWRkaXQgbm8gbG9uZ2VyIHByb3ZpZGVzIHRoZSBjb3JyZXNwb25kaW5nIEFQSSBlbmRwb2ludC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5zZWFyY2hTdWJyZWRkaXRUb3BpY3Moe3F1ZXJ5OiAnbW92aWVzJ30pLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IFtcbiAgICogLy8gIFN1YnJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ3RpcG9mbXl0b25ndWUnIH0sXG4gICAqIC8vICBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdyZW1vdmUnIH0sXG4gICAqIC8vICBTdWJyZWRkaXQgeyBkaXNwbGF5X25hbWU6ICdob3Jyb3InIH0sXG4gICAqIC8vICAuLi5cbiAgICogLy8gXVxuICAgKi9cblxuXG4gIHNlYXJjaFN1YnJlZGRpdFRvcGljcyhfcmVmMTEpIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICB2YXIgcXVlcnkgPSBfcmVmMTEucXVlcnk7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh7XG4gICAgICB1cmk6ICdhcGkvc3VicmVkZGl0c19ieV90b3BpYycsXG4gICAgICBxczoge1xuICAgICAgICBxdWVyeVxuICAgICAgfVxuICAgIH0pLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gX3RoaXMxMC5nZXRTdWJyZWRkaXQocmVzdWx0Lm5hbWUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiBzdWJyZWRkaXRzIHRoYXQgdGhlIGN1cnJlbnRseS1hdXRoZW50aWNhdGVkIHVzZXIgaXMgc3Vic2NyaWJlZCB0by5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIFN1YnJlZGRpdHNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRTdWJzY3JpcHRpb25zKHtsaW1pdDogMn0pLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IExpc3RpbmcgW1xuICAgKiAvLyAgU3VicmVkZGl0IHtcbiAgICogLy8gICAgZGlzcGxheV9uYW1lOiAnZ2FkZ2V0cycsXG4gICAqIC8vICAgIHRpdGxlOiAncmVkZGl0IGdhZGdldCBndWlkZScsXG4gICAqIC8vICAgIC4uLlxuICAgKiAvLyAgfSxcbiAgICogLy8gIFN1YnJlZGRpdCB7XG4gICAqIC8vICAgIGRpc3BsYXlfbmFtZTogJ3Nwb3J0cycsXG4gICAqIC8vICAgIHRpdGxlOiAndGhlIHNwb3J0c3BhZ2Ugb2YgdGhlIEludGVybmV0JyxcbiAgICogLy8gICAgLi4uXG4gICAqIC8vICB9XG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRTdWJzY3JpcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6ICdzdWJyZWRkaXRzL21pbmUvc3Vic2NyaWJlcicsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiBzdWJyZWRkaXRzIGluIHdoaWNoIHRoZSBjdXJyZW50bHktYXV0aGVudGljYXRlZCB1c2VyIGlzIGFuIGFwcHJvdmVkIHN1Ym1pdHRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIFN1YnJlZGRpdHNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRDb250cmlidXRvclN1YnJlZGRpdHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIFN1YnJlZGRpdCB7XG4gICAqIC8vICAgIGRpc3BsYXlfbmFtZTogJ3Nub293cmFwX3Rlc3RpbmcnLFxuICAgKiAvLyAgICB0aXRsZTogJ3Nub293cmFwJyxcbiAgICogLy8gICAgLi4uXG4gICAqIC8vICB9XG4gICAqIC8vIF1cbiAgICpcbiAgICovXG5cblxuICBnZXRDb250cmlidXRvclN1YnJlZGRpdHMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogJ3N1YnJlZGRpdHMvbWluZS9jb250cmlidXRvcicsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiBzdWJyZWRkaXRzIGluIHdoaWNoIHRoZSBjdXJyZW50bHktYXV0aGVudGljYXRlZCB1c2VyIGlzIGEgbW9kZXJhdG9yLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSByZXN1bHRpbmcgTGlzdGluZ1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VicmVkZGl0c1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmdldE1vZGVyYXRlZFN1YnJlZGRpdHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFtcbiAgICogLy8gIFN1YnJlZGRpdCB7XG4gICAqIC8vICAgIGRpc3BsYXlfbmFtZTogJ3Nub293cmFwX3Rlc3RpbmcnLFxuICAgKiAvLyAgICB0aXRsZTogJ3Nub293cmFwJyxcbiAgICogLy8gICAgLi4uXG4gICAqIC8vICB9XG4gICAqIC8vIF1cbiAgICovXG5cblxuICBnZXRNb2RlcmF0ZWRTdWJyZWRkaXRzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6ICdzdWJyZWRkaXRzL21pbmUvbW9kZXJhdG9yJyxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IFNlYXJjaGVzIHN1YnJlZGRpdHMgYnkgdGl0bGUgYW5kIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgc2VhcmNoLiBNYXkgYWxzbyBjb250YWluIExpc3RpbmcgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucXVlcnkgVGhlIHNlYXJjaCBxdWVyeVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBMaXN0aW5nIGNvbnRhaW5pbmcgU3VicmVkZGl0c1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLnNlYXJjaFN1YnJlZGRpdHMoe3F1ZXJ5OiAnY29va2llcyd9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFsgU3VicmVkZGl0IHsgLi4uIH0sIFN1YnJlZGRpdCB7IC4uLiB9LCAuLi5dXG4gICAqL1xuXG5cbiAgc2VhcmNoU3VicmVkZGl0cyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5xID0gb3B0aW9ucy5xdWVyeTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TGlzdGluZyh7XG4gICAgICB1cmk6ICdzdWJyZWRkaXRzL3NlYXJjaCcsXG4gICAgICBxczogKDAsIF9sb2Rhc2gub21pdCkob3B0aW9ucywgJ3F1ZXJ5JylcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyBhIGxpc3Qgb2Ygc3VicmVkZGl0cywgYXJyYW5nZWQgYnkgcG9wdWxhcml0eS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIFN1YnJlZGRpdHNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRQb3B1bGFyU3VicmVkZGl0cygpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IExpc3RpbmcgWyBTdWJyZWRkaXQgeyAuLi4gfSwgU3VicmVkZGl0IHsgLi4uIH0sIC4uLl1cbiAgICovXG5cblxuICBnZXRQb3B1bGFyU3VicmVkZGl0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldExpc3Rpbmcoe1xuICAgICAgdXJpOiAnc3VicmVkZGl0cy9wb3B1bGFyJyxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYSBsaXN0IG9mIHN1YnJlZGRpdHMsIGFycmFuZ2VkIGJ5IGFnZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcmVzdWx0aW5nIExpc3RpbmdcbiAgICogQHJldHVybnMge1Byb21pc2V9IEEgTGlzdGluZyBjb250YWluaW5nIFN1YnJlZGRpdHNcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXROZXdTdWJyZWRkaXRzKCkudGhlbihjb25zb2xlLmxvZylcbiAgICogLy8gPT4gTGlzdGluZyBbIFN1YnJlZGRpdCB7IC4uLiB9LCBTdWJyZWRkaXQgeyAuLi4gfSwgLi4uXVxuICAgKi9cblxuXG4gIGdldE5ld1N1YnJlZGRpdHMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogJ3N1YnJlZGRpdHMvbmV3JyxcbiAgICAgIHFzOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEdldHMgYSBsaXN0IG9mIGdvbGQtZXhjbHVzaXZlIHN1YnJlZGRpdHMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyBTdWJyZWRkaXRzXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0R29sZFN1YnJlZGRpdHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFsgU3VicmVkZGl0IHsgLi4uIH0sIFN1YnJlZGRpdCB7IC4uLiB9LCAuLi5dXG4gICAqL1xuXG5cbiAgZ2V0R29sZFN1YnJlZGRpdHMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogJ3N1YnJlZGRpdHMvZ29sZCcsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBHZXRzIGEgbGlzdCBvZiBkZWZhdWx0IHN1YnJlZGRpdHMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHJlc3VsdGluZyBMaXN0aW5nXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIExpc3RpbmcgY29udGFpbmluZyBTdWJyZWRkaXRzXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuZ2V0RGVmYXVsdFN1YnJlZGRpdHMoKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiBMaXN0aW5nIFsgU3VicmVkZGl0IHsgLi4uIH0sIFN1YnJlZGRpdCB7IC4uLiB9LCAuLi5dXG4gICAqL1xuXG5cbiAgZ2V0RGVmYXVsdFN1YnJlZGRpdHMob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZXRMaXN0aW5nKHtcbiAgICAgIHVyaTogJ3N1YnJlZGRpdHMvZGVmYXVsdCcsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAc3VtbWFyeSBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHVzZXJuYW1lIGlzIGF2YWlsYWJsZSBmb3IgcmVnaXN0cmF0aW9uXG4gICAqIEBkZXNjICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IHdvcmsgd2hlbiBzbm9vd3JhcCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciwgZHVlIHRvIGFuIGlzc3VlIHdpdGggcmVkZGl0J3MgQ09SU1xuICAgc2V0dGluZ3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSB1c2VybmFtZSBpbiBxdWVzdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCBhIEJvb2xlYW4gKGB0cnVlYCBvciBgZmFsc2VgKVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmNoZWNrVXNlcm5hbWVBdmFpbGFiaWxpdHkoJ25vdF9hbl9hYXJkdmFyaycpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IGZhbHNlXG4gICAqIHIuY2hlY2tVc2VybmFtZUF2YWlsYWJpbGl0eSgnZXF3WkFyOXF1bng3SUhxeldWZUYnKS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuXG5cbiAgY2hlY2tVc2VybmFtZUF2YWlsYWJpbGl0eShuYW1lKSB7XG4gICAgLy8gVGhlIG9hdXRoIGVuZHBvaW50IGxpc3RlZCBpbiByZWRkaXQncyBkb2N1bWVudGF0aW9uIGRvZXNuJ3QgYWN0dWFsbHkgd29yaywgc28ganVzdCBzZW5kIGFuIHVuYXV0aGVudGljYXRlZCByZXF1ZXN0LlxuICAgIHJldHVybiB0aGlzLnVuYXV0aGVudGljYXRlZFJlcXVlc3Qoe1xuICAgICAgdXJpOiAnYXBpL3VzZXJuYW1lX2F2YWlsYWJsZS5qc29uJyxcbiAgICAgIHFzOiB7XG4gICAgICAgIHVzZXI6IG5hbWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIG5ldyBMaXZlVGhyZWFkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSBUaGUgdGl0bGUgb2YgdGhlIGxpdmV0aHJlYWQgKDEwMCBjaGFyYWN0ZXJzIG1heClcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSBBIGRlc2NyaXB0aW9ucyBvZiB0aGUgdGhyZWFkLiAxMjAgY2hhcmFjdGVycyBtYXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlc291cmNlc10gSW5mb3JtYXRpb24gYW5kIHVzZWZ1bCBsaW5rcyByZWxhdGVkIHRvIHRoZSB0aHJlYWQuIDEyMCBjaGFyYWN0ZXJzIG1heFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5zZnc9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciB0aGUgdGhyZWFkIGlzIE5vdCBTYWZlIEZvciBXb3JrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoZSBuZXcgTGl2ZVRocmVhZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHIuY3JlYXRlTGl2ZXRocmVhZCh7dGl0bGU6ICdNeSBsaXZldGhyZWFkJ30pLnRoZW4oY29uc29sZS5sb2cpXG4gICAqIC8vID0+IExpdmVUaHJlYWQgeyBpZDogJ3dwaW1uY20xZjAxaicgfVxuICAgKi9cblxuXG4gIGNyZWF0ZUxpdmV0aHJlYWQoX3JlZjEyKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgdmFyIHRpdGxlID0gX3JlZjEyLnRpdGxlLFxuICAgICAgICBkZXNjcmlwdGlvbiA9IF9yZWYxMi5kZXNjcmlwdGlvbixcbiAgICAgICAgcmVzb3VyY2VzID0gX3JlZjEyLnJlc291cmNlcyxcbiAgICAgICAgX3JlZjEyJG5zZncgPSBfcmVmMTIubnNmdyxcbiAgICAgICAgbnNmdyA9IF9yZWYxMiRuc2Z3ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYxMiRuc2Z3O1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9saXZlL2NyZWF0ZScsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIGFwaV90eXBlLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgbnNmdyxcbiAgICAgICAgcmVzb3VyY2VzLFxuICAgICAgICB0aXRsZVxuICAgICAgfVxuICAgIH0pLnRhcCgoMCwgX2hlbHBlcnMuaGFuZGxlSnNvbkVycm9ycykodGhpcykpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIF90aGlzMTEuZ2V0TGl2ZXRocmVhZChyZXN1bHQuanNvbi5kYXRhLmlkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyB0aGUgXCJoYXBwZW5pbmcgbm93XCIgTGl2ZVRocmVhZCwgaWYgaXQgZXhpc3RzXG4gICAqIEBkZXNjIFRoaXMgaXMgdGhlIExpdmVUaHJlYWQgdGhhdCBpcyBvY2Nhc2lvbmFsbHkgbGlua2VkIGF0IHRoZSB0b3Agb2YgcmVkZGl0LmNvbSwgcmVsYXRpbmcgdG8gY3VycmVudCBldmVudHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aXRoIHRoZSBcImhhcHBlbmluZyBub3dcIiBMaXZlVGhyZWFkIGlmIGl0IGV4aXN0cywgb3IgcmVqZWN0cyB3aXRoIGEgNDA0IGVycm9yXG4gICBvdGhlcndpc2UuXG4gICAqIEBleGFtcGxlIHIuZ2V0Q3VycmVudEV2ZW50c0xpdmV0aHJlYWQoKS50aGVuKHRocmVhZCA9PiB0aHJlYWQuc3RyZWFtLm9uKCd1cGRhdGUnLCBjb25zb2xlLmxvZykpXG4gICAqL1xuXG5cbiAgZ2V0U3RpY2tpZWRMaXZldGhyZWFkKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoe1xuICAgICAgdXJpOiAnYXBpL2xpdmUvaGFwcGVuaW5nX25vdydcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgR2V0cyB0aGUgdXNlcidzIG93biBtdWx0aXJlZGRpdHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgZm9yIGFuIEFycmF5IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlcidzIE11bHRpUmVkZGl0cy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogci5nZXRNeU11bHRpcmVkZGl0cygpLnRoZW4oY29uc29sZS5sb2cpXG4gICAqID0+IFsgTXVsdGlSZWRkaXQgeyAuLi4gfSwgTXVsdGlSZWRkaXQgeyAuLi4gfSwgLi4uIF1cbiAgICovXG5cblxuICBnZXRNeU11bHRpcmVkZGl0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHtcbiAgICAgIHVyaTogJ2FwaS9tdWx0aS9taW5lJyxcbiAgICAgIHFzOiB7XG4gICAgICAgIGV4cGFuZF9zcnM6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgQ3JlYXRlcyBhIG5ldyBtdWx0aXJlZGRpdC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IG11bHRpcmVkZGl0LiA1MCBjaGFyYWN0ZXJzIG1heFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5kZXNjcmlwdGlvbiBBIGRlc2NyaXB0aW9uIGZvciB0aGUgbmV3IG11bHRpcmVkZGl0LCBpbiBtYXJrZG93bi5cbiAgICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5zdWJyZWRkaXRzIEFuIEFycmF5IG9mIFN1YnJlZGRpdCBvYmplY3RzIChvciBzdWJyZWRkaXQgbmFtZXMpIHRoYXQgdGhpcyBtdWx0aXJlZGRpdCBzaG91bGQgY29tcG9zZSBvZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmlzaWJpbGl0eT0ncHJpdmF0ZSddIFRoZSBtdWx0aXJlZGRpdCdzIHZpc2liaWxpdHkgc2V0dGluZy4gT25lIG9mIGBwcml2YXRlYCwgYHB1YmxpY2AsIGBoaWRkZW5gLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWNvbl9uYW1lPScnXSBPbmUgb2YgYGFydCBhbmQgZGVzaWduYCwgYGFza2AsIGBib29rc2AsIGBidXNpbmVzc2AsIGBjYXJzYCwgYGNvbWljc2AsXG4gICBgY3V0ZSBhbmltYWxzYCwgYGRpeWAsIGBlbnRlcnRhaW5tZW50YCwgYGZvb2QgYW5kIGRyaW5rYCwgYGZ1bm55YCwgYGdhbWVzYCwgYGdyb29taW5nYCwgYGhlYWx0aGAsIGBsaWZlIGFkdmljZWAsIGBtaWxpdGFyeWAsXG4gICBgbW9kZWxzIHBpbnVwYCwgYG11c2ljYCwgYG5ld3NgLCBgcGhpbG9zb3BoeWAsIGBwaWN0dXJlcyBhbmQgZ2lmc2AsIGBzY2llbmNlYCwgYHNob3BwaW5nYCwgYHNwb3J0c2AsIGBzdHlsZWAsIGB0ZWNoYCxcbiAgIGB0cmF2ZWxgLCBgdW51c3VhbCBzdG9yaWVzYCwgYHZpZGVvYCwgYE5vbmVgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5rZXlfY29sb3I9JyMwMDAwMDAnXSBBIHNpeC1kaWdpdCBSR0IgaGV4IGNvbG9yLCBwcmVjZWRlZCBieSAnIydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLndlaWdodGluZ19zY2hlbWU9J2NsYXNzaWMnXSBPbmUgb2YgYGNsYXNzaWNgLCBgZnJlc2hgXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgZm9yIHRoZSBuZXdseS1jcmVhdGVkIE11bHRpUmVkZGl0IG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiByLmNyZWF0ZU11bHRpcmVkZGl0KHtcbiAgICogICBuYW1lOiAnbXlNdWx0aScsXG4gICAqICAgZGVzY3JpcHRpb246ICdBbiBleGFtcGxlIG11bHRpcmVkZGl0JyxcbiAgICogICBzdWJyZWRkaXRzOiBbJ3Nub293cmFwJywgJ3Nub293cmFwX3Rlc3RpbmcnXVxuICAgKiB9KS50aGVuKGNvbnNvbGUubG9nKVxuICAgKiA9PiBNdWx0aVJlZGRpdCB7IGRpc3BsYXlfbmFtZTogJ215TXVsdGknLCAuLi4gfVxuICAgKi9cblxuXG4gIGNyZWF0ZU11bHRpcmVkZGl0KF9yZWYxMykge1xuICAgIHZhciBuYW1lID0gX3JlZjEzLm5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uID0gX3JlZjEzLmRlc2NyaXB0aW9uLFxuICAgICAgICBzdWJyZWRkaXRzID0gX3JlZjEzLnN1YnJlZGRpdHMsXG4gICAgICAgIF9yZWYxMyR2aXNpYmlsaXR5ID0gX3JlZjEzLnZpc2liaWxpdHksXG4gICAgICAgIHZpc2liaWxpdHkgPSBfcmVmMTMkdmlzaWJpbGl0eSA9PT0gdm9pZCAwID8gJ3ByaXZhdGUnIDogX3JlZjEzJHZpc2liaWxpdHksXG4gICAgICAgIF9yZWYxMyRpY29uX25hbWUgPSBfcmVmMTMuaWNvbl9uYW1lLFxuICAgICAgICBpY29uX25hbWUgPSBfcmVmMTMkaWNvbl9uYW1lID09PSB2b2lkIDAgPyAnJyA6IF9yZWYxMyRpY29uX25hbWUsXG4gICAgICAgIF9yZWYxMyRrZXlfY29sb3IgPSBfcmVmMTMua2V5X2NvbG9yLFxuICAgICAgICBrZXlfY29sb3IgPSBfcmVmMTMka2V5X2NvbG9yID09PSB2b2lkIDAgPyAnIzAwMDAwMCcgOiBfcmVmMTMka2V5X2NvbG9yLFxuICAgICAgICBfcmVmMTMkd2VpZ2h0aW5nX3NjaGUgPSBfcmVmMTMud2VpZ2h0aW5nX3NjaGVtZSxcbiAgICAgICAgd2VpZ2h0aW5nX3NjaGVtZSA9IF9yZWYxMyR3ZWlnaHRpbmdfc2NoZSA9PT0gdm9pZCAwID8gJ2NsYXNzaWMnIDogX3JlZjEzJHdlaWdodGluZ19zY2hlO1xuICAgIHJldHVybiB0aGlzLl9wb3N0KHtcbiAgICAgIHVyaTogJ2FwaS9tdWx0aScsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIG1vZGVsOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZGlzcGxheV9uYW1lOiBuYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uX21kOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICBpY29uX25hbWUsXG4gICAgICAgICAga2V5X2NvbG9yLFxuICAgICAgICAgIHN1YnJlZGRpdHM6IHN1YnJlZGRpdHMubWFwKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG5hbWU6IHR5cGVvZiBzdWIgPT09ICdzdHJpbmcnID8gc3ViIDogc3ViLmRpc3BsYXlfbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB2aXNpYmlsaXR5LFxuICAgICAgICAgIHdlaWdodGluZ19zY2hlbWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9yZXZva2VUb2tlbih0b2tlbikge1xuICAgIHJldHVybiB0aGlzLmNyZWRlbnRpYWxlZENsaWVudFJlcXVlc3Qoe1xuICAgICAgdXJpOiAnYXBpL3YxL3Jldm9rZV90b2tlbicsXG4gICAgICBmb3JtOiB7XG4gICAgICAgIHRva2VuXG4gICAgICB9LFxuICAgICAgbWV0aG9kOiAncG9zdCdcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgSW52YWxpZGF0ZXMgdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2hlbiB0aGlzIHJlcXVlc3QgaXMgY29tcGxldGVcbiAgICogQGRlc2MgKipOb3RlKio6IFRoaXMgY2FuIG9ubHkgYmUgdXNlZCBpZiB0aGUgY3VycmVudCByZXF1ZXN0ZXIgd2FzIHN1cHBsaWVkIHdpdGggYSBgY2xpZW50X2lkYCBhbmQgYGNsaWVudF9zZWNyZXRgLiBJZiB0aGVcbiAgIGN1cnJlbnQgcmVxdWVzdGVyIHdhcyBzdXBwbGllZCB3aXRoIGEgcmVmcmVzaCB0b2tlbiwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhIG5ldyBhY2Nlc3MgdG9rZW4gaWYgYW55IG1vcmUgcmVxdWVzdHNcbiAgIGFyZSBtYWRlIGFmdGVyIHRoaXMgb25lLlxuICAgKiBAZXhhbXBsZSByLnJldm9rZUFjY2Vzc1Rva2VuKCk7XG4gICAqL1xuXG5cbiAgcmV2b2tlQWNjZXNzVG9rZW4oKSB7XG4gICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Jldm9rZVRva2VuKHRoaXMuYWNjZXNzVG9rZW4pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMxMi5hY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICBfdGhpczEyLnRva2VuRXhwaXJhdGlvbiA9IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBzdW1tYXJ5IEludmFsaWRhdGVzIHRoZSBjdXJyZW50IHJlZnJlc2ggdG9rZW4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIFByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIHRoaXMgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAgKiBAZGVzYyAqKk5vdGUqKjogVGhpcyBjYW4gb25seSBiZSB1c2VkIGlmIHRoZSBjdXJyZW50IHJlcXVlc3RlciB3YXMgc3VwcGxpZWQgd2l0aCBhIGBjbGllbnRfaWRgIGFuZCBgY2xpZW50X3NlY3JldGAuIEFsbFxuICAgYWNjZXNzIHRva2VucyBnZW5lcmF0ZWQgYnkgdGhpcyByZWZyZXNoIHRva2VuIHdpbGwgYWxzbyBiZSBpbnZhbGlkYXRlZC4gVGhpcyBlZmZlY3RpdmVseSBkZS1hdXRoZW50aWNhdGVzIHRoZSByZXF1ZXN0ZXIgYW5kXG4gICBwcmV2ZW50cyBpdCBmcm9tIG1ha2luZyBhbnkgbW9yZSB2YWxpZCByZXF1ZXN0cy4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIGEgZmV3IGNhc2VzLCBlLmcuIGlmIHRoaXMgdG9rZW4gaGFzXG4gICBiZWVuIGFjY2lkZW50YWxseSBsZWFrZWQgdG8gYSB0aGlyZCBwYXJ0eS5cbiAgICogQGV4YW1wbGUgci5yZXZva2VSZWZyZXNoVG9rZW4oKTtcbiAgICovXG5cblxuICByZXZva2VSZWZyZXNoVG9rZW4oKSB7XG4gICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Jldm9rZVRva2VuKHRoaXMucmVmcmVzaFRva2VuKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMTMucmVmcmVzaFRva2VuID0gbnVsbDtcbiAgICAgIF90aGlzMTMuYWNjZXNzVG9rZW4gPSBudWxsOyAvLyBSZXZva2luZyBhIHJlZnJlc2ggdG9rZW4gYWxzbyByZXZva2VzIGFueSBhc3NvY2lhdGVkIGFjY2VzcyB0b2tlbnMuXG5cbiAgICAgIF90aGlzMTMudG9rZW5FeHBpcmF0aW9uID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIF9zZWxlY3RGbGFpcihfcmVmMTQpIHtcbiAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICB2YXIgZmxhaXJfdGVtcGxhdGVfaWQgPSBfcmVmMTQuZmxhaXJfdGVtcGxhdGVfaWQsXG4gICAgICAgIGxpbmsgPSBfcmVmMTQubGluayxcbiAgICAgICAgbmFtZSA9IF9yZWYxNC5uYW1lLFxuICAgICAgICB0ZXh0ID0gX3JlZjE0LnRleHQsXG4gICAgICAgIHN1YnJlZGRpdE5hbWUgPSBfcmVmMTQuc3VicmVkZGl0TmFtZTtcblxuICAgIGlmICghZmxhaXJfdGVtcGxhdGVfaWQpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZE1ldGhvZENhbGxFcnJvcignTm8gZmxhaXIgdGVtcGxhdGUgSUQgcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1Byb21pc2UuZGVmYXVsdC5yZXNvbHZlKHN1YnJlZGRpdE5hbWUpLnRoZW4oZnVuY3Rpb24gKHN1Yk5hbWUpIHtcbiAgICAgIHJldHVybiBfdGhpczE0Ll9wb3N0KHtcbiAgICAgICAgdXJpOiBcInIvXCIuY29uY2F0KHN1Yk5hbWUsIFwiL2FwaS9zZWxlY3RmbGFpclwiKSxcbiAgICAgICAgZm9ybToge1xuICAgICAgICAgIGFwaV90eXBlLFxuICAgICAgICAgIGZsYWlyX3RlbXBsYXRlX2lkLFxuICAgICAgICAgIGxpbmssXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX2Fzc2lnbkZsYWlyKF9yZWYxNSkge1xuICAgIHZhciBfdGhpczE1ID0gdGhpcztcblxuICAgIHZhciBjc3NfY2xhc3MgPSBfcmVmMTUuY3NzX2NsYXNzLFxuICAgICAgICBfcmVmMTUkY3NzQ2xhc3MgPSBfcmVmMTUuY3NzQ2xhc3MsXG4gICAgICAgIGNzc0NsYXNzID0gX3JlZjE1JGNzc0NsYXNzID09PSB2b2lkIDAgPyBjc3NfY2xhc3MgOiBfcmVmMTUkY3NzQ2xhc3MsXG4gICAgICAgIGxpbmsgPSBfcmVmMTUubGluayxcbiAgICAgICAgbmFtZSA9IF9yZWYxNS5uYW1lLFxuICAgICAgICB0ZXh0ID0gX3JlZjE1LnRleHQsXG4gICAgICAgIHN1YnJlZGRpdF9uYW1lID0gX3JlZjE1LnN1YnJlZGRpdF9uYW1lLFxuICAgICAgICBfcmVmMTUkc3VicmVkZGl0TmFtZSA9IF9yZWYxNS5zdWJyZWRkaXROYW1lLFxuICAgICAgICBzdWJyZWRkaXROYW1lID0gX3JlZjE1JHN1YnJlZGRpdE5hbWUgPT09IHZvaWQgMCA/IHN1YnJlZGRpdF9uYW1lIDogX3JlZjE1JHN1YnJlZGRpdE5hbWU7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VXcmFwKF9Qcm9taXNlLmRlZmF1bHQucmVzb2x2ZShzdWJyZWRkaXROYW1lKS50aGVuKGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgcmV0dXJuIF90aGlzMTUuX3Bvc3Qoe1xuICAgICAgICB1cmk6IFwici9cIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiL2FwaS9mbGFpclwiKSxcbiAgICAgICAgZm9ybToge1xuICAgICAgICAgIGFwaV90eXBlLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBsaW5rLFxuICAgICAgICAgIGNzc19jbGFzczogY3NzQ2xhc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG5cbiAgX3BvcHVsYXRlKHJlc3BvbnNlVHJlZSkge1xuICAgIHZhciBfdGhpczE2ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VUcmVlID09PSAnb2JqZWN0JyAmJiByZXNwb25zZVRyZWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1hcCB7a2luZDogJ3QyJywgZGF0YToge25hbWU6ICdzb21lX3VzZXJuYW1lJywgLi4uIH19IHRvIGEgUmVkZGl0VXNlciAoZS5nLikgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzXG4gICAgICBpZiAoT2JqZWN0LmtleXMocmVzcG9uc2VUcmVlKS5sZW5ndGggPT09IDIgJiYgcmVzcG9uc2VUcmVlLmtpbmQgJiYgcmVzcG9uc2VUcmVlLmRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ld09iamVjdChfY29uc3RhbnRzLktJTkRTW3Jlc3BvbnNlVHJlZS5raW5kXSB8fCAnUmVkZGl0Q29udGVudCcsIHRoaXMuX3BvcHVsYXRlKHJlc3BvbnNlVHJlZS5kYXRhKSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAoQXJyYXkuaXNBcnJheShyZXNwb25zZVRyZWUpID8gX2xvZGFzaC5tYXAgOiBfbG9kYXNoLm1hcFZhbHVlcykocmVzcG9uc2VUcmVlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAvLyBNYXBzIHthdXRob3I6ICdzb21lX3VzZXJuYW1lJ30gdG8ge2F1dGhvcjogUmVkZGl0VXNlciB7IG5hbWU6ICdzb21lX3VzZXJuYW1lJyB9IH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIF9jb25zdGFudHMuVVNFUl9LRVlTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTYuX25ld09iamVjdCgnUmVkZGl0VXNlcicsIHtcbiAgICAgICAgICAgIG5hbWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgX2NvbnN0YW50cy5TVUJSRURESVRfS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczE2Ll9uZXdPYmplY3QoJ1N1YnJlZGRpdCcsIHtcbiAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpczE2Ll9wb3B1bGF0ZSh2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2Ygc25vb3dyYXAub2JqZWN0cy5MaXN0aW5nICYmIHJlc3VsdFswXVswXSBpbnN0YW5jZW9mIHNub293cmFwLm9iamVjdHMuU3VibWlzc2lvbiAmJiByZXN1bHRbMV0gaW5zdGFuY2VvZiBzbm9vd3JhcC5vYmplY3RzLkxpc3RpbmcpIHtcbiAgICAgICAgaWYgKHJlc3VsdFsxXS5fbW9yZSAmJiAhcmVzdWx0WzFdLl9tb3JlLmxpbmtfaWQpIHtcbiAgICAgICAgICByZXN1bHRbMV0uX21vcmUubGlua19pZCA9IHJlc3VsdFswXVswXS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0WzBdWzBdLmNvbW1lbnRzID0gcmVzdWx0WzFdO1xuICAgICAgICByZXR1cm4gcmVzdWx0WzBdWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVRyZWU7XG4gIH1cblxuICBfZ2V0TGlzdGluZyhfcmVmMTYpIHtcbiAgICB2YXIgdXJpID0gX3JlZjE2LnVyaSxcbiAgICAgICAgX3JlZjE2JHFzID0gX3JlZjE2LnFzLFxuICAgICAgICBxcyA9IF9yZWYxNiRxcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMTYkcXMsXG4gICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjE2LCBbXCJ1cmlcIiwgXCJxc1wiXSk7XG5cbiAgICAvKiBXaGVuIHRoZSByZXNwb25zZSB0eXBlIGlzIGV4cGVjdGVkIHRvIGJlIGEgTGlzdGluZywgYWRkIGEgYGNvdW50YCBwYXJhbWV0ZXIgd2l0aCBhIHZlcnkgaGlnaCBudW1iZXIuXG4gICAgVGhpcyBlbnN1cmVzIHRoYXQgcmVkZGl0IHJldHVybnMgYSBgYmVmb3JlYCBwcm9wZXJ0eSBpbiB0aGUgcmVzdWx0aW5nIExpc3RpbmcgdG8gZW5hYmxlIHBhZ2luYXRpb24uXG4gICAgKEFzaWRlIGZyb20gdGhlIGFkZGl0aW9uYWwgcGFyYW1ldGVyLCB0aGlzIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gc25vb3dyYXAucHJvdG90eXBlLl9nZXQpICovXG4gICAgdmFyIG1lcmdlZFF1ZXJ5ID0gX29iamVjdFNwcmVhZCh7XG4gICAgICBjb3VudDogOTk5OVxuICAgIH0sIHFzKTtcblxuICAgIHJldHVybiBxcy5saW1pdCB8fCAhKDAsIF9sb2Rhc2guaXNFbXB0eSkob3B0aW9ucykgPyB0aGlzLl9uZXdPYmplY3QoJ0xpc3RpbmcnLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIF9xdWVyeTogbWVyZ2VkUXVlcnksXG4gICAgICBfdXJpOiB1cmlcbiAgICB9LCBvcHRpb25zKSkuZmV0Y2hNb3JlKHFzLmxpbWl0IHx8IF9jb25zdGFudHMuTUFYX0xJU1RJTkdfSVRFTVMpXG4gICAgLyogVGhpcyBzZWNvbmQgY2FzZSBpcyB1c2VkIGFzIGEgZmFsbGJhY2sgaW4gY2FzZSB0aGUgZW5kcG9pbnQgdW5leHBlY3RlZGx5IGVuZHMgdXAgcmV0dXJuaW5nIHNvbWV0aGluZyBvdGhlciB0aGFuIGFcbiAgICBMaXN0aW5nIChlLmcuIFN1Ym1pc3Npb24jZ2V0UmVsYXRlZCwgd2hpY2ggdXNlZCB0byByZXR1cm4gYSBMaXN0aW5nIGJ1dCBubyBsb25nZXIgZG9lcyBkdWUgdG8gdXBzdHJlYW0gcmVkZGl0IEFQSVxuICAgIGNoYW5nZXMpLCBpbiB3aGljaCBjYXNlIHVzaW5nIGZldGNoX21vcmUoKSBhcyBhYm92ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICBUaGlzIGZhbGxiYWNrIG9ubHkgd29ya3MgaWYgdGhlcmUgYXJlIG5vIG90aGVyIG1ldGEtcHJvcGVydGllcyBwcm92aWRlZCBmb3IgdGhlIExpc3RpbmcsIHN1Y2ggYXMgX3RyYW5zZm9ybS4gSWYgdGhlcmUgYXJlXG4gICAgb3RoZXIgbWV0YS1wcm9wZXJ0aWVzLCAgdGhlIGZ1bmN0aW9uIHdpbGwgc3RpbGwgZW5kIHVwIHRocm93aW5nIGFuIGVycm9yLCBidXQgdGhlcmUncyBub3QgcmVhbGx5IGFueSBnb29kIHdheSB0byBoYW5kbGUgaXRcbiAgICAocHJlZGljdGluZyB1cHN0cmVhbSBjaGFuZ2VzIGNhbiBvbmx5IGdvIHNvIGZhcikuIE1vcmUgaW1wb3J0YW50bHksIGluIHRoZSBsaW1pdGVkIGNhc2VzIHdoZXJlIGl0J3MgdXNlZCwgdGhlIGZhbGxiYWNrXG4gICAgc2hvdWxkIGhhdmUgbm8gZWZmZWN0IG9uIHRoZSByZXR1cm5lZCByZXN1bHRzICovXG4gICAgOiB0aGlzLl9nZXQoe1xuICAgICAgdXJpLFxuICAgICAgcXM6IG1lcmdlZFF1ZXJ5XG4gICAgfSkudGhlbihmdW5jdGlvbiAobGlzdGluZykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdGluZykpIHtcbiAgICAgICAgbGlzdGluZy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbS5jb25zdHJ1Y3Rvci5fbmFtZSA9PT0gJ0NvbW1lbnQnO1xuICAgICAgICB9KS5mb3JFYWNoKF9oZWxwZXJzLmFkZEVtcHR5UmVwbGllc0xpc3RpbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdGluZztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHN1bW1hcnkgSW4gYnJvd3NlcnMsIHJlc3RvcmVzIHRoZSBgd2luZG93LnNub293cmFwYCBwcm9wZXJ0eSB0byB3aGF0ZXZlciBpdCB3YXMgYmVmb3JlIHRoaXMgaW5zdGFuY2Ugb2Ygc25vb3dyYXAgd2FzXG4gICBsb2FkZWQuIFRoaXMgaXMgYSBuby1vcCBpbiBOb2RlLlxuICAgKiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIG9mIHRoZSBzbm9vd3JhcCBjb25zdHJ1Y3RvclxuICAgKiBAZXhhbXBsZSB2YXIgc25vb3dyYXAgPSB3aW5kb3cuc25vb3dyYXAubm9Db25mbGljdCgpO1xuICAgKi9cblxuXG4gIHN0YXRpYyBub0NvbmZsaWN0KCkge1xuICAgIGlmIChfaGVscGVycy5pc0Jyb3dzZXIpIHtcbiAgICAgIGdsb2JhbFtfY29uc3RhbnRzLk1PRFVMRV9OQU1FXSA9IHRoaXMuX3ByZXZpb3VzU25vb3dyYXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4oMCwgX2hlbHBlcnMuZGVmaW5lSW5zcGVjdEZ1bmMpKHNub293cmFwLnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xuICAvLyBIaWRlIGNvbmZpZGVudGlhbCBpbmZvcm1hdGlvbiAodG9rZW5zLCBjbGllbnQgSURzLCBldGMuKSwgYXMgd2VsbCBhcyBwcml2YXRlIHByb3BlcnRpZXMsIGZyb20gdGhlIGNvbnNvbGUubG9nIG91dHB1dC5cbiAgdmFyIGtleXNGb3JIaWRkZW5WYWx1ZXMgPSBbJ2NsaWVudFNlY3JldCcsICdyZWZyZXNoVG9rZW4nLCAnYWNjZXNzVG9rZW4nLCAncGFzc3dvcmQnXTtcbiAgdmFyIGZvcm1hdHRlZCA9ICgwLCBfbG9kYXNoLm1hcFZhbHVlcykoKDAsIF9sb2Rhc2gub21pdEJ5KSh0aGlzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuc3RhcnRzV2l0aCgnXycpO1xuICB9KSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gKDAsIF9sb2Rhc2guaW5jbHVkZXMpKGtleXNGb3JIaWRkZW5WYWx1ZXMsIGtleSkgPyB2YWx1ZSAmJiAnKHJlZGFjdGVkKScgOiB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChfY29uc3RhbnRzLk1PRFVMRV9OQU1FLCBcIiBcIikuY29uY2F0KF91dGlsLmRlZmF1bHQuaW5zcGVjdChmb3JtYXR0ZWQpKTtcbn0pO1xudmFyIGNsYXNzRnVuY0Rlc2NyaXB0b3JzID0ge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59O1xuLyogQWRkIHRoZSByZXF1ZXN0X2hhbmRsZXIgZnVuY3Rpb25zIChvYXV0aF9yZXF1ZXN0LCBjcmVkZW50aWFsZWRfY2xpZW50X3JlcXVlc3QsIGV0Yy4pIHRvIHRoZSBzbm9vd3JhcCBwcm90b3R5cGUuIFVzZVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgdG8gZW5zdXJlIHRoYXQgdGhlIHByb3BlcnRpZXMgYXJlIG5vbi1lbnVtZXJhYmxlLiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhzbm9vd3JhcC5wcm90b3R5cGUsICgwLCBfbG9kYXNoLm1hcFZhbHVlcykocmVxdWVzdEhhbmRsZXIsIGZ1bmN0aW9uIChmdW5jKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICB2YWx1ZTogZnVuY1xuICB9LCBjbGFzc0Z1bmNEZXNjcmlwdG9ycyk7XG59KSk7XG5cbl9jb25zdGFudHMuSFRUUF9WRVJCUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLyogRGVmaW5lIG1ldGhvZCBzaG9ydGN1dHMgZm9yIGVhY2ggb2YgdGhlIEhUVFAgdmVyYnMuIGkuZS4gYHNub293cmFwLnByb3RvdHlwZS5fcG9zdGAgaXMgdGhlIHNhbWUgYXMgYG9hdXRoX3JlcXVlc3RgIGV4Y2VwdFxuICB0aGF0IHRoZSBIVFRQIG1ldGhvZCBkZWZhdWx0cyB0byBgcG9zdGAsIGFuZCB0aGUgcmVzdWx0IGlzIHByb21pc2Utd3JhcHBlZC4gVXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgcHJvcGVydGllcyBhcmUgbm9uLWVudW1lcmFibGUuICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzbm9vd3JhcC5wcm90b3R5cGUsIFwiX1wiLmNvbmNhdChtZXRob2QpLCBfb2JqZWN0U3ByZWFkKHtcbiAgICB2YWx1ZShvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVdyYXAodGhpcy5vYXV0aFJlcXVlc3QoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBtZXRob2RcbiAgICAgIH0pKSk7XG4gICAgfVxuXG4gIH0sIGNsYXNzRnVuY0Rlc2NyaXB0b3JzKSk7XG59KTtcbi8qIGBvYmplY3RzYCB3aWxsIGJlIGFuIG9iamVjdCBjb250YWluaW5nIGdldHRlcnMgZm9yIGVhY2ggY29udGVudCB0eXBlLCBkdWUgdG8gdGhlIHdheSBvYmplY3RzIGFyZSBleHBvcnRlZCBmcm9tXG5vYmplY3RzL2luZGV4LmpzLiBUbyB1bndyYXAgdGhlc2UgZ2V0dGVycyBpbnRvIGRpcmVjdCBwcm9wZXJ0aWVzLCB1c2UgbG9kYXNoLm1hcFZhbHVlcyB3aXRoIGFuIGlkZW50aXR5IGZ1bmN0aW9uLiAqL1xuXG5cbnNub293cmFwLm9iamVjdHMgPSAoMCwgX2xvZGFzaC5tYXBWYWx1ZXMpKG9iamVjdHMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59KTtcbigwLCBfbG9kYXNoLmZvck93bikoX2NvbnN0YW50cy5LSU5EUywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHNub293cmFwLm9iamVjdHNbdmFsdWVdID0gc25vb3dyYXAub2JqZWN0c1t2YWx1ZV0gfHwgY2xhc3MgZXh0ZW5kcyBvYmplY3RzLlJlZGRpdENvbnRlbnQge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzbm9vd3JhcC5vYmplY3RzW3ZhbHVlXSwgJ19uYW1lJywge1xuICAgIHZhbHVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn0pOyAvLyBBbGlhcyBhbGwgZnVuY3Rpb25zIG9uIHNub293cmFwJ3MgcHJvdG90eXBlIGFuZCBzbm9vd3JhcCdzIG9iamVjdCBwcm90b3R5cGVzIGluIHNuYWtlX2Nhc2UuXG5cbigwLCBfbG9kYXNoLnZhbHVlcykoc25vb3dyYXAub2JqZWN0cykuY29uY2F0KHNub293cmFwKS5tYXAoZnVuY3Rpb24gKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmMucHJvdG90eXBlO1xufSkuZm9yRWFjaChmdW5jdGlvbiAoZnVuY1Byb3RvKSB7XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGZ1bmNQcm90bykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICFuYW1lLnN0YXJ0c1dpdGgoJ18nKSAmJiBuYW1lICE9PSAoMCwgX2xvZGFzaC5zbmFrZUNhc2UpKG5hbWUpICYmIHR5cGVvZiBmdW5jUHJvdG9bbmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmNQcm90bywgKDAsIF9sb2Rhc2guc25ha2VDYXNlKShuYW1lKSwgX29iamVjdFNwcmVhZCh7XG4gICAgICB2YWx1ZTogZnVuY1Byb3RvW25hbWVdXG4gICAgfSwgY2xhc3NGdW5jRGVzY3JpcHRvcnMpKTtcbiAgfSk7XG59KTtcbnNub293cmFwLmVycm9ycyA9IGVycm9ycztcbnNub293cmFwLnZlcnNpb24gPSBfY29uc3RhbnRzLlZFUlNJT047XG5cbmlmICghbW9kdWxlLnBhcmVudCAmJiBfaGVscGVycy5pc0Jyb3dzZXIpIHtcbiAgLy8gY2hlY2sgaWYgdGhlIGNvZGUgaXMgYmVpbmcgcnVuIGluIGEgYnJvd3NlciB0aHJvdWdoIGJyb3dzZXJpZnksIGV0Yy5cbiAgc25vb3dyYXAuX3ByZXZpb3VzU25vb3dyYXAgPSBnbG9iYWxbX2NvbnN0YW50cy5NT0RVTEVfTkFNRV07XG4gIGdsb2JhbFtfY29uc3RhbnRzLk1PRFVMRV9OQU1FXSA9IHNub293cmFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNub293cmFwOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/snoowrap.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/dist/xhr.js":
/*!*******************************************!*\
  !*** ./node_modules/snoowrap/dist/xhr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _Promise = _interopRequireDefault(__webpack_require__(/*! ./Promise.js */ \"(rsc)/./node_modules/snoowrap/dist/Promise.js\"));\n\nvar _url = _interopRequireDefault(__webpack_require__(/*! url */ \"url\"));\n\nvar _querystring = __webpack_require__(/*! querystring */ \"querystring\");\n\nvar _errors = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/snoowrap/dist/errors.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-env browser */\n// Provide a shim for some of the functionality of the `request-promise` npm package in browsers.\n// Previously, snoowrap depended on browserify to package `request-promise` for the browser bundle, and while this worked\n// properly, it caused the snoowrap bundle to be very large since `request-promise` contains many dependencies that snoowrap\n// doesn't actually need.\nfunction noop() {}\n\nfunction tryParseJson(maybeJson) {\n  try {\n    return JSON.parse(maybeJson);\n  } catch (e) {\n    return maybeJson;\n  }\n}\n\nfunction parseHeaders(headerString) {\n  return headerString.split('\\r\\n').filter(function (line) {\n    return line;\n  }).reduce(function (accumulator, line) {\n    var index = line.indexOf(': ');\n    accumulator[line.slice(0, index)] = line.slice(index + 2);\n    return accumulator;\n  }, {});\n}\n\nmodule.exports = function rawRequest(options) {\n  // It would be nice to be able to use the `URL` API in browsers, but Safari 9 doesn't support `URLSearchParams`.\n  var parsedUrl = _url.default.parse(options.url || _url.default.resolve(options.baseUrl, options.uri), true);\n\n  parsedUrl.search = (0, _querystring.stringify)(Object.assign({}, parsedUrl.query, options.qs)); // create a new url object with the new qs params, to ensure that the `href` value changes (to use later for parsing response)\n\n  var finalUrl = _url.default.parse(parsedUrl.format());\n\n  var xhr = new XMLHttpRequest();\n  var method = options.method ? options.method.toUpperCase() : 'GET';\n  xhr.open(method, finalUrl.href);\n  Object.keys(options.headers).filter(function (header) {\n    return header.toLowerCase() !== 'user-agent';\n  }).forEach(function (key) {\n    return xhr.setRequestHeader(key, options.headers[key]);\n  });\n\n  if (options.auth) {\n    xhr.setRequestHeader('Authorization', options.auth.bearer ? \"bearer \".concat(options.auth.bearer) : 'basic ' + btoa(\"\".concat(options.auth.user, \":\").concat(options.auth.pass)));\n  }\n\n  var requestBody;\n\n  if (options.formData) {\n    requestBody = new FormData();\n    Object.keys(options.formData).forEach(function (key) {\n      return requestBody.append(key, options.formData[key]);\n    });\n\n    if (options.form) {\n      Object.keys(options.form).forEach(function (key) {\n        return requestBody.append(key, options.form[key]);\n      });\n    }\n\n    xhr.setRequestHeader('Content-Type', 'multipart/form-data');\n  } else if (options.form) {\n    requestBody = (0, _querystring.stringify)(options.form);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  } else if (options.json) {\n    requestBody = JSON.stringify(options.body);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n  } else {\n    requestBody = options.body;\n  }\n\n  return new _Promise.default(function (resolve, reject, onCancel) {\n    onCancel(function () {\n      return xhr.abort();\n    });\n\n    xhr.onload = function () {\n      var _this = this;\n\n      var success = this.status >= 200 && this.status < 300;\n      var settleFunc = success ? resolve : function (err) {\n        return reject(Object.assign(new _errors.StatusCodeError(_this.status + ''), err));\n      };\n      var response = {\n        statusCode: this.status,\n        body: (options.json ? tryParseJson : noop)(xhr.response),\n        headers: parseHeaders(xhr.getAllResponseHeaders()),\n        request: {\n          method,\n          uri: finalUrl\n        }\n      };\n\n      if (typeof options.transform === 'function') {\n        settleFunc(options.transform(response.body, response));\n      } else if (!success || options.resolveWithFullResponse) {\n        settleFunc(response);\n      } else {\n        settleFunc(response.body);\n      }\n    };\n\n    xhr.onerror = function (err) {\n      return reject(Object.assign(new _errors.RequestError(), err));\n    };\n\n    xhr.send(requestBody);\n  }).timeout(options.timeout || Math.pow(2, 31) - 1, 'Error: ETIMEDOUT').catch(_Promise.default.TimeoutError, function (err) {\n    xhr.abort();\n    throw err;\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvZGlzdC94aHIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0NBQXNDLG1CQUFPLENBQUMsbUVBQWM7O0FBRTVELGtDQUFrQyxtQkFBTyxDQUFDLGdCQUFLOztBQUUvQyxtQkFBbUIsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFeEMsY0FBYyxtQkFBTyxDQUFDLGlFQUFhOztBQUVuQyx1Q0FBdUMsdUNBQXVDOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFpRSxpQ0FBaUM7O0FBRWxHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9kaXN0L3hoci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9Qcm9taXNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Qcm9taXNlLmpzXCIpKTtcblxudmFyIF91cmwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ1cmxcIikpO1xuXG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuXG52YXIgX2Vycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG4vLyBQcm92aWRlIGEgc2hpbSBmb3Igc29tZSBvZiB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGUgYHJlcXVlc3QtcHJvbWlzZWAgbnBtIHBhY2thZ2UgaW4gYnJvd3NlcnMuXG4vLyBQcmV2aW91c2x5LCBzbm9vd3JhcCBkZXBlbmRlZCBvbiBicm93c2VyaWZ5IHRvIHBhY2thZ2UgYHJlcXVlc3QtcHJvbWlzZWAgZm9yIHRoZSBicm93c2VyIGJ1bmRsZSwgYW5kIHdoaWxlIHRoaXMgd29ya2VkXG4vLyBwcm9wZXJseSwgaXQgY2F1c2VkIHRoZSBzbm9vd3JhcCBidW5kbGUgdG8gYmUgdmVyeSBsYXJnZSBzaW5jZSBgcmVxdWVzdC1wcm9taXNlYCBjb250YWlucyBtYW55IGRlcGVuZGVuY2llcyB0aGF0IHNub293cmFwXG4vLyBkb2Vzbid0IGFjdHVhbGx5IG5lZWQuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJ5UGFyc2VKc29uKG1heWJlSnNvbikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKG1heWJlSnNvbik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbWF5YmVKc29uO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJTdHJpbmcpIHtcbiAgcmV0dXJuIGhlYWRlclN0cmluZy5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIGxpbmUpIHtcbiAgICB2YXIgaW5kZXggPSBsaW5lLmluZGV4T2YoJzogJyk7XG4gICAgYWNjdW11bGF0b3JbbGluZS5zbGljZSgwLCBpbmRleCldID0gbGluZS5zbGljZShpbmRleCArIDIpO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfSwge30pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhd1JlcXVlc3Qob3B0aW9ucykge1xuICAvLyBJdCB3b3VsZCBiZSBuaWNlIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBgVVJMYCBBUEkgaW4gYnJvd3NlcnMsIGJ1dCBTYWZhcmkgOSBkb2Vzbid0IHN1cHBvcnQgYFVSTFNlYXJjaFBhcmFtc2AuXG4gIHZhciBwYXJzZWRVcmwgPSBfdXJsLmRlZmF1bHQucGFyc2Uob3B0aW9ucy51cmwgfHwgX3VybC5kZWZhdWx0LnJlc29sdmUob3B0aW9ucy5iYXNlVXJsLCBvcHRpb25zLnVyaSksIHRydWUpO1xuXG4gIHBhcnNlZFVybC5zZWFyY2ggPSAoMCwgX3F1ZXJ5c3RyaW5nLnN0cmluZ2lmeSkoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkVXJsLnF1ZXJ5LCBvcHRpb25zLnFzKSk7IC8vIGNyZWF0ZSBhIG5ldyB1cmwgb2JqZWN0IHdpdGggdGhlIG5ldyBxcyBwYXJhbXMsIHRvIGVuc3VyZSB0aGF0IHRoZSBgaHJlZmAgdmFsdWUgY2hhbmdlcyAodG8gdXNlIGxhdGVyIGZvciBwYXJzaW5nIHJlc3BvbnNlKVxuXG4gIHZhciBmaW5hbFVybCA9IF91cmwuZGVmYXVsdC5wYXJzZShwYXJzZWRVcmwuZm9ybWF0KCkpO1xuXG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kID8gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSA6ICdHRVQnO1xuICB4aHIub3BlbihtZXRob2QsIGZpbmFsVXJsLmhyZWYpO1xuICBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpLmZpbHRlcihmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgcmV0dXJuIGhlYWRlci50b0xvd2VyQ2FzZSgpICE9PSAndXNlci1hZ2VudCc7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdGlvbnMuaGVhZGVyc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMuYXV0aCkge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgb3B0aW9ucy5hdXRoLmJlYXJlciA/IFwiYmVhcmVyIFwiLmNvbmNhdChvcHRpb25zLmF1dGguYmVhcmVyKSA6ICdiYXNpYyAnICsgYnRvYShcIlwiLmNvbmNhdChvcHRpb25zLmF1dGgudXNlciwgXCI6XCIpLmNvbmNhdChvcHRpb25zLmF1dGgucGFzcykpKTtcbiAgfVxuXG4gIHZhciByZXF1ZXN0Qm9keTtcblxuICBpZiAob3B0aW9ucy5mb3JtRGF0YSkge1xuICAgIHJlcXVlc3RCb2R5ID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucy5mb3JtRGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEJvZHkuYXBwZW5kKGtleSwgb3B0aW9ucy5mb3JtRGF0YVtrZXldKTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmZvcm0pIHtcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuZm9ybSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0Qm9keS5hcHBlbmQoa2V5LCBvcHRpb25zLmZvcm1ba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ211bHRpcGFydC9mb3JtLWRhdGEnKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvcm0pIHtcbiAgICByZXF1ZXN0Qm9keSA9ICgwLCBfcXVlcnlzdHJpbmcuc3RyaW5naWZ5KShvcHRpb25zLmZvcm0pO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5qc29uKSB7XG4gICAgcmVxdWVzdEJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3RCb2R5ID0gb3B0aW9ucy5ib2R5O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBfUHJvbWlzZS5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSB7XG4gICAgb25DYW5jZWwoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHhoci5hYm9ydCgpO1xuICAgIH0pO1xuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzdWNjZXNzID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwO1xuICAgICAgdmFyIHNldHRsZUZ1bmMgPSBzdWNjZXNzID8gcmVzb2x2ZSA6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChPYmplY3QuYXNzaWduKG5ldyBfZXJyb3JzLlN0YXR1c0NvZGVFcnJvcihfdGhpcy5zdGF0dXMgKyAnJyksIGVycikpO1xuICAgICAgfTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXMsXG4gICAgICAgIGJvZHk6IChvcHRpb25zLmpzb24gPyB0cnlQYXJzZUpzb24gOiBub29wKSh4aHIucmVzcG9uc2UpLFxuICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSxcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICB1cmk6IGZpbmFsVXJsXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2V0dGxlRnVuYyhvcHRpb25zLnRyYW5zZm9ybShyZXNwb25zZS5ib2R5LCByZXNwb25zZSkpO1xuICAgICAgfSBlbHNlIGlmICghc3VjY2VzcyB8fCBvcHRpb25zLnJlc29sdmVXaXRoRnVsbFJlc3BvbnNlKSB7XG4gICAgICAgIHNldHRsZUZ1bmMocmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dGxlRnVuYyhyZXNwb25zZS5ib2R5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KE9iamVjdC5hc3NpZ24obmV3IF9lcnJvcnMuUmVxdWVzdEVycm9yKCksIGVycikpO1xuICAgIH07XG5cbiAgICB4aHIuc2VuZChyZXF1ZXN0Qm9keSk7XG4gIH0pLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0IHx8IE1hdGgucG93KDIsIDMxKSAtIDEsICdFcnJvcjogRVRJTUVET1VUJykuY2F0Y2goX1Byb21pc2UuZGVmYXVsdC5UaW1lb3V0RXJyb3IsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICB4aHIuYWJvcnQoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/dist/xhr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/safe-buffer/index.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsY0FBYztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/index.js":
/*!********************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst WebSocket = __webpack_require__(/*! ./lib/WebSocket */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/WebSocket.js\");\n\nWebSocket.Server = __webpack_require__(/*! ./lib/WebSocketServer */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/WebSocketServer.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/Receiver */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/Sender */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Sender.js\");\n\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsdUZBQWlCOztBQUUzQyxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBdUI7QUFDbEQscUJBQXFCLG1CQUFPLENBQUMscUZBQWdCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGlGQUFjOztBQUV6QyIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9ub2RlX21vZHVsZXMvd3MvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB3czogYSBub2RlLmpzIHdlYnNvY2tldCBjbGllbnRcbiAqIENvcHlyaWdodChjKSAyMDExIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi9XZWJTb2NrZXQnKTtcblxuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL1dlYlNvY2tldFNlcnZlcicpO1xuV2ViU29ja2V0LlJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvUmVjZWl2ZXInKTtcbldlYlNvY2tldC5TZW5kZXIgPSByZXF1aXJlKCcuL2xpYi9TZW5kZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/BufferUtil.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/BufferUtil.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nconst concat = (list, totalLength) => {\n  const target = Buffer.allocUnsafe(totalLength);\n  var offset = 0;\n\n  for (var i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(target, offset);\n    offset += buf.length;\n  }\n\n  return target;\n};\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"(rsc)/./node_modules/bufferutil/index.js\");\n\n  module.exports = Object.assign({ concat }, bufferUtil.BufferUtil || bufferUtil);\n} catch (e) /* istanbul ignore next */ {\n  /**\n   * Masks a buffer using the given mask.\n   *\n   * @param {Buffer} source The buffer to mask\n   * @param {Buffer} mask The mask to use\n   * @param {Buffer} output The buffer where to store the result\n   * @param {Number} offset The offset at which to start writing\n   * @param {Number} length The number of bytes to mask.\n   * @public\n   */\n  const mask = (source, mask, output, offset, length) => {\n    for (var i = 0; i < length; i++) {\n      output[offset + i] = source[i] ^ mask[i & 3];\n    }\n  };\n\n  /**\n   * Unmasks a buffer using the given mask.\n   *\n   * @param {Buffer} buffer The buffer to unmask\n   * @param {Buffer} mask The mask to use\n   * @public\n   */\n  const unmask = (buffer, mask) => {\n    // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n    const length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] ^= mask[i & 3];\n    }\n  };\n\n  module.exports = { concat, mask, unmask };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9CdWZmZXJVdGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQWE7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsNERBQVk7O0FBRXpDLG1DQUFtQyxRQUFRO0FBQzNDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL25vZGVfbW9kdWxlcy93cy9saWIvQnVmZmVyVXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNhZmVCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpO1xuXG5jb25zdCBCdWZmZXIgPSBzYWZlQnVmZmVyLkJ1ZmZlcjtcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgYnVmZmVycyBpbnRvIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoIFRoZSB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiB0aGUgbGlzdFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5jb25zdCBjb25jYXQgPSAobGlzdCwgdG90YWxMZW5ndGgpID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICBidWYuY29weSh0YXJnZXQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudHJ5IHtcbiAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24oeyBjb25jYXQgfSwgYnVmZmVyVXRpbC5CdWZmZXJVdGlsIHx8IGJ1ZmZlclV0aWwpO1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICAvKipcbiAgICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29uc3QgbWFzayA9IChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAgICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbnN0IHVubWFzayA9IChidWZmZXIsIG1hc2spID0+IHtcbiAgICAvLyBSZXF1aXJlZCB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzkwMDYgaXMgcmVzb2x2ZWQuXG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0geyBjb25jYXQsIG1hc2ssIHVubWFzayB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/BufferUtil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Constants.js":
/*!****************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/Constants.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\nexports.BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nexports.GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nexports.EMPTY_BUFFER = Buffer.alloc(0);\nexports.NOOP = () => {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9Db25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQWE7O0FBRXhDOztBQUVBLG9CQUFvQjtBQUNwQixZQUFZO0FBQ1osb0JBQW9CO0FBQ3BCLFlBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9Db25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzYWZlQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKTtcblxuY29uc3QgQnVmZmVyID0gc2FmZUJ1ZmZlci5CdWZmZXI7XG5cbmV4cG9ydHMuQklOQVJZX1RZUEVTID0gWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddO1xuZXhwb3J0cy5HVUlEID0gJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMSc7XG5leHBvcnRzLkVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYygwKTtcbmV4cG9ydHMuTk9PUCA9ICgpID0+IHt9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/ErrorCodes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/ErrorCodes.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nmodule.exports = {\n  isValidErrorCode: function (code) {\n    return (code >= 1000 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006) ||\n      (code >= 3000 && code <= 4999);\n  },\n  1000: 'normal',\n  1001: 'going away',\n  1002: 'protocol error',\n  1003: 'unsupported data',\n  1004: 'reserved',\n  1005: 'reserved for extensions',\n  1006: 'reserved for extensions',\n  1007: 'inconsistent or invalid data',\n  1008: 'policy violation',\n  1009: 'message too big',\n  1010: 'extension handshake missing',\n  1011: 'an unexpected condition prevented the request from being fulfilled',\n  1012: 'service restart',\n  1013: 'try again later'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9FcnJvckNvZGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL25vZGVfbW9kdWxlcy93cy9saWIvRXJyb3JDb2Rlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1ZhbGlkRXJyb3JDb2RlOiBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gMTAxMyAmJiBjb2RlICE9PSAxMDA0ICYmIGNvZGUgIT09IDEwMDUgJiYgY29kZSAhPT0gMTAwNikgfHxcbiAgICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbiAgfSxcbiAgMTAwMDogJ25vcm1hbCcsXG4gIDEwMDE6ICdnb2luZyBhd2F5JyxcbiAgMTAwMjogJ3Byb3RvY29sIGVycm9yJyxcbiAgMTAwMzogJ3Vuc3VwcG9ydGVkIGRhdGEnLFxuICAxMDA0OiAncmVzZXJ2ZWQnLFxuICAxMDA1OiAncmVzZXJ2ZWQgZm9yIGV4dGVuc2lvbnMnLFxuICAxMDA2OiAncmVzZXJ2ZWQgZm9yIGV4dGVuc2lvbnMnLFxuICAxMDA3OiAnaW5jb25zaXN0ZW50IG9yIGludmFsaWQgZGF0YScsXG4gIDEwMDg6ICdwb2xpY3kgdmlvbGF0aW9uJyxcbiAgMTAwOTogJ21lc3NhZ2UgdG9vIGJpZycsXG4gIDEwMTA6ICdleHRlbnNpb24gaGFuZHNoYWtlIG1pc3NpbmcnLFxuICAxMDExOiAnYW4gdW5leHBlY3RlZCBjb25kaXRpb24gcHJldmVudGVkIHRoZSByZXF1ZXN0IGZyb20gYmVpbmcgZnVsZmlsbGVkJyxcbiAgMTAxMjogJ3NlcnZpY2UgcmVzdGFydCcsXG4gIDEwMTM6ICd0cnkgYWdhaW4gbGF0ZXInXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/ErrorCodes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/EventTarget.js":
/*!******************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/EventTarget.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor (type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor (data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor (code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor (target) {\n    super('open', target);\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener (method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage (data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose (code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError (event) {\n      event.type = 'error';\n      event.target = this;\n      listener.call(this, event);\n    }\n\n    function onOpen () {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener (method, listener) {\n    const listeners = this.listeners(method);\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9FdmVudFRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25ELGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9ub2RlX21vZHVsZXMvd3MvbGliL0V2ZW50VGFyZ2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhcyBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIHJlY2VpdmVkIGRhdGFcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRhdGEsIHRhcmdldCkge1xuICAgIHN1cGVyKCdtZXNzYWdlJywgdGFyZ2V0KTtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBiZWluZyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvbiBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb2RlLCByZWFzb24sIHRhcmdldCkge1xuICAgIHN1cGVyKCdjbG9zZScsIHRhcmdldCk7XG5cbiAgICB0aGlzLndhc0NsZWFuID0gdGFyZ2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGFyZ2V0Ll9jbG9zZUZyYW1lU2VudDtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIG9wZW4gZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE9wZW5FdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgT3BlbkV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXMgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCkge1xuICAgIHN1cGVyKCdvcGVuJywgdGFyZ2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyIChtZXRob2QsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gb25NZXNzYWdlIChkYXRhKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBNZXNzYWdlRXZlbnQoZGF0YSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xvc2UgKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IENsb3NlRXZlbnQoY29kZSwgbWVzc2FnZSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRXJyb3IgKGV2ZW50KSB7XG4gICAgICBldmVudC50eXBlID0gJ2Vycm9yJztcbiAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk9wZW4gKCkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgT3BlbkV2ZW50KHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kID09PSAnbWVzc2FnZScpIHtcbiAgICAgIG9uTWVzc2FnZS5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXMub24obWV0aG9kLCBvbk1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpcy5vbihtZXRob2QsIG9uQ2xvc2UpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAnZXJyb3InKSB7XG4gICAgICBvbkVycm9yLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgdGhpcy5vbihtZXRob2QsIG9uRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSAnb3BlbicpIHtcbiAgICAgIG9uT3Blbi5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXMub24obWV0aG9kLCBvbk9wZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyIChtZXRob2QsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lciB8fCBsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/EventTarget.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Extensions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/Extensions.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push (dest, name, elem) {\n  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);\n  else dest[name] = [elem];\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse (header) {\n  const offers = {};\n\n  if (header === undefined || header === '') return offers;\n\n  var params = {};\n  var mustUnescape = false;\n  var isEscaping = false;\n  var inQuotes = false;\n  var extensionName;\n  var paramName;\n  var start = -1;\n  var end = -1;\n\n  for (var i = 0; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20/* ' ' */|| code === 0x09/* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b/* ';' */ || code === 0x2c/* ',' */) {\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = {};\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new Error(`unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d/* '=' */&& start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new Error(`unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new Error(`unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22/* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c/* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new Error(`unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\n\n        if (end === -1) end = i;\n        var value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new Error(`unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) throw new Error('unexpected end of input');\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, {});\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Serializes a parsed `Sec-WebSocket-Extensions` header to a string.\n *\n * @param {Object} value The object to format\n * @return {String} A string representing the given value\n * @public\n */\nfunction format (value) {\n  return Object.keys(value).map((token) => {\n    var paramsList = value[token];\n    if (!Array.isArray(paramsList)) paramsList = [paramsList];\n    return paramsList.map((params) => {\n      return [token].concat(Object.keys(params).map((k) => {\n        var p = params[k];\n        if (!Array.isArray(p)) p = [p];\n        return p.map((v) => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\n\nmodule.exports = { format, parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9FeHRlbnNpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUSwyQkFBMkI7QUFDbkMsMkVBQTJFLEVBQUU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUix5REFBeUQsRUFBRTtBQUMzRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLDJFQUEyRSxFQUFFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlEQUF5RCxFQUFFO0FBQzNEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLDJEQUEyRCxFQUFFO0FBQzdEO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLDJFQUEyRSxFQUFFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUix5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFLEdBQUcsRUFBRSxXQUFXO0FBQ2xFLE9BQU8sV0FBVztBQUNsQixLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9ub2RlX21vZHVsZXMvd3MvbGliL0V4dGVuc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoIChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVzdCwgbmFtZSkpIGRlc3RbbmFtZV0ucHVzaChlbGVtKTtcbiAgZWxzZSBkZXN0W25hbWVdID0gW2VsZW1dO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UgKGhlYWRlcikge1xuICBjb25zdCBvZmZlcnMgPSB7fTtcblxuICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgfHwgaGVhZGVyID09PSAnJykgcmV0dXJuIG9mZmVycztcblxuICB2YXIgcGFyYW1zID0ge307XG4gIHZhciBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgdmFyIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgdmFyIGluUXVvdGVzID0gZmFsc2U7XG4gIHZhciBleHRlbnNpb25OYW1lO1xuICB2YXIgcGFyYW1OYW1lO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAvKiAnICcgKi98fCBjb2RlID09PSAweDA5LyogJ1xcdCcgKi8pIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiLyogJzsnICovIHx8IGNvZGUgPT09IDB4MmMvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgcHVzaChwYXJhbXMsIGhlYWRlci5zbGljZShzdGFydCwgZW5kKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QvKiAnPScgKi8mJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1Yy8qICdcXCcgKi8pIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICYmIGhlYWRlci5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHgzZCkge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSAtMSAmJiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcykgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuXG4gIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICBjb25zdCB0b2tlbiA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwge30pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgcGFyc2VkIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIG9iamVjdCB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBmb3JtYXQgKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKCh0b2tlbikgPT4ge1xuICAgIHZhciBwYXJhbXNMaXN0ID0gdmFsdWVbdG9rZW5dO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXNMaXN0KSkgcGFyYW1zTGlzdCA9IFtwYXJhbXNMaXN0XTtcbiAgICByZXR1cm4gcGFyYW1zTGlzdC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgcmV0dXJuIFt0b2tlbl0uY29uY2F0KE9iamVjdC5rZXlzKHBhcmFtcykubWFwKChrKSA9PiB7XG4gICAgICAgIHZhciBwID0gcGFyYW1zW2tdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocCkpIHAgPSBbcF07XG4gICAgICAgIHJldHVybiBwLm1hcCgodikgPT4gdiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkuam9pbignOyAnKTtcbiAgICAgIH0pKS5qb2luKCc7ICcpO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gIH0pLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Extensions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/PerMessageDeflate.js":
/*!************************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/PerMessageDeflate.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js\");\nconst Limiter = __webpack_require__(/*! async-limiter */ \"(rsc)/./node_modules/async-limiter/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/BufferUtil.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\n\nconst kWriteInProgress = Symbol('write-in-progress');\nconst kPendingClose = Symbol('pending-close');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\nconst kOwner = Symbol('owner');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Number} options.level The value of zlib's `level` param\n   * @param {Number} options.memLevel The value of zlib's `memLevel` param\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor (options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined\n      ? this._options.threshold\n      : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined\n        ? this._options.concurrencyLimit\n        : 10;\n      zlibLimiter = new Limiter({ concurrency });\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName () {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create extension parameters offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer () {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept extension offer.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept (paramsList) {\n    paramsList = this.normalizeParams(paramsList);\n\n    var params;\n    if (this._isServer) {\n      params = this.acceptAsServer(paramsList);\n    } else {\n      params = this.acceptAsClient(paramsList);\n    }\n\n    this.params = params;\n    return params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup () {\n    if (this._inflate) {\n      if (this._inflate[kWriteInProgress]) {\n        this._inflate[kPendingClose] = true;\n      } else {\n        this._inflate.close();\n        this._inflate = null;\n      }\n    }\n    if (this._deflate) {\n      if (this._deflate[kWriteInProgress]) {\n        this._deflate[kPendingClose] = true;\n      } else {\n        this._deflate.close();\n        this._deflate = null;\n      }\n    }\n  }\n\n  /**\n   * Accept extension offer from client.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer (paramsList) {\n    const accepted = {};\n    const result = paramsList.some((params) => {\n      if (\n        (this._options.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (this._options.serverMaxWindowBits === false &&\n          params.server_max_window_bits) ||\n        (typeof this._options.serverMaxWindowBits === 'number' &&\n          typeof params.server_max_window_bits === 'number' &&\n          this._options.serverMaxWindowBits > params.server_max_window_bits) ||\n        (typeof this._options.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return;\n      }\n\n      if (\n        this._options.serverNoContextTakeover ||\n        params.server_no_context_takeover\n      ) {\n        accepted.server_no_context_takeover = true;\n      }\n      if (\n        this._options.clientNoContextTakeover ||\n        (this._options.clientNoContextTakeover !== false &&\n          params.client_no_context_takeover)\n      ) {\n        accepted.client_no_context_takeover = true;\n      }\n      if (typeof this._options.serverMaxWindowBits === 'number') {\n        accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n      } else if (typeof params.server_max_window_bits === 'number') {\n        accepted.server_max_window_bits = params.server_max_window_bits;\n      }\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n      } else if (\n        this._options.clientMaxWindowBits !== false &&\n        typeof params.client_max_window_bits === 'number'\n      ) {\n        accepted.client_max_window_bits = params.client_max_window_bits;\n      }\n      return true;\n    });\n\n    if (!result) throw new Error(\"Doesn't support the offered configuration\");\n\n    return accepted;\n  }\n\n  /**\n   * Accept extension response from server.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient (paramsList) {\n    const params = paramsList[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\n    }\n\n    if (\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        (!params.client_max_window_bits ||\n          params.client_max_window_bits > this._options.clientMaxWindowBits)) ||\n      (this._options.clientMaxWindowBits === false &&\n        params.client_max_window_bits)\n    ) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize extensions parameters.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Array} Normalized extensions parameters\n   * @private\n   */\n  normalizeParams (paramsList) {\n    return paramsList.map((params) => {\n      Object.keys(params).forEach((key) => {\n        var value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Multiple extension parameters for ${key}`);\n        }\n\n        value = value[0];\n\n        switch (key) {\n          case 'server_no_context_takeover':\n          case 'client_no_context_takeover':\n            if (value !== true) {\n              throw new Error(`invalid extension parameter value for ${key} (${value})`);\n            }\n            params[key] = true;\n            break;\n          case 'server_max_window_bits':\n          case 'client_max_window_bits':\n            if (typeof value === 'string') {\n              value = parseInt(value, 10);\n              if (\n                Number.isNaN(value) ||\n                value < zlib.Z_MIN_WINDOWBITS ||\n                value > zlib.Z_MAX_WINDOWBITS\n              ) {\n                throw new Error(`invalid extension parameter value for ${key} (${value})`);\n              }\n            }\n            if (!this._isServer && value === true) {\n              throw new Error(`Missing extension parameter value for ${key}`);\n            }\n            params[key] = value;\n            break;\n          default:\n            throw new Error(`Not defined extension parameter (${key})`);\n        }\n      });\n      return params;\n    });\n  }\n\n  /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress (data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress (data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress (data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number'\n        ? zlib.Z_DEFAULT_WINDOWBITS\n        : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({ windowBits });\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate[kOwner] = this;\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n    this._inflate[kWriteInProgress] = true;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\n        this._inflate[kPendingClose]\n      ) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kWriteInProgress] = false;\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress (data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number'\n        ? zlib.Z_DEFAULT_WINDOWBITS\n        : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        memLevel: this._options.memLevel,\n        level: this._options.level,\n        flush: zlib.Z_SYNC_FLUSH,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\n      // it is made after it has already been closed. This cannot happen here,\n      // so we only add a listener for the `'data'` event.\n      //\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kWriteInProgress] = true;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      var data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\n        this._deflate[kPendingClose]\n      ) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kWriteInProgress] = false;\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData (chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData (chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kOwner]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kOwner]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new Error('max payload size exceeded');\n  this[kError].closeCode = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError (err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kOwner]._inflate = null;\n  this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9QZXJNZXNzYWdlRGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBYTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBZTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLG1CQUFtQixtQkFBTyxDQUFDLHFGQUFjOztBQUV6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIs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O0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9QZXJNZXNzYWdlRGVmbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNhZmVCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJ2FzeW5jLWxpbWl0ZXInKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL0J1ZmZlclV0aWwnKTtcblxuY29uc3QgQnVmZmVyID0gc2FmZUJ1ZmZlci5CdWZmZXI7XG5cbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3QgRU1QVFlfQkxPQ0sgPSBCdWZmZXIuZnJvbShbMHgwMF0pO1xuXG5jb25zdCBrV3JpdGVJblByb2dyZXNzID0gU3ltYm9sKCd3cml0ZS1pbi1wcm9ncmVzcycpO1xuY29uc3Qga1BlbmRpbmdDbG9zZSA9IFN5bWJvbCgncGVuZGluZy1jbG9zZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5jb25zdCBrT3duZXIgPSBTeW1ib2woJ293bmVyJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciBSZXF1ZXN0L2FjY2VwdCBkaXNhYmxpbmdcbiAgICogICAgIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciBBZHZlcnRpc2UvYWNrbm93bGVkZ2VcbiAgICogICAgIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IG9wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5sZXZlbCBUaGUgdmFsdWUgb2YgemxpYidzIGBsZXZlbGAgcGFyYW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWVtTGV2ZWwgVGhlIHZhbHVlIG9mIHpsaWIncyBgbWVtTGV2ZWxgIHBhcmFtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnRocmVzaG9sZCBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2ggbWVzc2FnZXNcbiAgICogICAgIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0IFRoZSBudW1iZXIgb2YgY29uY3VycmVudCBjYWxscyB0b1xuICAgKiAgICAgemxpYlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2VydmVyIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvciBjbGllbnRcbiAgICogICAgIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFBheWxvYWQgVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWRcbiAgICAgID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGRcbiAgICAgIDogMTAyNDtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG5cbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKHsgY29uY3VycmVuY3kgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUgKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb2ZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb2ZmZXIgKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGV4dGVuc2lvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zTGlzdCBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0IChwYXJhbXNMaXN0KSB7XG4gICAgcGFyYW1zTGlzdCA9IHRoaXMubm9ybWFsaXplUGFyYW1zKHBhcmFtc0xpc3QpO1xuXG4gICAgdmFyIHBhcmFtcztcbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIHBhcmFtcyA9IHRoaXMuYWNjZXB0QXNTZXJ2ZXIocGFyYW1zTGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcyA9IHRoaXMuYWNjZXB0QXNDbGllbnQocGFyYW1zTGlzdCk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlW2tXcml0ZUluUHJvZ3Jlc3NdKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1BlbmRpbmdDbG9zZV0gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9kZWZsYXRlW2tXcml0ZUluUHJvZ3Jlc3NdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1BlbmRpbmdDbG9zZV0gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGV4dGVuc2lvbiBvZmZlciBmcm9tIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zTGlzdCBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyIChwYXJhbXNMaXN0KSB7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSB7fTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJhbXNMaXN0LnNvbWUoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XG4gICAgICAgICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpIHx8XG4gICAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgIHR5cGVvZiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykgfHxcbiAgICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyIHx8XG4gICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICAgKSB7XG4gICAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciB8fFxuICAgICAgICAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciAhPT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIpXG4gICAgICApIHtcbiAgICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgIT09IGZhbHNlICYmXG4gICAgICAgIHR5cGVvZiBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gJ251bWJlcidcbiAgICAgICkge1xuICAgICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJEb2Vzbid0IHN1cHBvcnQgdGhlIG9mZmVyZWQgY29uZmlndXJhdGlvblwiKTtcblxuICAgIHJldHVybiBhY2NlcHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgZXh0ZW5zaW9uIHJlc3BvbnNlIGZyb20gc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNMaXN0IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQgKHBhcmFtc0xpc3QpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBwYXJhbXNMaXN0WzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyB8fFxuICAgICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSkgfHxcbiAgICAgICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlICYmXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIicpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGV4dGVuc2lvbnMgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zTGlzdCBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gTm9ybWFsaXplZCBleHRlbnNpb25zIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyAocGFyYW1zTGlzdCkge1xuICAgIHJldHVybiBwYXJhbXNMaXN0Lm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIGZvciAke2tleX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3Zlcic6XG4gICAgICAgICAgY2FzZSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInOlxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBleHRlbnNpb24gcGFyYW1ldGVyIHZhbHVlIGZvciAke2tleX0gKCR7dmFsdWV9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VydmVyX21heF93aW5kb3dfYml0cyc6XG4gICAgICAgICAgY2FzZSAnY2xpZW50X21heF93aW5kb3dfYml0cyc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgPCB6bGliLlpfTUlOX1dJTkRPV0JJVFMgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSA+IHpsaWIuWl9NQVhfV0lORE9XQklUU1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZXh0ZW5zaW9uIHBhcmFtZXRlciB2YWx1ZSBmb3IgJHtrZXl9ICgke3ZhbHVlfSlgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1NlcnZlciAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZXh0ZW5zaW9uIHBhcmFtZXRlciB2YWx1ZSBmb3IgJHtrZXl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGRlZmluZWQgZXh0ZW5zaW9uIHBhcmFtZXRlciAoJHtrZXl9KWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkIGJ5IGFzeW5jLWxpbWl0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWNvbXByZXNzIChkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIucHVzaCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQgYnkgYXN5bmMtbGltaXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyAoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLnB1c2goKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzIChkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9IHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9pbmZsYXRlID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KHsgd2luZG93Qml0cyB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrT3duZXJdID0gdGhpcztcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX2luZmxhdGVba1dyaXRlSW5Qcm9ncmVzc10gPSB0cnVlO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB8fFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tQZW5kaW5nQ2xvc2VdXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1dyaXRlSW5Qcm9ncmVzc10gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzIChkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCBFTVBUWV9CTE9DSyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9IHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgbWVtTGV2ZWw6IHRoaXMuX29wdGlvbnMubWVtTGV2ZWwsXG4gICAgICAgIGxldmVsOiB0aGlzLl9vcHRpb25zLmxldmVsLFxuICAgICAgICBmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgLy9cbiAgICAgIC8vIGB6bGliLkRlZmxhdGVSYXdgIGVtaXRzIGFuIGAnZXJyb3InYCBldmVudCBvbmx5IHdoZW4gYW4gYXR0ZW1wdCB0byB1c2VcbiAgICAgIC8vIGl0IGlzIG1hZGUgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuIFRoaXMgY2Fubm90IGhhcHBlbiBoZXJlLFxuICAgICAgLy8gc28gd2Ugb25seSBhZGQgYSBsaXN0ZW5lciBmb3IgdGhlIGAnZGF0YSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tXcml0ZUluUHJvZ3Jlc3NdID0gdHJ1ZTtcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgaWYgKFxuICAgICAgICAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHx8XG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1BlbmRpbmdDbG9zZV1cbiAgICAgICkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrV3JpdGVJblByb2dyZXNzXSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEgKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEgKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba093bmVyXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trT3duZXJdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBFcnJvcignbWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY2xvc2VDb2RlID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IgKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba093bmVyXS5faW5mbGF0ZSA9IG51bGw7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/PerMessageDeflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Receiver.js":
/*!***************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/Receiver.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/PerMessageDeflate.js\");\nconst isValidUTF8 = __webpack_require__(/*! ./Validation */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Validation.js\");\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/BufferUtil.js\");\nconst ErrorCodes = __webpack_require__(/*! ./ErrorCodes */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/ErrorCodes.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Constants.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n */\nclass Receiver {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */\n  constructor (extensions, maxPayload, binaryType) {\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._mask = null;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._cleanupCallback = null;\n    this._hadError = false;\n    this._dead = false;\n    this._loop = false;\n\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    this.onping = null;\n    this.onpong = null;\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */\n  readBuffer (bytes) {\n    var offset = 0;\n    var dst;\n    var l;\n\n    this._bufferedBytes -= bytes;\n\n    if (bytes === this._buffers[0].length) return this._buffers.shift();\n\n    if (bytes < this._buffers[0].length) {\n      dst = this._buffers[0].slice(0, bytes);\n      this._buffers[0] = this._buffers[0].slice(bytes);\n      return dst;\n    }\n\n    dst = Buffer.allocUnsafe(bytes);\n\n    while (bytes > 0) {\n      l = this._buffers[0].length;\n\n      if (bytes >= l) {\n        this._buffers[0].copy(dst, offset);\n        offset += l;\n        this._buffers.shift();\n      } else {\n        this._buffers[0].copy(dst, offset, 0, bytes);\n        this._buffers[0] = this._buffers[0].slice(bytes);\n      }\n\n      bytes -= l;\n    }\n\n    return dst;\n  }\n\n  /**\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\n   * calls `cleanup` if necessary.\n   *\n   * @param {Number} n The number of bytes to check against\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n   * @private\n   */\n  hasBufferedBytes (n) {\n    if (this._bufferedBytes >= n) return true;\n\n    this._loop = false;\n    if (this._dead) this.cleanup(this._cleanupCallback);\n    return false;\n  }\n\n  /**\n   * Adds new data to the parser.\n   *\n   * @public\n   */\n  add (data) {\n    if (this._dead) return;\n\n    this._bufferedBytes += data.length;\n    this._buffers.push(data);\n    this.startLoop();\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @private\n   */\n  startLoop () {\n    this._loop = true;\n\n    while (this._loop) {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData();\n          break;\n        default: // `INFLATING`\n          this._loop = false;\n      }\n    }\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @private\n   */\n  getInfo () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    const buf = this.readBuffer(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this.error(new Error('RSV1 must be clear'), 1002);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (!this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      } else {\n        this._opcode = this._fragmented;\n      }\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this.error(new Error('FIN must be set'), 1002);\n        return;\n      }\n\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this.error(new Error('invalid payload length'), 1002);\n        return;\n      }\n    } else {\n      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @private\n   */\n  getPayloadLength16 () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n    this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @private\n   */\n  getPayloadLength64 () {\n    if (!this.hasBufferedBytes(8)) return;\n\n    const buf = this.readBuffer(8);\n    const num = buf.readUInt32BE(0, true);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this.error(new Error('max payload size exceeded'), 1009);\n      return;\n    }\n\n    this._payloadLength = (num * Math.pow(2, 32)) + buf.readUInt32BE(4, true);\n    this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @private\n   */\n  haveLength () {\n    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n      return;\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask () {\n    if (!this.hasBufferedBytes(4)) return;\n\n    this._mask = this.readBuffer(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @private\n   */\n  getData () {\n    var data = constants.EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (!this.hasBufferedBytes(this._payloadLength)) return;\n\n      data = this.readBuffer(this._payloadLength);\n      if (this._masked) bufferUtil.unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data);\n    } else if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data);\n    } else if (this.pushFragment(data)) {\n      this.dataMessage();\n    }\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @private\n   */\n  decompress (data) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) {\n        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n        return;\n      }\n\n      if (this.pushFragment(buf)) this.dataMessage();\n      this.startLoop();\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @private\n   */\n  dataMessage () {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = toBuffer(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.onmessage(data);\n      } else {\n        const buf = toBuffer(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onmessage(buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @private\n   */\n  controlMessage (data) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this.onclose(1000, '');\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      } else if (data.length === 1) {\n        this.error(new Error('invalid payload length'), 1002);\n      } else {\n        const code = data.readUInt16BE(0, true);\n\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          this.error(new Error(`invalid status code: ${code}`), 1002);\n          return;\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onclose(code, buf.toString());\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      }\n\n      return;\n    }\n\n    if (this._opcode === 0x09) this.onping(data);\n    else this.onpong(data);\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles an error.\n   *\n   * @param {Error} err The error\n   * @param {Number} code Close code\n   * @private\n   */\n  error (err, code) {\n    this.onerror(err, code);\n    this._hadError = true;\n    this._loop = false;\n    this.cleanup(this._cleanupCallback);\n  }\n\n  /**\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n   *\n   * @param {Number} length Payload length\n   * @private\n   */\n  maxPayloadExceeded (length) {\n    if (length === 0 || this._maxPayload < 1) return false;\n\n    const fullLength = this._totalPayloadLength + length;\n\n    if (fullLength <= this._maxPayload) {\n      this._totalPayloadLength = fullLength;\n      return false;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return true;\n  }\n\n  /**\n   * Appends a fragment in the fragments array after checking that the sum of\n   * fragment lengths does not exceed `maxPayload`.\n   *\n   * @param {Buffer} fragment The fragment to add\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n   * @private\n   */\n  pushFragment (fragment) {\n    if (fragment.length === 0) return true;\n\n    const totalLength = this._messageLength + fragment.length;\n\n    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n      this._messageLength = totalLength;\n      this._fragments.push(fragment);\n      return true;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return false;\n  }\n\n  /**\n   * Releases resources used by the receiver.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  cleanup (cb) {\n    this._dead = true;\n\n    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n      this._cleanupCallback = cb;\n    } else {\n      this._extensions = null;\n      this._fragments = null;\n      this._buffers = null;\n      this._mask = null;\n\n      this._cleanupCallback = null;\n      this.onmessage = null;\n      this.onclose = null;\n      this.onerror = null;\n      this.onping = null;\n      this.onpong = null;\n\n      if (cb) cb();\n    }\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */\nfunction toBuffer (fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */\nfunction toArrayBuffer (buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9SZWNlaXZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLG9GQUFhOztBQUV4QywwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBcUI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWM7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMscUZBQWM7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMscUZBQWM7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsbUZBQWE7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhDQUE4QyxhQUFhO0FBQzNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9ub2RlX21vZHVsZXMvd3MvbGliL1JlY2VpdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogd3M6IGEgbm9kZS5qcyB3ZWJzb2NrZXQgY2xpZW50XG4gKiBDb3B5cmlnaHQoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9QZXJNZXNzYWdlRGVmbGF0ZScpO1xuY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCcuL1ZhbGlkYXRpb24nKTtcbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL0J1ZmZlclV0aWwnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSByZXF1aXJlKCcuL0Vycm9yQ29kZXMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5cbmNvbnN0IEJ1ZmZlciA9IHNhZmVCdWZmZXIuQnVmZmVyO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUmVjZWl2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJpbmFyeVR5cGUgVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZXh0ZW5zaW9ucywgbWF4UGF5bG9hZCwgYmluYXJ5VHlwZSkge1xuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBiaW5hcnlUeXBlIHx8IGNvbnN0YW50cy5CSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX21hc2sgPSBudWxsO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fY2xlYW51cENhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuX2RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG5cbiAgICB0aGlzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25waW5nID0gbnVsbDtcbiAgICB0aGlzLm9ucG9uZyA9IG51bGw7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGJ5dGVzIGZyb20gdGhlIGF2YWlsYWJsZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZXMgVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gQ29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlYWRCdWZmZXIgKGJ5dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGRzdDtcbiAgICB2YXIgbDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gYnl0ZXM7XG5cbiAgICBpZiAoYnl0ZXMgPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKGJ5dGVzIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGRzdCA9IHRoaXMuX2J1ZmZlcnNbMF0uc2xpY2UoMCwgYnl0ZXMpO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IHRoaXMuX2J1ZmZlcnNbMF0uc2xpY2UoYnl0ZXMpO1xuICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cbiAgICBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpO1xuXG4gICAgd2hpbGUgKGJ5dGVzID4gMCkge1xuICAgICAgbCA9IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoO1xuXG4gICAgICBpZiAoYnl0ZXMgPj0gbCkge1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdLmNvcHkoZHN0LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gbDtcbiAgICAgICAgdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXS5jb3B5KGRzdCwgb2Zmc2V0LCAwLCBieXRlcyk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSB0aGlzLl9idWZmZXJzWzBdLnNsaWNlKGJ5dGVzKTtcbiAgICAgIH1cblxuICAgICAgYnl0ZXMgLT0gbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbnVtYmVyIG9mIGJ1ZmZlcmVkIGJ5dGVzIGlzIGJpZ2dlciBvciBlcXVhbCB0aGFuIGBuYCBhbmRcbiAgICogY2FsbHMgYGNsZWFudXBgIGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjaGVjayBhZ2FpbnN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmZmVyZWRCeXRlcyA+PSBuYCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNCdWZmZXJlZEJ5dGVzIChuKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPj0gbikgcmV0dXJuIHRydWU7XG5cbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2RlYWQpIHRoaXMuY2xlYW51cCh0aGlzLl9jbGVhbnVwQ2FsbGJhY2spO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoZSBwYXJzZXIuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZCAoZGF0YSkge1xuICAgIGlmICh0aGlzLl9kZWFkKSByZXR1cm47XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChkYXRhKTtcbiAgICB0aGlzLnN0YXJ0TG9vcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wICgpIHtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIHdoaWxlICh0aGlzLl9sb29wKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIGBJTkZMQVRJTkdgXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQnVmZmVyZWRCeXRlcygyKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicpLCAxMDAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdSU1YxIG11c3QgYmUgY2xlYXInKSwgMTAwMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignUlNWMSBtdXN0IGJlIGNsZWFyJyksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcihgaW52YWxpZCBvcGNvZGU6ICR7dGhpcy5fb3Bjb2RlfWApLCAxMDAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKGBpbnZhbGlkIG9wY29kZTogJHt0aGlzLl9vcGNvZGV9YCksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignRklOIG11c3QgYmUgc2V0JyksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdSU1YxIG11c3QgYmUgY2xlYXInKSwgMTAwMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdpbnZhbGlkIHBheWxvYWQgbGVuZ3RoJyksIDEwMDIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKGBpbnZhbGlkIG9wY29kZTogJHt0aGlzLl9vcGNvZGV9YCksIDEwMDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuXG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcbiAgICBlbHNlIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2ICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQnVmZmVyZWRCeXRlcygyKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMucmVhZEJ1ZmZlcigyKS5yZWFkVUludDE2QkUoMCwgdHJ1ZSk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQgKCkge1xuICAgIGlmICghdGhpcy5oYXNCdWZmZXJlZEJ5dGVzKDgpKSByZXR1cm47XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwLCB0cnVlKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ21heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKSwgMTAwOSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IChudW0gKiBNYXRoLnBvdygyLCAzMikpICsgYnVmLnJlYWRVSW50MzJCRSg0LCB0cnVlKTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aCAoKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA8IDB4MDggJiYgdGhpcy5tYXhQYXlsb2FkRXhjZWVkZWQodGhpcy5fcGF5bG9hZExlbmd0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzayAoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0J1ZmZlcmVkQnl0ZXMoNCkpIHJldHVybjtcblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLnJlYWRCdWZmZXIoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YSAoKSB7XG4gICAgdmFyIGRhdGEgPSBjb25zdGFudHMuRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNCdWZmZXJlZEJ5dGVzKHRoaXMuX3BheWxvYWRMZW5ndGgpKSByZXR1cm47XG5cbiAgICAgIGRhdGEgPSB0aGlzLnJlYWRCdWZmZXIodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSBidWZmZXJVdGlsLnVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykge1xuICAgICAgdGhpcy5jb250cm9sTWVzc2FnZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wdXNoRnJhZ21lbnQoZGF0YSkpIHtcbiAgICAgIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzc2VzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVjb21wcmVzcyAoZGF0YSkge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmRlY29tcHJlc3MoZGF0YSwgdGhpcy5fZmluLCAoZXJyLCBidWYpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5lcnJvcihlcnIsIGVyci5jbG9zZUNvZGUgPT09IDEwMDkgPyAxMDA5IDogMTAwNyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHVzaEZyYWdtZW50KGJ1ZikpIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgICAgIHRoaXMuc3RhcnRMb29wKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlICgpIHtcbiAgICBpZiAodGhpcy5fZmluKSB7XG4gICAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9ubWVzc2FnZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ2ludmFsaWQgdXRmOCBzZXF1ZW5jZScpLCAxMDA3KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9ubWVzc2FnZShidWYudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UgKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5vbmNsb3NlKDEwMDAsICcnKTtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsZWFudXAodGhpcy5fY2xlYW51cENhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ2ludmFsaWQgcGF5bG9hZCBsZW5ndGgnKSwgMTAwMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCFFcnJvckNvZGVzLmlzVmFsaWRFcnJvckNvZGUoY29kZSkpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcihgaW52YWxpZCBzdGF0dXMgY29kZTogJHtjb2RlfWApLCAxMDAyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBkYXRhLnNsaWNlKDIpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdpbnZhbGlkIHV0Zjggc2VxdWVuY2UnKSwgMTAwNyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbmNsb3NlKGNvZGUsIGJ1Zi50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsZWFudXAodGhpcy5fY2xlYW51cENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDkpIHRoaXMub25waW5nKGRhdGEpO1xuICAgIGVsc2UgdGhpcy5vbnBvbmcoZGF0YSk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgQ2xvc2UgY29kZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXJyb3IgKGVyciwgY29kZSkge1xuICAgIHRoaXMub25lcnJvcihlcnIsIGNvZGUpO1xuICAgIHRoaXMuX2hhZEVycm9yID0gdHJ1ZTtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhbnVwKHRoaXMuX2NsZWFudXBDYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHBheWxvYWQgc2l6ZSwgZGlzY29ubmVjdHMgc29ja2V0IHdoZW4gaXQgZXhjZWVkcyBgbWF4UGF5bG9hZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggUGF5bG9hZCBsZW5ndGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1heFBheWxvYWRFeGNlZWRlZCAobGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCB8fCB0aGlzLl9tYXhQYXlsb2FkIDwgMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgZnVsbExlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArIGxlbmd0aDtcblxuICAgIGlmIChmdWxsTGVuZ3RoIDw9IHRoaXMuX21heFBheWxvYWQpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IGZ1bGxMZW5ndGg7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ21heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKSwgMTAwOSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBhIGZyYWdtZW50IGluIHRoZSBmcmFnbWVudHMgYXJyYXkgYWZ0ZXIgY2hlY2tpbmcgdGhhdCB0aGUgc3VtIG9mXG4gICAqIGZyYWdtZW50IGxlbmd0aHMgZG9lcyBub3QgZXhjZWVkIGBtYXhQYXlsb2FkYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBhZGRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBtYXhQYXlsb2FkYCBpcyBub3QgZXhjZWVkZWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHVzaEZyYWdtZW50IChmcmFnbWVudCkge1xuICAgIGlmIChmcmFnbWVudC5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3QgdG90YWxMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoICsgZnJhZ21lbnQubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuX21heFBheWxvYWQgPCAxIHx8IHRvdGFsTGVuZ3RoIDw9IHRoaXMuX21heFBheWxvYWQpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0b3RhbExlbmd0aDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGZyYWdtZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdtYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyksIDEwMDkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyByZXNvdXJjZXMgdXNlZCBieSB0aGUgcmVjZWl2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAgKGNiKSB7XG4gICAgdGhpcy5fZGVhZCA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuX2hhZEVycm9yICYmICh0aGlzLl9sb29wIHx8IHRoaXMuX3N0YXRlID09PSBJTkZMQVRJTkcpKSB7XG4gICAgICB0aGlzLl9jbGVhbnVwQ2FsbGJhY2sgPSBjYjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG51bGw7XG4gICAgICB0aGlzLl9mcmFnbWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgICB0aGlzLl9tYXNrID0gbnVsbDtcblxuICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrID0gbnVsbDtcbiAgICAgIHRoaXMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMub25jbG9zZSA9IG51bGw7XG4gICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5vbnBpbmcgPSBudWxsO1xuICAgICAgdGhpcy5vbnBvbmcgPSBudWxsO1xuXG4gICAgICBpZiAoY2IpIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjZWl2ZXI7XG5cbi8qKlxuICogTWFrZXMgYSBidWZmZXIgZnJvbSBhIGxpc3Qgb2YgZnJhZ21lbnRzLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGZyYWdtZW50cyBUaGUgbGlzdCBvZiBmcmFnbWVudHMgY29tcG9zaW5nIHRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZUxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0J1ZmZlciAoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSB7XG4gIGlmIChmcmFnbWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gZnJhZ21lbnRzWzBdO1xuICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBidWZmZXJVdGlsLmNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICByZXR1cm4gY29uc3RhbnRzLkVNUFRZX0JVRkZFUjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKGJ1Zikge1xuICBpZiAoYnVmLmJ5dGVPZmZzZXQgPT09IDAgJiYgYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Sender.js":
/*!*************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/Sender.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/PerMessageDeflate.js\");\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/BufferUtil.js\");\nconst ErrorCodes = __webpack_require__(/*! ./ErrorCodes */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/ErrorCodes.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Constants.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor (socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame (data, options) {\n    const merge = data.length < 1024 || (options.mask && options.readOnly);\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2, true);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2, true);\n      target.writeUInt32BE(data.length, 6, true);\n    }\n\n    if (!options.mask) {\n      target[1] = payloadLength;\n      if (merge) {\n        data.copy(target, offset);\n        return [target];\n      }\n\n      return [target, data];\n    }\n\n    const mask = crypto.randomBytes(4);\n\n    target[1] = payloadLength | 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      bufferUtil.mask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    bufferUtil.mask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (code, data, mask, cb) {\n    var buf;\n\n    if (code === undefined) {\n      code = 1000;\n    } else if (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code)) {\n      throw new Error('first argument must be a valid error code number');\n    }\n\n    if (data === undefined || data === '') {\n      if (code === 1000) {\n        buf = constants.EMPTY_BUFFER;\n      } else {\n        buf = Buffer.allocUnsafe(2);\n        buf.writeUInt16BE(code, 0, true);\n      }\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0, true);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose (data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  ping (data, mask) {\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, data, mask, readOnly]);\n    } else {\n      this.doPing(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPing (data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  pong (data, mask) {\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, data, mask, readOnly]);\n    } else {\n      this.doPong(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPong (data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send (data, options, cb) {\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = data.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly\n      }), cb);\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch (data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this._deflating = false;\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue () {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue (params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame (list, cb) {\n    if (list.length === 2) {\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer (view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9TZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBYTtBQUN4QyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFxQjtBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBYztBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBYztBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBYTs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZGFtc2hhdy9EZXZlbG9wbWVudC93ZWJzaXRlcy9ob3Rkb2ctZGlhcmllcy9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9TZW5kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB3czogYSBub2RlLmpzIHdlYnNvY2tldCBjbGllbnRcbiAqIENvcHlyaWdodChjKSAyMDExIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzYWZlQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vUGVyTWVzc2FnZURlZmxhdGUnKTtcbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL0J1ZmZlclV0aWwnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSByZXF1aXJlKCcuL0Vycm9yQ29kZXMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5cbmNvbnN0IEJ1ZmZlciA9IHNhZmVCdWZmZXIuQnVmZmVyO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzb2NrZXQsIGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJzdjEgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgUlNWMSBiaXRcbiAgICogQHJldHVybiB7QnVmZmVyW119IFRoZSBmcmFtZWQgZGF0YSBhcyBhIGxpc3Qgb2YgYEJ1ZmZlcmAgaW5zdGFuY2VzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZSAoZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lcmdlID0gZGF0YS5sZW5ndGggPCAxMDI0IHx8IChvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSk7XG4gICAgdmFyIG9mZnNldCA9IG9wdGlvbnMubWFzayA/IDYgOiAyO1xuICAgIHZhciBwYXlsb2FkTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YS5sZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGEubGVuZ3RoLCAyLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoMCwgMiwgdHJ1ZSk7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MzJCRShkYXRhLmxlbmd0aCwgNiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHtcbiAgICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG4gICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgZGF0YS5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gICAgfVxuXG4gICAgY29uc3QgbWFzayA9IGNyeXB0by5yYW5kb21CeXRlcyg0KTtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGggfCAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGJ1ZmZlclV0aWwubWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGJ1ZmZlclV0aWwubWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfHVuZGVmaW5lZCl9IGNvZGUgVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlIChjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIHZhciBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2RlID0gMTAwMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhRXJyb3JDb2Rlcy5pc1ZhbGlkRXJyb3JDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH1cblxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gJycpIHtcbiAgICAgIGlmIChjb2RlID09PSAxMDAwKSB7XG4gICAgICAgIGJ1ZiA9IGNvbnN0YW50cy5FTVBUWV9CVUZGRVI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDAsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDAsIHRydWUpO1xuICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb0Nsb3NlLCBidWYsIG1hc2ssIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9DbG9zZShidWYsIG1hc2ssIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIGNsb3NlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9DbG9zZSAoZGF0YSwgbWFzaywgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgZmluOiB0cnVlLFxuICAgICAgcnN2MTogZmFsc2UsXG4gICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICBtYXNrLFxuICAgICAgcmVhZE9ubHk6IGZhbHNlXG4gICAgfSksIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nIChkYXRhLCBtYXNrKSB7XG4gICAgdmFyIHJlYWRPbmx5ID0gdHJ1ZTtcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSB2aWV3VG9CdWZmZXIoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUGluZywgZGF0YSwgbWFzaywgcmVhZE9ubHldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BpbmcoZGF0YSwgbWFzaywgcmVhZE9ubHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcGluZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9QaW5nIChkYXRhLCBtYXNrLCByZWFkT25seSkge1xuICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICBmaW46IHRydWUsXG4gICAgICByc3YxOiBmYWxzZSxcbiAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgIG1hc2ssXG4gICAgICByZWFkT25seVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBtYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nIChkYXRhLCBtYXNrKSB7XG4gICAgdmFyIHJlYWRPbmx5ID0gdHJ1ZTtcblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSB2aWV3VG9CdWZmZXIoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUG9uZywgZGF0YSwgbWFzaywgcmVhZE9ubHldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BvbmcoZGF0YSwgbWFzaywgcmVhZE9ubHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcG9uZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVhZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9Qb25nIChkYXRhLCBtYXNrLCByZWFkT25seSkge1xuICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICBmaW46IHRydWUsXG4gICAgICByc3YxOiBmYWxzZSxcbiAgICAgIG9wY29kZTogMHgwYSxcbiAgICAgIG1hc2ssXG4gICAgICByZWFkT25seVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbXByZXNzIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmJpbmFyeSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZpbiBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5tYXNrIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kIChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIHZhciByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcbiAgICB2YXIgcmVhZE9ubHkgPSB0cnVlO1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHZpZXdUb0J1ZmZlcihkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKHJzdjEgJiYgcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgcnN2MSA9IGRhdGEubGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGlmIChwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgcnN2MSxcbiAgICAgICAgb3Bjb2RlLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIHJlYWRPbmx5XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGUsXG4gICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb21wcmVzcyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZWFkT25seSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5maW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubWFzayBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJzdjEgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGUgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoIChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9kZWZsYXRpbmcgPSB0cnVlO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSAoKSB7XG4gICAgd2hpbGUgKCF0aGlzLl9kZWZsYXRpbmcgJiYgdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1sxXS5sZW5ndGg7XG4gICAgICBwYXJhbXNbMF0uYXBwbHkodGhpcywgcGFyYW1zLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzZW5kIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnF1ZXVlIChwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZSAobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBBcnJheUJ1ZmZlcmAgdmlldyBpbnRvIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7KERhdGFWaWV3fFR5cGVkQXJyYXkpfSB2aWV3IFRoZSB2aWV3IHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gQ29udmVydGVkIHZpZXdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZpZXdUb0J1ZmZlciAodmlldykge1xuICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbSh2aWV3LmJ1ZmZlcik7XG5cbiAgaWYgKHZpZXcuYnl0ZUxlbmd0aCAhPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuc2xpY2Uodmlldy5ieXRlT2Zmc2V0LCB2aWV3LmJ5dGVPZmZzZXQgKyB2aWV3LmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Validation.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/Validation.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\ntry {\n  const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'utf-8-validate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n  module.exports = typeof isValidUTF8 === 'object'\n    ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n    : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  module.exports = () => true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9WYWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyw2SUFBZ0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYWRhbXNoYXcvRGV2ZWxvcG1lbnQvd2Vic2l0ZXMvaG90ZG9nLWRpYXJpZXMvbm9kZV9tb2R1bGVzL3Nub293cmFwL25vZGVfbW9kdWxlcy93cy9saWIvVmFsaWRhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBpc1ZhbGlkVVRGOCA9PT0gJ29iamVjdCdcbiAgICA/IGlzVmFsaWRVVEY4LlZhbGlkYXRpb24uaXNWYWxpZFVURjggLy8gdXRmLTgtdmFsaWRhdGVAPDMuMC4wXG4gICAgOiBpc1ZhbGlkVVRGODtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAoKSA9PiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/WebSocket.js":
/*!****************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/WebSocket.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Ultron = __webpack_require__(/*! ultron */ \"(rsc)/./node_modules/ultron/index.js\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/PerMessageDeflate.js\");\nconst EventTarget = __webpack_require__(/*! ./EventTarget */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/EventTarget.js\");\nconst Extensions = __webpack_require__(/*! ./Extensions */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Extensions.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Constants.js\");\nconst Receiver = __webpack_require__(/*! ./Receiver */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Receiver.js\");\nconst Sender = __webpack_require__(/*! ./Sender */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Sender.js\");\n\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {String} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor (address, protocols, options) {\n    super();\n\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols === 'string') {\n      protocols = [protocols];\n    } else if (!Array.isArray(protocols)) {\n      options = protocols;\n      protocols = [];\n    }\n\n    this.readyState = WebSocket.CONNECTING;\n    this.bytesReceived = 0;\n    this.extensions = {};\n    this.protocol = '';\n\n    this._binaryType = constants.BINARY_TYPES[0];\n    this._finalize = this.finalize.bind(this);\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._finalized = false;\n    this._closeCode = 1006;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    this._ultron = null;\n\n    if (Array.isArray(address)) {\n      initAsServerClient.call(this, address[0], address[1], options);\n    } else {\n      initAsClient.call(this, address, protocols, options);\n    }\n  }\n\n  get CONNECTING () { return WebSocket.CONNECTING; }\n  get CLOSING () { return WebSocket.CLOSING; }\n  get CLOSED () { return WebSocket.CLOSED; }\n  get OPEN () { return WebSocket.OPEN; }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount () {\n    var amount = 0;\n\n    if (this._socket) {\n      amount = this._socket.bufferSize + this._sender._bufferedBytes;\n    }\n    return amount;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the required\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n   *\n   * @type {String}\n   */\n  get binaryType () {\n    return this._binaryType;\n  }\n\n  set binaryType (type) {\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @private\n   */\n  setSocket (socket, head) {\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\n    this._sender = new Sender(socket, this.extensions);\n    this._ultron = new Ultron(socket);\n    this._socket = socket;\n\n    this._ultron.on('close', this._finalize);\n    this._ultron.on('error', this._finalize);\n    this._ultron.on('end', this._finalize);\n\n    if (head.length > 0) socket.unshift(head);\n\n    this._ultron.on('data', (data) => {\n      this.bytesReceived += data.length;\n      this._receiver.add(data);\n    });\n\n    this._receiver.onmessage = (data) => this.emit('message', data);\n    this._receiver.onping = (data) => {\n      this.pong(data, !this._isServer, true);\n      this.emit('ping', data);\n    };\n    this._receiver.onpong = (data) => this.emit('pong', data);\n    this._receiver.onclose = (code, reason) => {\n      this._closeFrameReceived = true;\n      this._closeMessage = reason;\n      this._closeCode = code;\n      if (!this._finalized) this.close(code, reason);\n    };\n    this._receiver.onerror = (error, code) => {\n      this._closeMessage = '';\n      this._closeCode = code;\n\n      //\n      // Ensure that the error is emitted even if `WebSocket#finalize()` has\n      // already been called.\n      //\n      this.readyState = WebSocket.CLOSING;\n      this.emit('error', error);\n      this.finalize(true);\n    };\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Clean up and release internal resources.\n   *\n   * @param {(Boolean|Error)} error Indicates whether or not an error occurred\n   * @private\n   */\n  finalize (error) {\n    if (this._finalized) return;\n\n    this.readyState = WebSocket.CLOSING;\n    this._finalized = true;\n\n    if (typeof error === 'object') this.emit('error', error);\n    if (!this._socket) return this.emitClose();\n\n    clearTimeout(this._closeTimer);\n    this._closeTimer = null;\n\n    this._ultron.destroy();\n    this._ultron = null;\n\n    this._socket.on('error', constants.NOOP);\n\n    if (!error) this._socket.end();\n    else this._socket.destroy();\n\n    this._socket = null;\n    this._sender = null;\n\n    this._receiver.cleanup(() => this.emitClose());\n    this._receiver = null;\n  }\n\n  /**\n   * Emit the `close` event.\n   *\n   * @private\n   */\n  emitClose () {\n    this.readyState = WebSocket.CLOSED;\n\n    this.emit('close', this._closeCode, this._closeMessage);\n\n    if (this.extensions[PerMessageDeflate.extensionName]) {\n      this.extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this.extensions = null;\n\n    this.removeAllListeners();\n  }\n\n  /**\n   * Pause the socket stream.\n   *\n   * @public\n   */\n  pause () {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n    this._socket.pause();\n  }\n\n  /**\n   * Resume the socket stream\n   *\n   * @public\n   */\n  resume () {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n    this._socket.resume();\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *            +----------+     +-----------+   +----------+\n   *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\n   *            +----------+     +-----------+   +----------+       |\n   *     |      +----------+     +-----------+         |\n   *            |ws.close()|<----|close frame|<--------+            |\n   *            +----------+     +-----------+         |\n   *  CLOSING         |              +---+             |         CLOSING\n   *                  |          +---|fin|<------------+\n   *     |            |          |   +---+                          |\n   *                  |          |   +---+      +-------------+\n   *     |            +----------+-->|fin|----->|ws.finalize()| - - +\n   *                             |   +---+      +-------------+\n   *     |     +-------------+   |\n   *      - - -|ws.finalize()|<--+\n   *           +-------------+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close (code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (!this._finalized) {\n        if (this._closeFrameReceived) this._socket.end();\n\n        //\n        // Ensure that the connection is cleaned up even when the closing\n        // handshake fails.\n        //\n        this._closeTimer = setTimeout(this._finalize, closeTimeout, true);\n      }\n    });\n  }\n\n  /**\n   * Send a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  ping (data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  pong (data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send (data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      if (cb) cb(new Error('not opened'));\n      else throw new Error('not opened');\n      return;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    const opts = Object.assign({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n\n    if (!this.extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate () {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n\n    this.finalize(true);\n  }\n}\n\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3;\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get () {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set (listener) {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket server client.\n *\n * @param {http.IncomingMessage} req The request object\n * @param {net.Socket} socket The network socket between the server and client\n * @param {Buffer} head The first packet of the upgraded stream\n * @param {Object} options WebSocket attributes\n * @param {Number} options.protocolVersion The WebSocket protocol version\n * @param {Object} options.extensions The negotiated extensions\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {String} options.protocol The chosen subprotocol\n * @private\n */\nfunction initAsServerClient (socket, head, options) {\n  this.protocolVersion = options.protocolVersion;\n  this._maxPayload = options.maxPayload;\n  this.extensions = options.extensions;\n  this.protocol = options.protocol;\n\n  this._isServer = true;\n\n  this.setSocket(socket, head);\n}\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {String} address The URL to which to connect\n * @param {String[]} protocols The list of subprotocols\n * @param {Object} options Connection options\n * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {String} options.localAddress Local interface to bind for network connections\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {Object} options.headers An object containing request headers\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @param {http.Agent} options.agent Use the specified Agent\n * @param {String} options.host Value of the `Host` header\n * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).\n * @param {Function} options.checkServerIdentity A function to validate the server hostname\n * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate\n * @param {String} options.passphrase The passphrase for the private key or pfx\n * @param {String} options.ciphers The ciphers to use or exclude\n * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude\n * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key\n * @param {(String|String[]|Buffer|Buffer[])} options.key The private key\n * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs\n * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates\n * @private\n */\nfunction initAsClient (address, protocols, options) {\n  options = Object.assign({\n    protocolVersion: protocolVersions[1],\n    protocol: protocols.join(','),\n    perMessageDeflate: true,\n    handshakeTimeout: null,\n    localAddress: null,\n    headers: null,\n    family: null,\n    origin: null,\n    agent: null,\n    host: null,\n\n    //\n    // SSL options.\n    //\n    checkServerIdentity: null,\n    rejectUnauthorized: null,\n    passphrase: null,\n    ciphers: null,\n    ecdhCurve: null,\n    cert: null,\n    key: null,\n    pfx: null,\n    ca: null\n  }, options);\n\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n    throw new Error(\n      `unsupported protocol version: ${options.protocolVersion} ` +\n      `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  this.protocolVersion = options.protocolVersion;\n  this._isServer = false;\n  this.url = address;\n\n  const serverUrl = url.parse(address);\n  const isUnixSocket = serverUrl.protocol === 'ws+unix:';\n\n  if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {\n    throw new Error('invalid url');\n  }\n\n  const isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  const key = crypto.randomBytes(16).toString('base64');\n  const httpObj = isSecure ? https : http;\n  var perMessageDeflate;\n\n  const requestOptions = {\n    port: serverUrl.port || (isSecure ? 443 : 80),\n    host: serverUrl.hostname,\n    path: '/',\n    headers: {\n      'Sec-WebSocket-Version': options.protocolVersion,\n      'Sec-WebSocket-Key': key,\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket'\n    }\n  };\n\n  if (options.headers) Object.assign(requestOptions.headers, options.headers);\n  if (options.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      options.perMessageDeflate !== true ? options.perMessageDeflate : {},\n      false\n    );\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (options.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;\n  }\n  if (options.origin) {\n    if (options.protocolVersion < 13) {\n      requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;\n    } else {\n      requestOptions.headers.Origin = options.origin;\n    }\n  }\n  if (options.host) requestOptions.headers.Host = options.host;\n  if (serverUrl.auth) requestOptions.auth = serverUrl.auth;\n\n  if (options.localAddress) requestOptions.localAddress = options.localAddress;\n  if (options.family) requestOptions.family = options.family;\n\n  if (isUnixSocket) {\n    const parts = serverUrl.path.split(':');\n\n    requestOptions.socketPath = parts[0];\n    requestOptions.path = parts[1];\n  } else if (serverUrl.path) {\n    //\n    // Make sure that path starts with `/`.\n    //\n    if (serverUrl.path.charAt(0) !== '/') {\n      requestOptions.path = `/${serverUrl.path}`;\n    } else {\n      requestOptions.path = serverUrl.path;\n    }\n  }\n\n  var agent = options.agent;\n\n  //\n  // A custom agent is required for these options.\n  //\n  if (\n    options.rejectUnauthorized != null ||\n    options.checkServerIdentity ||\n    options.passphrase ||\n    options.ciphers ||\n    options.ecdhCurve ||\n    options.cert ||\n    options.key ||\n    options.pfx ||\n    options.ca\n  ) {\n    if (options.passphrase) requestOptions.passphrase = options.passphrase;\n    if (options.ciphers) requestOptions.ciphers = options.ciphers;\n    if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;\n    if (options.cert) requestOptions.cert = options.cert;\n    if (options.key) requestOptions.key = options.key;\n    if (options.pfx) requestOptions.pfx = options.pfx;\n    if (options.ca) requestOptions.ca = options.ca;\n    if (options.checkServerIdentity) {\n      requestOptions.checkServerIdentity = options.checkServerIdentity;\n    }\n    if (options.rejectUnauthorized != null) {\n      requestOptions.rejectUnauthorized = options.rejectUnauthorized;\n    }\n\n    if (!agent) agent = new httpObj.Agent(requestOptions);\n  }\n\n  if (agent) requestOptions.agent = agent;\n\n  this._req = httpObj.get(requestOptions);\n\n  if (options.handshakeTimeout) {\n    this._req.setTimeout(options.handshakeTimeout, () => {\n      this._req.abort();\n      this.finalize(new Error('opening handshake has timed out'));\n    });\n  }\n\n  this._req.on('error', (error) => {\n    if (this._req.aborted) return;\n\n    this._req = null;\n    this.finalize(error);\n  });\n\n  this._req.on('response', (res) => {\n    if (!this.emit('unexpected-response', this._req, res)) {\n      this._req.abort();\n      this.finalize(new Error(`unexpected server response (${res.statusCode})`));\n    }\n  });\n\n  this._req.on('upgrade', (res, socket, head) => {\n    this.emit('headers', res.headers, res);\n\n    //\n    // The user may have closed the connection from a listener of the `headers`\n    // event.\n    //\n    if (this.readyState !== WebSocket.CONNECTING) return;\n\n    this._req = null;\n\n    const digest = crypto.createHash('sha1')\n      .update(key + constants.GUID, 'binary')\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      socket.destroy();\n      return this.finalize(new Error('invalid server key'));\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (options.protocol || '').split(/, */);\n    var protError;\n\n    if (!options.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      socket.destroy();\n      return this.finalize(new Error(protError));\n    }\n\n    if (serverProt) this.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const serverExtensions = Extensions.parse(\n          res.headers['sec-websocket-extensions']\n        );\n\n        if (serverExtensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(\n            serverExtensions[PerMessageDeflate.extensionName]\n          );\n          this.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        socket.destroy();\n        this.finalize(new Error('invalid Sec-WebSocket-Extensions header'));\n        return;\n      }\n    }\n\n    this.setSocket(socket, head);\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9XZWJTb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLOztBQUV6QiwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBcUI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsdUZBQWU7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMscUZBQWM7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsbUZBQWE7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDZFQUFVOztBQUVqQztBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLGdCQUFnQjs7QUFFaEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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L25vZGVfbW9kdWxlcy9zbm9vd3JhcC9ub2RlX21vZHVsZXMvd3MvbGliL1dlYlNvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBVbHRyb24gPSByZXF1aXJlKCd1bHRyb24nKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL1Blck1lc3NhZ2VEZWZsYXRlJyk7XG5jb25zdCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vRXZlbnRUYXJnZXQnKTtcbmNvbnN0IEV4dGVuc2lvbnMgPSByZXF1aXJlKCcuL0V4dGVuc2lvbnMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vUmVjZWl2ZXInKTtcbmNvbnN0IFNlbmRlciA9IHJlcXVpcmUoJy4vU2VuZGVyJyk7XG5cbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwOyAvLyBBbGxvdyAzMCBzZWNvbmRzIHRvIHRlcm1pbmF0ZSB0aGUgY29ubmVjdGlvbiBjbGVhbmx5LlxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgV2ViU29ja2V0YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAoIXByb3RvY29scykge1xuICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gY29uc3RhbnRzLkJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9maW5hbGl6ZSA9IHRoaXMuZmluYWxpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9ICcnO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlQ29kZSA9IDEwMDY7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcbiAgICB0aGlzLl91bHRyb24gPSBudWxsO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWRkcmVzcykpIHtcbiAgICAgIGluaXRBc1NlcnZlckNsaWVudC5jYWxsKHRoaXMsIGFkZHJlc3NbMF0sIGFkZHJlc3NbMV0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0QXNDbGllbnQuY2FsbCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBDT05ORUNUSU5HICgpIHsgcmV0dXJuIFdlYlNvY2tldC5DT05ORUNUSU5HOyB9XG4gIGdldCBDTE9TSU5HICgpIHsgcmV0dXJuIFdlYlNvY2tldC5DTE9TSU5HOyB9XG4gIGdldCBDTE9TRUQgKCkgeyByZXR1cm4gV2ViU29ja2V0LkNMT1NFRDsgfVxuICBnZXQgT1BFTiAoKSB7IHJldHVybiBXZWJTb2NrZXQuT1BFTjsgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50ICgpIHtcbiAgICB2YXIgYW1vdW50ID0gMDtcblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIGFtb3VudCA9IHRoaXMuX3NvY2tldC5idWZmZXJTaXplICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICAgIH1cbiAgICByZXR1cm4gYW1vdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgV0hBVFdHIGludGVyZmFjZSBzaW5jZSB3cyBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVpcmVkXG4gICAqIGRlZmF1bHQgXCJibG9iXCIgdHlwZSAoaW5zdGVhZCB3ZSBkZWZpbmUgYSBjdXN0b20gXCJub2RlYnVmZmVyXCIgdHlwZSkuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSAodHlwZSkge1xuICAgIGlmIChjb25zdGFudHMuQklOQVJZX1RZUEVTLmluZGV4T2YodHlwZSkgPCAwKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldCAoc29ja2V0LCBoZWFkKSB7XG4gICAgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuICAgIHRoaXMuX3JlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHRoaXMuZXh0ZW5zaW9ucywgdGhpcy5fbWF4UGF5bG9hZCwgdGhpcy5iaW5hcnlUeXBlKTtcbiAgICB0aGlzLl9zZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5leHRlbnNpb25zKTtcbiAgICB0aGlzLl91bHRyb24gPSBuZXcgVWx0cm9uKHNvY2tldCk7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fdWx0cm9uLm9uKCdjbG9zZScsIHRoaXMuX2ZpbmFsaXplKTtcbiAgICB0aGlzLl91bHRyb24ub24oJ2Vycm9yJywgdGhpcy5fZmluYWxpemUpO1xuICAgIHRoaXMuX3VsdHJvbi5vbignZW5kJywgdGhpcy5fZmluYWxpemUpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICB0aGlzLl91bHRyb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5fcmVjZWl2ZXIuYWRkKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVjZWl2ZXIub25tZXNzYWdlID0gKGRhdGEpID0+IHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuX3JlY2VpdmVyLm9ucGluZyA9IChkYXRhKSA9PiB7XG4gICAgICB0aGlzLnBvbmcoZGF0YSwgIXRoaXMuX2lzU2VydmVyLCB0cnVlKTtcbiAgICAgIHRoaXMuZW1pdCgncGluZycsIGRhdGEpO1xuICAgIH07XG4gICAgdGhpcy5fcmVjZWl2ZXIub25wb25nID0gKGRhdGEpID0+IHRoaXMuZW1pdCgncG9uZycsIGRhdGEpO1xuICAgIHRoaXMuX3JlY2VpdmVyLm9uY2xvc2UgPSAoY29kZSwgcmVhc29uKSA9PiB7XG4gICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICAgICAgdGhpcy5fY2xvc2VDb2RlID0gY29kZTtcbiAgICAgIGlmICghdGhpcy5fZmluYWxpemVkKSB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgfTtcbiAgICB0aGlzLl9yZWNlaXZlci5vbmVycm9yID0gKGVycm9yLCBjb2RlKSA9PiB7XG4gICAgICB0aGlzLl9jbG9zZU1lc3NhZ2UgPSAnJztcbiAgICAgIHRoaXMuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZXJyb3IgaXMgZW1pdHRlZCBldmVuIGlmIGBXZWJTb2NrZXQjZmluYWxpemUoKWAgaGFzXG4gICAgICAvLyBhbHJlYWR5IGJlZW4gY2FsbGVkLlxuICAgICAgLy9cbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIHRoaXMuZmluYWxpemUodHJ1ZSk7XG4gICAgfTtcblxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFuZCByZWxlYXNlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxFcnJvcil9IGVycm9yIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCBhbiBlcnJvciBvY2N1cnJlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZmluYWxpemUgKGVycm9yKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIGlmICghdGhpcy5fc29ja2V0KSByZXR1cm4gdGhpcy5lbWl0Q2xvc2UoKTtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLl9jbG9zZVRpbWVyKTtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcblxuICAgIHRoaXMuX3VsdHJvbi5kZXN0cm95KCk7XG4gICAgdGhpcy5fdWx0cm9uID0gbnVsbDtcblxuICAgIHRoaXMuX3NvY2tldC5vbignZXJyb3InLCBjb25zdGFudHMuTk9PUCk7XG5cbiAgICBpZiAoIWVycm9yKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgZWxzZSB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcbiAgICB0aGlzLl9zZW5kZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fcmVjZWl2ZXIuY2xlYW51cCgoKSA9PiB0aGlzLmVtaXRDbG9zZSgpKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYGNsb3NlYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSAoKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcblxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG5cbiAgICBpZiAodGhpcy5leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IG51bGw7XG5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQgc3RyZWFtLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwYXVzZSAoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHRocm93IG5ldyBFcnJvcignbm90IG9wZW5lZCcpO1xuXG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHRoZSBzb2NrZXQgc3RyZWFtXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlc3VtZSAoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHRocm93IG5ldyBFcnJvcignbm90IG9wZW5lZCcpO1xuXG4gICAgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICAgKy0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICArIC0gLSAtfHdzLmNsb3NlKCl8LS0tLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC0gLVxuICAgKiAgICAgICAgICAgICstLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgICB8XG4gICAqICAgICB8ICAgICAgKy0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiAgICAgICAgICAgIHx3cy5jbG9zZSgpfDwtLS0tfGNsb3NlIGZyYW1lfDwtLS0tLS0tLSsgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgKy0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiAgQ0xPU0lORyAgICAgICAgIHwgICAgICAgICAgICAgICstLS0rICAgICAgICAgICAgIHwgICAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICAgICAgICAgfCAgICAgICAgICArLS0tfGZpbnw8LS0tLS0tLS0tLS0tK1xuICAgKiAgICAgfCAgICAgICAgICAgIHwgICAgICAgICAgfCAgICstLS0rICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgKy0tLSsgICAgICArLS0tLS0tLS0tLS0tLStcbiAgICogICAgIHwgICAgICAgICAgICArLS0tLS0tLS0tLSstLT58ZmlufC0tLS0tPnx3cy5maW5hbGl6ZSgpfCAtIC0gK1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgKy0tLS0tLS0tLS0tLS0rXG4gICAqICAgICB8ICAgICArLS0tLS0tLS0tLS0tLSsgICB8XG4gICAqICAgICAgLSAtIC18d3MuZmluYWxpemUoKXw8LS0rXG4gICAqICAgICAgICAgICArLS0tLS0tLS0tLS0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBBIHN0cmluZyBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlIChjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcbiAgICAgIHRoaXMuZmluYWxpemUobmV3IEVycm9yKCdjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVNlbnQgJiYgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuX2ZpbmFsaXplZCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkKSB0aGlzLl9zb2NrZXQuZW5kKCk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgY2xlYW5lZCB1cCBldmVuIHdoZW4gdGhlIGNsb3NpbmdcbiAgICAgICAgLy8gaGFuZHNoYWtlIGZhaWxzLlxuICAgICAgICAvL1xuICAgICAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9maW5hbGl6ZSwgY2xvc2VUaW1lb3V0LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmFpbFNpbGVudGx5IEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byB0aHJvdyBpZiBgcmVhZHlTdGF0ZWAgaXNuJ3QgYE9QRU5gXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcgKGRhdGEsIG1hc2ssIGZhaWxTaWxlbnRseSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBpZiAoZmFpbFNpbGVudGx5KSByZXR1cm47XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBvcGVuZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBjb25zdGFudHMuRU1QVFlfQlVGRkVSLCBtYXNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hc2sgSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmFpbFNpbGVudGx5IEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byB0aHJvdyBpZiBgcmVhZHlTdGF0ZWAgaXNuJ3QgYE9QRU5gXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcgKGRhdGEsIG1hc2ssIGZhaWxTaWxlbnRseSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBpZiAoZmFpbFNpbGVudGx5KSByZXR1cm47XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBvcGVuZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBjb25zdGFudHMuRU1QVFlfQlVGRkVSLCBtYXNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY29tcHJlc3MgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuYmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZmluIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGUgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm1hc2sgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kIChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBpZiAoY2IpIGNiKG5ldyBFcnJvcignbm90IG9wZW5lZCcpKTtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdub3Qgb3BlbmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGlmICghdGhpcy5leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBjb25zdGFudHMuRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSAoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcbiAgICAgIHRoaXMuZmluYWxpemUobmV3IEVycm9yKCdjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmluYWxpemUodHJ1ZSk7XG4gIH1cbn1cblxuV2ViU29ja2V0LkNPTk5FQ1RJTkcgPSAwO1xuV2ViU29ja2V0Lk9QRU4gPSAxO1xuV2ViU29ja2V0LkNMT1NJTkcgPSAyO1xuV2ViU29ja2V0LkNMT1NFRCA9IDM7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsaXN0ZW5lciBvZiB0aGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoRnVuY3Rpb258dW5kZWZpbmVkKX0gVGhlIGV2ZW50IGxpc3RlbmVyIG9yIGB1bmRlZmluZWRgXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCAoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIpIHJldHVybiBsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0IChsaXN0ZW5lcikge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMobWV0aG9kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlbW92ZSBvbmx5IHRoZSBsaXN0ZW5lcnMgYWRkZWQgdmlhIGBhZGRFdmVudExpc3RlbmVyYC5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIpIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSk7XG59KTtcblxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgc2VydmVyIGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgV2ViU29ja2V0IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnByb3RvY29sVmVyc2lvbiBUaGUgV2ViU29ja2V0IHByb3RvY29sIHZlcnNpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmV4dGVuc2lvbnMgVGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4UGF5bG9hZCBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvdG9jb2wgVGhlIGNob3NlbiBzdWJwcm90b2NvbFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzU2VydmVyQ2xpZW50IChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5wcm90b2NvbFZlcnNpb24gPSBvcHRpb25zLnByb3RvY29sVmVyc2lvbjtcbiAgdGhpcy5fbWF4UGF5bG9hZCA9IG9wdGlvbnMubWF4UGF5bG9hZDtcbiAgdGhpcy5leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zO1xuICB0aGlzLnByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbDtcblxuICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG5cbiAgdGhpcy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7U3RyaW5nW119IHByb3RvY29scyBUaGUgbGlzdCBvZiBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvdG9jb2wgVmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBoZWFkZXJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSBFbmFibGUvZGlzYWJsZSBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXQgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubG9jYWxBZGRyZXNzIExvY2FsIGludGVyZmFjZSB0byBiaW5kIGZvciBuZXR3b3JrIGNvbm5lY3Rpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wcm90b2NvbFZlcnNpb24gVmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuaGVhZGVycyBBbiBvYmplY3QgY29udGFpbmluZyByZXF1ZXN0IGhlYWRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm9yaWdpbiBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3IgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7aHR0cC5BZ2VudH0gb3B0aW9ucy5hZ2VudCBVc2UgdGhlIHNwZWNpZmllZCBBZ2VudFxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaG9zdCBWYWx1ZSBvZiB0aGUgYEhvc3RgIGhlYWRlclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZmFtaWx5IElQIGFkZHJlc3MgZmFtaWx5IHRvIHVzZSBkdXJpbmcgaG9zdG5hbWUgbG9va3VwICg0IG9yIDYpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5IEEgZnVuY3Rpb24gdG8gdmFsaWRhdGUgdGhlIHNlcnZlciBob3N0bmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCBWZXJpZnkgb3Igbm90IHRoZSBzZXJ2ZXIgY2VydGlmaWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnBhc3NwaHJhc2UgVGhlIHBhc3NwaHJhc2UgZm9yIHRoZSBwcml2YXRlIGtleSBvciBwZnhcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNpcGhlcnMgVGhlIGNpcGhlcnMgdG8gdXNlIG9yIGV4Y2x1ZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVjZGhDdXJ2ZSBUaGUgY3VydmVzIGZvciBFQ0RIIGtleSBhZ3JlZW1lbnQgdG8gdXNlIG9yIGV4Y2x1ZGVcbiAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXXxCdWZmZXJ8QnVmZmVyW10pfSBvcHRpb25zLmNlcnQgVGhlIGNlcnRpZmljYXRlIGtleVxuICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdfEJ1ZmZlcnxCdWZmZXJbXSl9IG9wdGlvbnMua2V5IFRoZSBwcml2YXRlIGtleVxuICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IG9wdGlvbnMucGZ4IFRoZSBwcml2YXRlIGtleSwgY2VydGlmaWNhdGUsIGFuZCBDQSBjZXJ0c1xuICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdfEJ1ZmZlcnxCdWZmZXJbXSl9IG9wdGlvbnMuY2EgVHJ1c3RlZCBjZXJ0aWZpY2F0ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc0NsaWVudCAoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgcHJvdG9jb2w6IHByb3RvY29scy5qb2luKCcsJyksXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgaGFuZHNoYWtlVGltZW91dDogbnVsbCxcbiAgICBsb2NhbEFkZHJlc3M6IG51bGwsXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICBmYW1pbHk6IG51bGwsXG4gICAgb3JpZ2luOiBudWxsLFxuICAgIGFnZW50OiBudWxsLFxuICAgIGhvc3Q6IG51bGwsXG5cbiAgICAvL1xuICAgIC8vIFNTTCBvcHRpb25zLlxuICAgIC8vXG4gICAgY2hlY2tTZXJ2ZXJJZGVudGl0eTogbnVsbCxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG51bGwsXG4gICAgcGFzc3BocmFzZTogbnVsbCxcbiAgICBjaXBoZXJzOiBudWxsLFxuICAgIGVjZGhDdXJ2ZTogbnVsbCxcbiAgICBjZXJ0OiBudWxsLFxuICAgIGtleTogbnVsbCxcbiAgICBwZng6IG51bGwsXG4gICAgY2E6IG51bGxcbiAgfSwgb3B0aW9ucyk7XG5cbiAgaWYgKHByb3RvY29sVmVyc2lvbnMuaW5kZXhPZihvcHRpb25zLnByb3RvY29sVmVyc2lvbikgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0aW9ucy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gb3B0aW9ucy5wcm90b2NvbFZlcnNpb247XG4gIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gIHRoaXMudXJsID0gYWRkcmVzcztcblxuICBjb25zdCBzZXJ2ZXJVcmwgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gIGNvbnN0IGlzVW5peFNvY2tldCA9IHNlcnZlclVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcblxuICBpZiAoIXNlcnZlclVybC5ob3N0ICYmICghaXNVbml4U29ja2V0IHx8ICFzZXJ2ZXJVcmwucGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdXJsJyk7XG4gIH1cblxuICBjb25zdCBpc1NlY3VyZSA9IHNlcnZlclVybC5wcm90b2NvbCA9PT0gJ3dzczonIHx8IHNlcnZlclVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIGNvbnN0IGtleSA9IGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBjb25zdCBodHRwT2JqID0gaXNTZWN1cmUgPyBodHRwcyA6IGh0dHA7XG4gIHZhciBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICBwb3J0OiBzZXJ2ZXJVcmwucG9ydCB8fCAoaXNTZWN1cmUgPyA0NDMgOiA4MCksXG4gICAgaG9zdDogc2VydmVyVXJsLmhvc3RuYW1lLFxuICAgIHBhdGg6ICcvJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0aW9ucy5wcm90b2NvbFZlcnNpb24sXG4gICAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgICAnQ29ubmVjdGlvbic6ICdVcGdyYWRlJyxcbiAgICAgICdVcGdyYWRlJzogJ3dlYnNvY2tldCdcbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuaGVhZGVycykgT2JqZWN0LmFzc2lnbihyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IEV4dGVuc2lvbnMuZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zLnByb3RvY29sKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gb3B0aW9ucy5wcm90b2NvbDtcbiAgfVxuICBpZiAob3B0aW9ucy5vcmlnaW4pIHtcbiAgICBpZiAob3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdGlvbnMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLk9yaWdpbiA9IG9wdGlvbnMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5ob3N0KSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLkhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gIGlmIChzZXJ2ZXJVcmwuYXV0aCkgcmVxdWVzdE9wdGlvbnMuYXV0aCA9IHNlcnZlclVybC5hdXRoO1xuXG4gIGlmIChvcHRpb25zLmxvY2FsQWRkcmVzcykgcmVxdWVzdE9wdGlvbnMubG9jYWxBZGRyZXNzID0gb3B0aW9ucy5sb2NhbEFkZHJlc3M7XG4gIGlmIChvcHRpb25zLmZhbWlseSkgcmVxdWVzdE9wdGlvbnMuZmFtaWx5ID0gb3B0aW9ucy5mYW1pbHk7XG5cbiAgaWYgKGlzVW5peFNvY2tldCkge1xuICAgIGNvbnN0IHBhcnRzID0gc2VydmVyVXJsLnBhdGguc3BsaXQoJzonKTtcblxuICAgIHJlcXVlc3RPcHRpb25zLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICByZXF1ZXN0T3B0aW9ucy5wYXRoID0gcGFydHNbMV07XG4gIH0gZWxzZSBpZiAoc2VydmVyVXJsLnBhdGgpIHtcbiAgICAvL1xuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHBhdGggc3RhcnRzIHdpdGggYC9gLlxuICAgIC8vXG4gICAgaWYgKHNlcnZlclVybC5wYXRoLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICByZXF1ZXN0T3B0aW9ucy5wYXRoID0gYC8ke3NlcnZlclVybC5wYXRofWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3RPcHRpb25zLnBhdGggPSBzZXJ2ZXJVcmwucGF0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuXG4gIC8vXG4gIC8vIEEgY3VzdG9tIGFnZW50IGlzIHJlcXVpcmVkIGZvciB0aGVzZSBvcHRpb25zLlxuICAvL1xuICBpZiAoXG4gICAgb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgIT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSB8fFxuICAgIG9wdGlvbnMucGFzc3BocmFzZSB8fFxuICAgIG9wdGlvbnMuY2lwaGVycyB8fFxuICAgIG9wdGlvbnMuZWNkaEN1cnZlIHx8XG4gICAgb3B0aW9ucy5jZXJ0IHx8XG4gICAgb3B0aW9ucy5rZXkgfHxcbiAgICBvcHRpb25zLnBmeCB8fFxuICAgIG9wdGlvbnMuY2FcbiAgKSB7XG4gICAgaWYgKG9wdGlvbnMucGFzc3BocmFzZSkgcmVxdWVzdE9wdGlvbnMucGFzc3BocmFzZSA9IG9wdGlvbnMucGFzc3BocmFzZTtcbiAgICBpZiAob3B0aW9ucy5jaXBoZXJzKSByZXF1ZXN0T3B0aW9ucy5jaXBoZXJzID0gb3B0aW9ucy5jaXBoZXJzO1xuICAgIGlmIChvcHRpb25zLmVjZGhDdXJ2ZSkgcmVxdWVzdE9wdGlvbnMuZWNkaEN1cnZlID0gb3B0aW9ucy5lY2RoQ3VydmU7XG4gICAgaWYgKG9wdGlvbnMuY2VydCkgcmVxdWVzdE9wdGlvbnMuY2VydCA9IG9wdGlvbnMuY2VydDtcbiAgICBpZiAob3B0aW9ucy5rZXkpIHJlcXVlc3RPcHRpb25zLmtleSA9IG9wdGlvbnMua2V5O1xuICAgIGlmIChvcHRpb25zLnBmeCkgcmVxdWVzdE9wdGlvbnMucGZ4ID0gb3B0aW9ucy5wZng7XG4gICAgaWYgKG9wdGlvbnMuY2EpIHJlcXVlc3RPcHRpb25zLmNhID0gb3B0aW9ucy5jYTtcbiAgICBpZiAob3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSB7XG4gICAgICByZXF1ZXN0T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gb3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdE9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFhZ2VudCkgYWdlbnQgPSBuZXcgaHR0cE9iai5BZ2VudChyZXF1ZXN0T3B0aW9ucyk7XG4gIH1cblxuICBpZiAoYWdlbnQpIHJlcXVlc3RPcHRpb25zLmFnZW50ID0gYWdlbnQ7XG5cbiAgdGhpcy5fcmVxID0gaHR0cE9iai5nZXQocmVxdWVzdE9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXQpIHtcbiAgICB0aGlzLl9yZXEuc2V0VGltZW91dChvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXQsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlcS5hYm9ydCgpO1xuICAgICAgdGhpcy5maW5hbGl6ZShuZXcgRXJyb3IoJ29wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKSk7XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLl9yZXEub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgaWYgKHRoaXMuX3JlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsO1xuICAgIHRoaXMuZmluYWxpemUoZXJyb3IpO1xuICB9KTtcblxuICB0aGlzLl9yZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGlmICghdGhpcy5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgdGhpcy5fcmVxLCByZXMpKSB7XG4gICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcbiAgICAgIHRoaXMuZmluYWxpemUobmV3IEVycm9yKGB1bmV4cGVjdGVkIHNlcnZlciByZXNwb25zZSAoJHtyZXMuc3RhdHVzQ29kZX0pYCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5fcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgcmVzLmhlYWRlcnMsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGBoZWFkZXJzYFxuICAgIC8vIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHRoaXMuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIGNvbnN0YW50cy5HVUlELCAnYmluYXJ5JylcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgaWYgKHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddICE9PSBkaWdlc3QpIHtcbiAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShuZXcgRXJyb3IoJ2ludmFsaWQgc2VydmVyIGtleScpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJQcm90ID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBjb25zdCBwcm90TGlzdCA9IChvcHRpb25zLnByb3RvY29sIHx8ICcnKS5zcGxpdCgvLCAqLyk7XG4gICAgdmFyIHByb3RFcnJvcjtcblxuICAgIGlmICghb3B0aW9ucy5wcm90b2NvbCAmJiBzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnc2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBldmVuIHRob3VnaCBub25lIHJlcXVlc3RlZCc7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnByb3RvY29sICYmICFzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnc2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wgZXZlbiB0aG91Z2ggcmVxdWVzdGVkJztcbiAgICB9IGVsc2UgaWYgKHNlcnZlclByb3QgJiYgcHJvdExpc3QuaW5kZXhPZihzZXJ2ZXJQcm90KSA9PT0gLTEpIHtcbiAgICAgIHByb3RFcnJvciA9ICdzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gaW52YWxpZCBwcm90b2NvbCc7XG4gICAgfVxuXG4gICAgaWYgKHByb3RFcnJvcikge1xuICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5ldyBFcnJvcihwcm90RXJyb3IpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgdGhpcy5wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckV4dGVuc2lvbnMgPSBFeHRlbnNpb25zLnBhcnNlKFxuICAgICAgICAgIHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzZXJ2ZXJFeHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KFxuICAgICAgICAgICAgc2VydmVyRXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplKG5ldyBFcnJvcignaW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkKTtcbiAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/WebSocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snoowrap/node_modules/ws/lib/WebSocketServer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/snoowrap/node_modules/ws/lib/WebSocketServer.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/snoowrap/node_modules/safe-buffer/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Ultron = __webpack_require__(/*! ultron */ \"(rsc)/./node_modules/ultron/index.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/PerMessageDeflate.js\");\nconst Extensions = __webpack_require__(/*! ./Extensions */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Extensions.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/Constants.js\");\nconst WebSocket = __webpack_require__(/*! ./WebSocket */ \"(rsc)/./node_modules/snoowrap/node_modules/ws/lib/WebSocket.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor (options, callback) {\n    super();\n\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('missing or invalid options');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._ultron = new Ultron(this._server);\n      this._ultron.on('listening', () => this.emit('listening'));\n      this._ultron.on('error', (err) => this.emit('error', err));\n      this._ultron.on('upgrade', (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, (client) => {\n          this.emit('connection', client, req);\n        });\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._ultron.destroy();\n      this._ultron = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) return server.close(cb);\n    }\n\n    if (cb) cb();\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle (req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade (req, socket, head, cb) {\n    socket.on('error', socketError);\n\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortConnection(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = Extensions.parse(\n          req.headers['sec-websocket-extensions']\n        );\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortConnection(socket, 400);\n      }\n    }\n\n    var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */);\n\n    //\n    // Optionally call external protocol selection handler.\n    //\n    if (this.options.handleProtocols) {\n      protocol = this.options.handleProtocols(protocol, req);\n      if (protocol === false) return abortConnection(socket, 401);\n    } else {\n      protocol = protocol[0];\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message) => {\n          if (!verified) return abortConnection(socket, code || 401, message);\n\n          this.completeUpgrade(\n            protocol,\n            extensions,\n            version,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n    }\n\n    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} protocol The chosen subprotocol\n   * @param {Object} extensions The accepted extensions\n   * @param {Number} version The WebSocket protocol version\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade (protocol, extensions, version, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const key = crypto.createHash('sha1')\n      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${key}`\n    ];\n\n    if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = Extensions.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n\n    const client = new WebSocket([socket, head], null, {\n      maxPayload: this.options.maxPayload,\n      protocolVersion: version,\n      extensions,\n      protocol\n    });\n\n    if (this.clients) {\n      this.clients.add(client);\n      client.on('close', () => this.clients.delete(client));\n    }\n\n    socket.removeListener('error', socketError);\n    cb(client);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketError () {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\nfunction abortConnection (socket, code, message) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      'Connection: close\\r\\n' +\n      'Content-type: text/html\\r\\n' +\n      `Content-Length: ${Buffer.byteLength(message)}\\r\\n` +\n      '\\r\\n' +\n      message\n    );\n  }\n\n  socket.removeListener('error', socketError);\n  socket.destroy();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vb3dyYXAvbm9kZV9tb2R1bGVzL3dzL2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBYTtBQUN4QyxxQkFBcUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7O0FBRXpCLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFxQjtBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBYztBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBYTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBYTs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtEQUFrRDtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQzs7QUFFQSwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0QsTUFBTTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNLEVBQUUsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FkYW1zaGF3L0RldmVsb3BtZW50L3dlYnNpdGVzL2hvdGRvZy1kaWFyaWVzL25vZGVfbW9kdWxlcy9zbm9vd3JhcC9ub2RlX21vZHVsZXMvd3MvbGliL1dlYlNvY2tldFNlcnZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHdzOiBhIG5vZGUuanMgd2Vic29ja2V0IGNsaWVudFxuICogQ29weXJpZ2h0KGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNhZmVCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IFVsdHJvbiA9IHJlcXVpcmUoJ3VsdHJvbicpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vUGVyTWVzc2FnZURlZmxhdGUnKTtcbmNvbnN0IEV4dGVuc2lvbnMgPSByZXF1aXJlKCcuL0V4dGVuc2lvbnMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL1dlYlNvY2tldCcpO1xuXG5jb25zdCBCdWZmZXIgPSBzYWZlQnVmZmVyLkJ1ZmZlcjtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXRTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ob3N0IFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucG9ydCBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtodHRwLlNlcnZlcn0gb3B0aW9ucy5zZXJ2ZXIgQSBwcmUtY3JlYXRlZCBIVFRQL1Mgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnZlcmlmeUNsaWVudCBBbiBob29rIHRvIHJlamVjdCBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmhhbmRsZVByb3RvY29scyBBbiBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucGF0aCBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm5vU2VydmVyIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY2xpZW50VHJhY2tpbmcgU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHRyYWNrIGNsaWVudHNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIEVuYWJsZS9kaXNhYmxlIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhQYXlsb2FkIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4ob3B0aW9ucy5wb3J0LCBvcHRpb25zLmhvc3QsIG9wdGlvbnMuYmFja2xvZywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3VsdHJvbiA9IG5ldyBVbHRyb24odGhpcy5fc2VydmVyKTtcbiAgICAgIHRoaXMuX3VsdHJvbi5vbignbGlzdGVuaW5nJywgKCkgPT4gdGhpcy5lbWl0KCdsaXN0ZW5pbmcnKSk7XG4gICAgICB0aGlzLl91bHRyb24ub24oJ2Vycm9yJywgKGVycikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycikpO1xuICAgICAgdGhpcy5fdWx0cm9uLm9uKCd1cGdyYWRlJywgKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgKGNsaWVudCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbicsIGNsaWVudCwgcmVxKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZSAoY2IpIHtcbiAgICAvL1xuICAgIC8vIFRlcm1pbmF0ZSBhbGwgYXNzb2NpYXRlZCBjbGllbnRzLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKSBjbGllbnQudGVybWluYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgdGhpcy5fdWx0cm9uLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3VsdHJvbiA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBDbG9zZSB0aGUgaHR0cCBzZXJ2ZXIgaWYgaXQgd2FzIGludGVybmFsbHkgY3JlYXRlZC5cbiAgICAgIC8vXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBvcnQgIT0gbnVsbCkgcmV0dXJuIHNlcnZlci5jbG9zZShjYik7XG4gICAgfVxuXG4gICAgaWYgKGNiKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZSAocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoICYmIHVybC5wYXJzZShyZXEudXJsKS5wYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhbmRsZVVwZ3JhZGUgKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRFcnJvcik7XG5cbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XG5cbiAgICBpZiAoXG4gICAgICByZXEubWV0aG9kICE9PSAnR0VUJyB8fCByZXEuaGVhZGVycy51cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnIHx8XG4gICAgICAhcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10gfHwgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0Q29ubmVjdGlvbihzb2NrZXQsIDQwMCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZmVycyA9IEV4dGVuc2lvbnMucGFyc2UoXG4gICAgICAgICAgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydENvbm5lY3Rpb24oc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm90b2NvbCA9IChyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddIHx8ICcnKS5zcGxpdCgvLCAqLyk7XG5cbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKSB7XG4gICAgICBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2wsIHJlcSk7XG4gICAgICBpZiAocHJvdG9jb2wgPT09IGZhbHNlKSByZXR1cm4gYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgNDAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvdG9jb2wgPSBwcm90b2NvbFswXTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBjbGllbnQgdmVyaWZpY2F0aW9uIGhhbmRsZXIuXG4gICAgLy9cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudCkge1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5jb25uZWN0aW9uLmF1dGhvcml6ZWQgfHwgcmVxLmNvbm5lY3Rpb24uZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSByZXR1cm4gYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UpO1xuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIGNiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKSByZXR1cm4gYWJvcnRDb25uZWN0aW9uKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShwcm90b2NvbCwgZXh0ZW5zaW9ucywgdmVyc2lvbiwgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFRoZSBjaG9zZW4gc3VicHJvdG9jb2xcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gVGhlIFdlYlNvY2tldCBwcm90b2NvbCB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlIChwcm90b2NvbCwgZXh0ZW5zaW9ucywgdmVyc2lvbiwgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgLy9cbiAgICAvLyBEZXN0cm95IHRoZSBzb2NrZXQgaWYgdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBzZW50IGEgRklOIHBhY2tldC5cbiAgICAvL1xuICAgIGlmICghc29ja2V0LnJlYWRhYmxlIHx8ICFzb2NrZXQud3JpdGFibGUpIHJldHVybiBzb2NrZXQuZGVzdHJveSgpO1xuXG4gICAgY29uc3Qga2V5ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSArIGNvbnN0YW50cy5HVUlELCAnYmluYXJ5JylcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtrZXl9YFxuICAgIF07XG5cbiAgICBpZiAocHJvdG9jb2wpIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IEV4dGVuc2lvbnMuZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuXG4gICAgY29uc3QgY2xpZW50ID0gbmV3IFdlYlNvY2tldChbc29ja2V0LCBoZWFkXSwgbnVsbCwge1xuICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBwcm90b2NvbFZlcnNpb246IHZlcnNpb24sXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgcHJvdG9jb2xcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQoY2xpZW50KTtcbiAgICAgIGNsaWVudC5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmNsaWVudHMuZGVsZXRlKGNsaWVudCkpO1xuICAgIH1cblxuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRFcnJvcik7XG4gICAgY2IoY2xpZW50KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBIYW5kbGUgcHJlbWF0dXJlIHNvY2tldCBlcnJvcnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0RXJyb3IgKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgSFRUUCByZXNwb25zZSBib2R5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydENvbm5lY3Rpb24gKHNvY2tldCwgY29kZSwgbWVzc2FnZSkge1xuICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgaHR0cC5TVEFUVVNfQ09ERVNbY29kZV07XG4gICAgc29ja2V0LndyaXRlKFxuICAgICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgICdDb25uZWN0aW9uOiBjbG9zZVxcclxcbicgK1xuICAgICAgJ0NvbnRlbnQtdHlwZTogdGV4dC9odG1sXFxyXFxuJyArXG4gICAgICBgQ29udGVudC1MZW5ndGg6ICR7QnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSl9XFxyXFxuYCArXG4gICAgICAnXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICAgKTtcbiAgfVxuXG4gIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRFcnJvcik7XG4gIHNvY2tldC5kZXN0cm95KCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snoowrap/node_modules/ws/lib/WebSocketServer.js\n");

/***/ })

};
;