"use strict";exports.id=6865,exports.ids=[6865],exports.modules={35144:(a,b,c)=>{c.d(b,{$b:()=>f,NR:()=>e,cM:()=>d});var d=function(a){return a.TEXT="text",a.IMAGE="image",a.VIDEO="video",a.MIXED="mixed",a}({}),e=function(a){return a.REDDIT="reddit",a.INSTAGRAM="instagram",a.FACEBOOK="facebook",a.TIKTOK="tiktok",a}({}),f=function(a){return a.DEBUG="debug",a.INFO="info",a.WARN="warn",a.ERROR="error",a.FATAL="fatal",a}({})},76865:(a,b,c)=>{c.a(a,async(a,d)=>{try{c.d(b,{G:()=>j,M:()=>k});var e=c(7462),f=c(35144),g=c(55511),h=c.n(g),i=a([e]);e=(i.then?(await i)():i)[0];class j{static{this.DEFAULT_SPAM_PATTERNS=["buy now","limited time","discount","promo code","sale","offer","deal","click here","act now","don't miss","free shipping","call now","order today","special offer","best price","lowest price","save \\$\\d+","get yours","hurry","expires","bonus","win","prize","winner","congratulations","claim your","earn money","work from home","make money","get rich","investment","profit","guaranteed","risk free","no obligation","free trial","subscribe","follow us","like and share","dm me","link in bio","swipe up","check out my","follow me","instagram\\.com","onlyfans","cashapp","venmo","paypal\\.me","bitcoin","crypto","nft","affiliate","referral","commission"]}static{this.DEFAULT_INAPPROPRIATE_PATTERNS=["fuck","shit","damn","hell","ass","bitch","bastard","crap","piss","cock","dick","pussy","tits","boobs","sex","porn","nude","naked","xxx","adult","escort","hookup","dating","kill","murder","suicide","die","death","violence","hate","racist","nazi","terrorism","bomb","weapon","gun","knife","drug","cocaine","heroin","marijuana","weed","cannabis","alcohol","drink","drunk","beer","wine","vodka","whiskey"]}static{this.DEFAULT_UNRELATED_PATTERNS=["hotdog[,!\\s]+that's amazing","hotdog[,!\\s]+that is amazing","hotdog[,!\\s]+wow","hotdog[,!\\s]+incredible","hotdog[,!\\s]+unbelievable","hotdog[,!\\s]+no way","hotdog[,!\\s]+really","hotdog[,!\\s]+seriously","hotdog[,!\\s]+damn","hotdog[,!\\s]+dude","hotdog[,!\\s]+man","hotdog[,!\\s]+bro","hotdog[,!\\s]+yo","hotdog[,!\\s]+wait","hotdog[,!\\s]+hold on","hotdog[,!\\s]+what","hotdog[,!\\s]+how","hotdog[,!\\s]+why","hotdog[,!\\s]+when","hotdog[,!\\s]+where","hotdog[,!\\s]+omg","hotdog[,!\\s]+oh my god","hotdog[,!\\s]+jesus","hotdog[,!\\s]+christ","hotdog[,!\\s]+wtf","hotdog[,!\\s]+lol","hotdog[,!\\s]+lmao","hotdog[,!\\s]+haha","hotdog[,!\\s]+this is","hotdog[,!\\s]+that was","hotdog[,!\\s]+you are","hotdog[,!\\s]+he is","hotdog[,!\\s]+she is","hotdog[,!\\s]+it is","hotdog[,!\\s]+we are","hotdog[,!\\s]+they are"]}static{this.DEFAULT_REQUIRED_PATTERNS=["hot\\s*dog","hotdog","hot-dog","frankfurter","wiener","sausage","bratwurst","polish sausage","kielbasa","chorizo","andouille","breakfast sausage","italian sausage","coney","chili dog","corn dog","pigs in a blanket","vienna sausage","cocktail sausage","breakfast link","smoked sausage","turkey dog","veggie dog","tofu dog","plant-based dog","vegan dog","beef frank","all beef","kosher dog","hebrew national","nathan's","ballpark frank","oscar mayer","johnsonville","hillshire farm","sabretts","hebrew national","dirty water dog","street dog","stadium dog","baseball dog","fair dog","carnival dog","cart dog","vendor dog","foot long","quarter pound","jumbo dog","mini dog","cocktail weenie","little smokie","pig in blanket","mustard","ketchup","relish","onions","sauerkraut","chili","cheese","bun","roll","bread","grill","bbq","barbecue","cookout","picnic","baseball game","stadium","ballpark","fair","carnival","street vendor","food truck","cart","stand"]}async getFilterPatterns(){try{return(await e.db.query("SELECT * FROM filter_patterns WHERE is_enabled = true ORDER BY pattern_type, created_at")).rows}catch(a){return await (0,e.rP)(f.$b.ERROR,"Failed to get filter patterns","FilteringService",{error:a instanceof Error?a.message:"Unknown error"}),[]}}async isSpamContent(a){try{let b=await this.getPatternsByType("spam"),c=[],d=0,e=a.toLowerCase().trim();for(let a of b)(a.is_regex?RegExp(a.pattern,"i"):RegExp(a.pattern.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"i")).test(e)&&(c.push(a.pattern),d+=1);let f=(e.match(/https?:\/\/\S+/g)||[]).length,g=(e.match(/\S+@\S+\.\S+/g)||[]).length,h=(e.match(/\d{3}[-.]?\d{3}[-.]?\d{4}/g)||[]).length,i=(e.match(/!/g)||[]).length,j=(e.match(/[A-Z]/g)||[]).length/e.length;f>2&&(c.push("excessive_urls"),d+=2),g>1&&(c.push("multiple_emails"),d+=2),h>0&&(c.push("phone_number"),d+=1),i>3&&(c.push("excessive_exclamations"),d+=1),j>.5&&e.length>10&&(c.push("excessive_caps"),d+=1);let k=Math.min(d/5,1);return{isSpam:k>.6,patterns:c,confidence:k}}catch(a){return await (0,e.rP)(f.$b.ERROR,"Failed to check spam content","FilteringService",{error:a instanceof Error?a.message:"Unknown error"}),{isSpam:!1,patterns:[],confidence:0}}}async isInappropriateContent(a){try{let b=await this.getPatternsByType("inappropriate"),c=[],d=0,e=a.toLowerCase().trim();for(let a of b)(a.is_regex?RegExp(a.pattern,"i"):RegExp(a.pattern.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"i")).test(e)&&(c.push(a.pattern),d+=1);let f=Math.min(d/3,1);return{isInappropriate:f>.3,patterns:c,confidence:f}}catch(a){return await (0,e.rP)(f.$b.ERROR,"Failed to check inappropriate content","FilteringService",{error:a instanceof Error?a.message:"Unknown error"}),{isInappropriate:!1,patterns:[],confidence:0}}}async isUnrelatedContent(a){try{let b=await this.getPatternsByType("unrelated"),c=[],d=0,e=a.toLowerCase().trim();for(let a of b)(a.is_regex?RegExp(a.pattern,"i"):RegExp(a.pattern.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"i")).test(e)&&(c.push(a.pattern),d+=1);let f=Math.min(d/2,1);return{isUnrelated:f>.5,patterns:c,confidence:f}}catch(a){return await (0,e.rP)(f.$b.ERROR,"Failed to check unrelated content","FilteringService",{error:a instanceof Error?a.message:"Unknown error"}),{isUnrelated:!1,patterns:[],confidence:0}}}async isValidHotdogContent(a){try{let b=this.extractTextFromContent(a),c=[],d=await this.getPatternsByType("required"),g=!1;for(let a of d)if((a.is_regex?RegExp(a.pattern,"i"):RegExp(a.pattern.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"i")).test(b.toLowerCase())){g=!0;break}g||c.push("No hotdog-related terms found");let[h,i,j]=await Promise.all([this.isSpamContent(b),this.isInappropriateContent(b),this.isUnrelatedContent(b)]),k=[...h.patterns,...i.patterns,...j.patterns],l=g?.7:.3,m=.3*!!h.isSpam,n=.5*!!i.isInappropriate,o=.4*!!j.isUnrelated,p=Math.max(0,l-m-n-o),q=g&&!h.isSpam&&!i.isInappropriate&&!j.isUnrelated,r=this.generateSimilarityHash(b),s={is_spam:h.isSpam,is_inappropriate:i.isInappropriate,is_unrelated:j.isUnrelated,is_valid_hotdog:q,confidence_score:p,flagged_patterns:k,processing_notes:c,similarity_hash:r};return await (0,e.rP)(f.$b.INFO,"Content analysis completed","FilteringService",{analysis:s,textLength:b.length,hasHotdogReference:g}),s}catch(a){return await (0,e.rP)(f.$b.ERROR,"Failed to validate hotdog content","FilteringService",{error:a instanceof Error?a.message:"Unknown error"}),{is_spam:!1,is_inappropriate:!1,is_unrelated:!1,is_valid_hotdog:!1,confidence_score:0,flagged_patterns:[],processing_notes:["Analysis failed"],similarity_hash:""}}}async testFilterPattern(a,b,c){try{let d,e=(d=b?RegExp(a,"i"):RegExp(a.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"i")).test(c),f=e?c.match(d)?.[0]:void 0;return{matches:e,matchedText:f}}catch(a){return{matches:!1,error:a instanceof Error?a.message:"Invalid pattern"}}}async getFilteringStats(a,b){try{let c=a&&b?"WHERE created_at >= $1 AND created_at <= $2":"WHERE created_at >= NOW() - INTERVAL '7 days'",d=(await e.db.query(`
        SELECT 
          COUNT(*) as total_processed,
          COUNT(*) FILTER (WHERE is_approved = true AND is_flagged = false) as auto_approved,
          COUNT(*) FILTER (WHERE is_approved = false AND is_flagged = false) as auto_rejected,
          COUNT(*) FILTER (WHERE is_flagged = true) as flagged_for_review,
          COUNT(*) FILTER (WHERE filter_results->>'is_spam' = 'true') as spam_detected,
          COUNT(*) FILTER (WHERE filter_results->>'is_inappropriate' = 'true') as inappropriate_detected,
          COUNT(*) FILTER (WHERE filter_results->>'is_unrelated' = 'true') as unrelated_detected,
          COUNT(*) FILTER (WHERE duplicate_of IS NOT NULL) as duplicates_detected,
          COUNT(*) FILTER (WHERE admin_override = true AND is_approved = true) as false_positives,
          COUNT(*) FILTER (WHERE admin_override = true AND is_approved = false) as false_negatives
        FROM content_analysis ${c}
      `,a&&b?[a,b]:[])).rows[0],f=parseInt(d.total_processed),g=parseInt(d.false_positives),h=parseInt(d.false_negatives);return{total_processed:f,auto_approved:parseInt(d.auto_approved),auto_rejected:parseInt(d.auto_rejected),flagged_for_review:parseInt(d.flagged_for_review),spam_detected:parseInt(d.spam_detected),inappropriate_detected:parseInt(d.inappropriate_detected),unrelated_detected:parseInt(d.unrelated_detected),duplicates_detected:parseInt(d.duplicates_detected),false_positives:g,false_negatives:h,accuracy_rate:f>0?1-(g+h)/f:0}}catch(a){return await (0,e.rP)(f.$b.ERROR,"Failed to get filtering stats","FilteringService",{error:a instanceof Error?a.message:"Unknown error"}),{total_processed:0,auto_approved:0,auto_rejected:0,flagged_for_review:0,spam_detected:0,inappropriate_detected:0,unrelated_detected:0,duplicates_detected:0,false_positives:0,false_negatives:0,accuracy_rate:0}}}async getPatternsByType(a){try{let b=await e.db.query("SELECT * FROM filter_patterns WHERE pattern_type = $1 AND is_enabled = true",[a]);if(0===b.rows.length)return await this.getDefaultPatterns(a);return b.rows}catch(b){return await this.getDefaultPatterns(a)}}async getDefaultPatterns(a){return(({spam:j.DEFAULT_SPAM_PATTERNS,inappropriate:j.DEFAULT_INAPPROPRIATE_PATTERNS,unrelated:j.DEFAULT_UNRELATED_PATTERNS,required:j.DEFAULT_REQUIRED_PATTERNS})[a]||[]).map((b,c)=>({id:c,pattern_type:a,pattern:b,description:`Default ${a} pattern`,is_regex:!0,is_enabled:!0,created_at:new Date,updated_at:new Date}))}extractTextFromContent(a){let b=[];return a.content_text&&b.push(a.content_text),a.original_author&&b.push(a.original_author),a.alt_text&&b.push(a.alt_text),a.caption&&b.push(a.caption),b.join(" ").trim()}generateSimilarityHash(a){let b=a.toLowerCase().replace(/[^\w\s]/g,"").replace(/\s+/g," ").trim();return h().createHash("md5").update(b).digest("hex")}}let k=new j;d()}catch(a){d(a)}})}};