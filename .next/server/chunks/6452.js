"use strict";exports.id=6452,exports.ids=[6452],exports.modules={46024:(a,b,c)=>{c.a(a,async(a,d)=>{try{c.d(b,{r_:()=>t});var e=c(32190),f=c(99986),g=c(23870),h=a([f]);f=(h.then?(await h)():h)[0];class i extends Error{constructor(a,b,c=500,d=!0,e,f,g){super(a),this.name="CustomError",this.category=b,this.statusCode=c,this.isOperational=d,this.context=e,this.userId=f,this.requestId=g,Error.captureStackTrace(this,i)}}class j extends i{constructor(a,b,c){super(a,"validation",400,!0,b,void 0,c),this.name="ValidationError"}}class k extends i{constructor(a,b,c){super(a,"database",500,!0,b,void 0,c),this.name="DatabaseError"}}class l extends i{constructor(a,b,c){super(a,"network",503,!0,b,void 0,c),this.name="NetworkError"}}class m extends i{constructor(a,b,c){super(a,"authentication",401,!0,b,void 0,c),this.name="AuthenticationError"}}class n extends i{constructor(a,b,c){super(a,"authorization",403,!0,b,void 0,c),this.name="AuthorizationError"}}class o extends i{constructor(a,b,c){super(a,"external_api",502,!0,b,void 0,c),this.name="ExternalAPIError"}}class p extends i{constructor(a,b,c){super(a,"rate_limit",429,!0,b,void 0,c),this.name="RateLimitError"}}class q extends i{constructor(a,b,c){super(a,"timeout",504,!0,b,void 0,c),this.name="TimeoutError"}}class r extends i{constructor(a,b,c){super(a,"not_found",404,!0,b,void 0,c),this.name="NotFoundError"}}class s{static getInstance(){return s.instance||(s.instance=new s),s.instance}async handleError(a,b,c){let d=this.buildErrorContext(b,c),e=this.categorizeError(a,d);return await this.logError(e,d),this.generateErrorResponse(e,d)}withErrorHandling(a){return async(b,c)=>{try{return await a(b,c)}catch(a){return this.handleError(a,b,c)}}}async withCircuitBreaker(a,b,c=5,d=3e4,e=6e4){let f=`circuit_${b}`,g=`failures_${b}`,h=this.getCircuitFailures(g),i=this.getLastFailureTime(f);if(h>=c){let a=Date.now()-i;if(a<e)throw new o(`Circuit breaker open for ${b}`,{serviceName:b,failures:h,timeSinceLastFailure:a,resetTimeoutMs:e});this.resetCircuitBreaker(g,f)}try{let b=await Promise.race([a(),new Promise((a,b)=>setTimeout(()=>b(new q(`Operation timed out after ${d}ms`)),d))]);return this.resetCircuitBreaker(g,f),b}catch(a){if(this.recordCircuitFailure(g,f),a instanceof q)throw a;throw new o(`${b} operation failed`,{serviceName:b,originalError:a.message})}}async withRetry(a,b=3,c=1e3,d=1e4,e=2){let g;for(let h=0;h<=b;h++)try{return await a()}catch(l){if(g=l,l instanceof j||l instanceof m||l instanceof n||l instanceof r||h===b)throw l;let a=Math.min(c*Math.pow(e,h),d),i=.1*Math.random()*a,k=a+i;await f.RE.logWarning("ErrorHandlingMiddleware",`Retrying operation (attempt ${h+1}/${b+1})`,{attempt:h,delay:k,error:l.message}),await new Promise(a=>setTimeout(a,k))}throw g}buildErrorContext(a,b){return{requestId:b?.requestId||(0,g.A)(),userId:b?.userId,sessionId:b?.sessionId,path:a.nextUrl.pathname,method:a.method,userAgent:a.headers.get("user-agent")||void 0,ip:a.ip||a.headers.get("x-forwarded-for")||void 0,timestamp:new Date,...b}}categorizeError(a,b){if(a instanceof i)return{...a,requestId:b.requestId,userId:b.userId};let c=a.message.toLowerCase();return c.includes("timeout")||c.includes("timed out")?new q(a.message,{originalError:a.name},b.requestId):c.includes("network")||c.includes("connection")||c.includes("econnrefused")?new l(a.message,{originalError:a.name},b.requestId):c.includes("database")||c.includes("query")||c.includes("sql")?new k(a.message,{originalError:a.name},b.requestId):c.includes("validation")||c.includes("invalid")||c.includes("required")?new j(a.message,{originalError:a.name},b.requestId):c.includes("unauthorized")||c.includes("authentication")?new m(a.message,{originalError:a.name},b.requestId):c.includes("forbidden")||c.includes("permission")?new n(a.message,{originalError:a.name},b.requestId):c.includes("rate limit")||c.includes("too many requests")?new p(a.message,{originalError:a.name},b.requestId):c.includes("not found")||c.includes("404")?new r(a.message,{originalError:a.name},b.requestId):new i(a.message,"internal",500,!1,{originalError:a.name,stack:a.stack},b.userId,b.requestId)}async logError(a,b){let c=this.sanitizeContext(b),d={category:a.category,statusCode:a.statusCode,isOperational:a.isOperational,context:a.context,requestContext:c,userAgent:b.userAgent,ip:b.ip};a.statusCode>=500?await f.RE.logError("ErrorHandlingMiddleware",a.message,d,a,{userId:b.userId,sessionId:b.sessionId,requestId:b.requestId}):a.statusCode>=400&&await f.RE.logWarning("ErrorHandlingMiddleware",a.message,d,{userId:b.userId,sessionId:b.sessionId,requestId:b.requestId})}generateErrorResponse(a,b){let c={error:{message:a.message,category:a.category,requestId:b.requestId,timestamp:b.timestamp.toISOString(),...!1}},d={"Content-Type":"application/json","X-Request-ID":b.requestId};return a instanceof p&&(d["Retry-After"]="60",d["X-RateLimit-Remaining"]="0"),e.NextResponse.json(c,{status:a.statusCode,headers:d})}sanitizeContext(a){if(!a||"object"!=typeof a)return a;let b={...a};for(let a in b){let c=a.toLowerCase();this.sensitiveFields.some(a=>c.includes(a))?b[a]="[REDACTED]":"object"==typeof b[a]&&(b[a]=this.sanitizeContext(b[a]))}return b}getCircuitFailures(a){return this.circuitState.get(a)||0}getLastFailureTime(a){return this.circuitTimestamps.get(a)||0}recordCircuitFailure(a,b){let c=this.circuitState.get(a)||0;this.circuitState.set(a,c+1),this.circuitTimestamps.set(b,Date.now())}resetCircuitBreaker(a,b){this.circuitState.delete(a),this.circuitTimestamps.delete(b)}constructor(){this.sensitiveFields=["password","token","secret","key","authorization","cookie","session","jwt","auth","credentials"],this.circuitState=new Map,this.circuitTimestamps=new Map}}let t=s.getInstance();d()}catch(a){d(a)}})},59794:(a,b,c)=>{c.a(a,async(a,d)=>{try{c.d(b,{VQ:()=>o,WX:()=>q});var e=c(7462),f=c(55229),g=c(99986),h=c(68051),i=c(90467),j=c(6901),k=c(24991),l=c(303),m=c(84749),n=a([e,f,g,h,i,j,k,l,m]);[e,f,g,h,i,j,k,l,m]=n.then?(await n)():n;var o=function(a){return a.HEALTHY="healthy",a.WARNING="warning",a.CRITICAL="critical",a.UNKNOWN="unknown",a}({});class p{constructor(){this.dependencies=[],this.startTime=new Date,this.registerDependencies()}async checkDatabaseHealth(){let a=Date.now(),b="healthy",c="Database is healthy",d={};try{await e.db.query("SELECT 1 as health_check");let g=e.db.getPoolStats(),h=Date.now();await (0,f.P)("system_logs").select(["id"]).limit(1).execute();let i=Date.now()-h,j=0;i>1e3&&(j=1,b="warning",c="Database queries are running slowly");let k=g.active/g.total*100;return k>80&&(b="warning",c="Database connection pool utilization is high"),k>95&&(b="critical",c="Database connection pool is nearly exhausted"),d={poolStats:g,queryTime:i,poolUtilization:Math.round(k)},{name:"Database",status:b,message:c,responseTime:Date.now()-a,lastChecked:new Date,metadata:d,connectionPool:{total:g.total,idle:g.idle,active:g.active},queryPerformance:{averageResponseTime:i,slowQueries:j}}}catch(b){return await g.RE.logError("HealthService","Database health check failed",{error:b.message},b),{name:"Database",status:"critical",message:`Database connection failed: ${b.message}`,responseTime:Date.now()-a,lastChecked:new Date,metadata:{error:b.message},connectionPool:{total:0,idle:0,active:0},queryPerformance:{averageResponseTime:0,slowQueries:0}}}}async checkSocialMediaAPIs(){let[a,b,c]=await Promise.allSettled([this.checkRedditAPI(),this.checkInstagramAPI(),this.checkTikTokAPI()]);return{reddit:"fulfilled"===a.status?a.value:this.createFailedAPICheck("Reddit",a.reason),instagram:"fulfilled"===b.status?b.value:this.createFailedAPICheck("Instagram",b.reason),tiktok:"fulfilled"===c.status?c.value:this.createFailedAPICheck("TikTok",c.reason)}}async checkRedditAPI(){let a=Date.now();try{let b=await h.redditService.getApiStatus(),c="healthy",d="Reddit API is healthy";return b.isConnected?b.rateLimits.remaining<10&&(c="warning",d="Reddit API rate limit is low"):(c="critical",d="Reddit API is not connected"),{name:"Reddit API",status:c,message:d,responseTime:Date.now()-a,lastChecked:new Date,endpoint:"Reddit API",rateLimits:{remaining:b.rateLimits.remaining,resetTime:b.rateLimits.resetTime},metadata:{userAgent:b.userAgent,lastRequest:b.lastRequest}}}catch(b){return{name:"Reddit API",status:"critical",message:`Reddit API check failed: ${b.message}`,responseTime:Date.now()-a,lastChecked:new Date,metadata:{error:b.message}}}}async checkInstagramAPI(){let a=Date.now();try{let b=await i.E.getApiStatus(),c="healthy",d="Instagram API is healthy";return b.isAuthenticated?b.rateLimits.remaining<10&&(c="warning",d="Instagram API rate limit is low"):(c="critical",d="Instagram API is not authenticated"),b.tokenExpiresAt&&(new Date(b.tokenExpiresAt).getTime()-Date.now())/36e5<24&&(c="warning",d="Instagram API token expires soon"),{name:"Instagram API",status:c,message:d,responseTime:Date.now()-a,lastChecked:new Date,endpoint:"Instagram Basic Display API",rateLimits:{remaining:b.rateLimits.remaining,resetTime:b.rateLimits.resetTime},metadata:{tokenExpiresAt:b.tokenExpiresAt,lastRequest:b.lastRequest}}}catch(b){return{name:"Instagram API",status:"critical",message:`Instagram API check failed: ${b.message}`,responseTime:Date.now()-a,lastChecked:new Date,metadata:{error:b.message}}}}async checkTikTokAPI(){let a=Date.now();try{let b=await j.u.getApiStatus(),c="healthy",d="TikTok API is healthy";if(b.isAuthenticated){let a=b.quota.hourly.used/b.quota.hourly.limit*100,e=b.quota.daily.used/b.quota.daily.limit*100;a>90||e>90?(c="critical",d="TikTok API quota is nearly exhausted"):(a>80||e>80)&&(c="warning",d="TikTok API quota usage is high")}else c="critical",d="TikTok API is not authenticated";return{name:"TikTok API",status:c,message:d,responseTime:Date.now()-a,lastChecked:new Date,endpoint:"TikTok Research API",quotaUsage:{used:b.quota.daily.used,limit:b.quota.daily.limit,percentage:Math.round(b.quota.daily.used/b.quota.daily.limit*100)},metadata:{hourlyQuota:b.quota.hourly,dailyQuota:b.quota.daily,tokenExpiresAt:b.tokenExpiresAt}}}catch(b){return{name:"TikTok API",status:"critical",message:`TikTok API check failed: ${b.message}`,responseTime:Date.now()-a,lastChecked:new Date,metadata:{error:b.message}}}}async checkContentQueue(){let a=Date.now();try{let b=await (0,f.P)("content_queue").select(["status","COUNT(*) as count"]).groupBy("status").execute(),c={pending:0,approved:0,rejected:0,flagged:0,total:0};b.forEach(a=>{let b=parseInt(a.count);c.total+=b,a.status in c&&(c[a.status]=b)});let d="healthy",e="Content queue is healthy";c.pending<5&&(d="warning",e="Content queue is running low on pending items"),c.pending>1e3&&(d="warning",e="Content queue has a large backlog");let g=c.total>0?c.flagged/c.total*100:0;return g>20&&(d="warning",e="High percentage of content is being flagged"),{name:"Content Queue",status:d,message:e,responseTime:Date.now()-a,lastChecked:new Date,metadata:{queueStats:c,flaggedPercentage:Math.round(g)}}}catch(b){return await g.RE.logError("HealthService","Content queue health check failed",{error:b.message},b),{name:"Content Queue",status:"critical",message:`Content queue check failed: ${b.message}`,responseTime:Date.now()-a,lastChecked:new Date,metadata:{error:b.message}}}}async checkScheduler(){let a=Date.now();try{let b=await (0,f.P)("posted_content").select(["posted_at"]).where("posted_at",">",new Date(Date.now()-864e5)).count("*").first(),c=parseInt(b?.count||"0"),d="healthy",e="Scheduler is working normally";0===c?(d="critical",e="No posts have been made in the last 24 hours"):c<6&&(d="warning",e=`Only ${c} posts made in last 24h (expected 6)`);let g=(await Promise.allSettled([k.L.getScanStats(),l.t.getScanStats(),m.f.getScanStats()])).filter(a=>"fulfilled"===a.status).length;return{name:"Scheduler",status:d,message:e,responseTime:Date.now()-a,lastChecked:new Date,metadata:{postsLast24h:c,expectedPosts:6,activeScanners:g,totalScanners:3}}}catch(b){return await g.RE.logError("HealthService","Scheduler health check failed",{error:b.message},b),{name:"Scheduler",status:"critical",message:`Scheduler check failed: ${b.message}`,responseTime:Date.now()-a,lastChecked:new Date,metadata:{error:b.message}}}}async checkSystemResources(){let a=Date.now();try{let b=process.memoryUsage(),c={rss:Math.round(b.rss/1024/1024),heapTotal:Math.round(b.heapTotal/1024/1024),heapUsed:Math.round(b.heapUsed/1024/1024),external:Math.round(b.external/1024/1024)},d="healthy",e="Memory usage is normal";c.heapUsed>512&&(d="warning",e="Memory usage is high"),c.heapUsed>1024&&(d="critical",e="Memory usage is critical");let f=process.cpuUsage();return{memory:{name:"Memory",status:d,message:e,responseTime:Date.now()-a,lastChecked:new Date,metadata:c},disk:{name:"Disk",status:"healthy",message:"Disk space is adequate",responseTime:Date.now()-a,lastChecked:new Date,metadata:{}},cpu:{name:"CPU",status:"healthy",message:"CPU usage is normal",responseTime:Date.now()-a,lastChecked:new Date,metadata:{user:Math.round(f.user/1e3),system:Math.round(f.system/1e3)}}}}catch(c){let b={name:"System Resources",status:"critical",message:`System resource check failed: ${c.message}`,responseTime:Date.now()-a,lastChecked:new Date,metadata:{error:c.message}};return{memory:b,disk:b,cpu:b}}}async generateHealthReport(){let a=Date.now();try{let[b,c,d,e,f]=await Promise.allSettled([this.checkDatabaseHealth(),this.checkSocialMediaAPIs(),this.checkContentQueue(),this.checkScheduler(),this.checkSystemResources()]),h="fulfilled"===b.status?b.value:this.createFailedCheck("Database",b.reason),i="fulfilled"===c.status?c.value:{reddit:this.createFailedAPICheck("Reddit",c.reason),instagram:this.createFailedAPICheck("Instagram",c.reason),tiktok:this.createFailedAPICheck("TikTok",c.reason)},j="fulfilled"===d.status?d.value:this.createFailedCheck("Content Queue",d.reason),k="fulfilled"===e.status?e.value:this.createFailedCheck("Scheduler",e.reason),l="fulfilled"===f.status?f.value:{memory:this.createFailedCheck("Memory",f.reason),disk:this.createFailedCheck("Disk",f.reason),cpu:this.createFailedCheck("CPU",f.reason)},m={name:"Logging",status:"healthy",message:"Logging service is operational",responseTime:0,lastChecked:new Date},n=[h,i.reddit,i.instagram,i.tiktok,j,k,m,l.memory,l.disk,l.cpu],o={totalChecks:n.length,healthyChecks:n.filter(a=>"healthy"===a.status).length,warningChecks:n.filter(a=>"warning"===a.status).length,criticalChecks:n.filter(a=>"critical"===a.status).length,responseTime:Date.now()-a},p="healthy";o.criticalChecks>0?p="critical":o.warningChecks>0&&(p="warning");let q=Date.now()-this.startTime.getTime(),r={overallStatus:p,timestamp:new Date,uptime:Math.round(q/1e3),checks:{database:h,apis:i,services:{contentQueue:j,scheduler:k,logging:m},system:l},summary:o};return await g.RE.logInfo("HealthService","Health report generated",{overallStatus:p,summary:o,uptime:r.uptime}),r}catch(a){throw await g.RE.logError("HealthService","Failed to generate health report",{error:a.message},a),a}}registerDependencies(){this.dependencies=[{name:"Database",type:"database",critical:!0,healthCheck:()=>this.checkDatabaseHealth()},{name:"Content Queue",type:"service",critical:!0,healthCheck:()=>this.checkContentQueue()},{name:"Scheduler",type:"service",critical:!1,healthCheck:()=>this.checkScheduler()}]}createFailedCheck(a,b){return{name:a,status:"critical",message:`Health check failed: ${b?.message||b}`,responseTime:0,lastChecked:new Date,metadata:{error:b?.message||b}}}createFailedAPICheck(a,b){return{name:`${a} API`,status:"critical",message:`API health check failed: ${b?.message||b}`,responseTime:0,lastChecked:new Date,metadata:{error:b?.message||b}}}getUptime(){return Date.now()-this.startTime.getTime()}async isHealthy(){try{let a=await this.generateHealthReport();return"healthy"===a.overallStatus||"warning"===a.overallStatus}catch{return!1}}}let q=new p;d()}catch(a){d(a)}})}};