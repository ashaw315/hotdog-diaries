exports.id=2535,exports.ids=[2535],exports.modules={7462:(a,b,c)=>{"use strict";c.a(a,async(a,d)=>{try{c.d(b,{db:()=>j,rP:()=>h});var e=c(64939),f=c(83376),g=a([e]);e=(g.then?(await g)():g)[0];class i{constructor(){this.pool=null,this.isVercel=!1,this.isVercel=!!process.env.POSTGRES_URL}getConfig(){return this.isVercel?{host:process.env.POSTGRES_HOST,port:5432,database:process.env.POSTGRES_DATABASE,user:process.env.POSTGRES_USER,password:process.env.POSTGRES_PASSWORD,ssl:!0,max:20,idleTimeoutMillis:3e4,connectionTimeoutMillis:2e3}:{host:process.env.DATABASE_HOST||"localhost",port:parseInt(process.env.DATABASE_PORT||"5432"),database:process.env.DATABASE_NAME||"hotdog_diaries_dev",user:process.env.DATABASE_USER||"postgres",password:process.env.DATABASE_PASSWORD||"password",ssl:!1,max:10,idleTimeoutMillis:3e4,connectionTimeoutMillis:2e3}}async connect(){if(this.pool)return;let a=this.getConfig();this.pool=new e.Pool(a),this.pool.on("error",a=>{console.error("Unexpected database error on idle client",a)}),this.pool.on("connect",()=>{console.log("Database connection established")}),this.pool.on("remove",()=>{console.log("Database connection removed")});try{let a=await this.pool.connect();await a.query("SELECT NOW()"),a.release(),console.log("Database connection successful")}catch(a){throw console.error("Database connection failed:",a),a}}async disconnect(){this.pool&&(await this.pool.end(),this.pool=null,console.log("Database connection closed"))}async query(a,b){if(this.isVercel)return await f.ll.query(a,b||[]);this.pool||await this.connect();let c=Date.now();try{let d=await this.pool.query(a,b),e=Date.now()-c;return console.log("Query executed",{text:a,duration:e,rows:d.rowCount}),d}catch(d){let b=Date.now()-c;throw console.error("Query error",{text:a,duration:b,error:d}),d}}async getClient(){if(this.isVercel)throw Error("Client connections not supported in Vercel environment");if(!this.pool)throw Error("Database not connected");return await this.pool.connect()}async healthCheck(){try{let a=Date.now();await this.query("SELECT 1 as health_check");let b=Date.now()-a;return{connected:!0,latency:b}}catch(a){return{connected:!1,error:a instanceof Error?a.message:"Unknown error"}}}async transaction(a){if(this.isVercel)throw Error("Transactions not supported in Vercel environment with @vercel/postgres");let b=await this.getClient();try{await b.query("BEGIN");let c=await a(b);return await b.query("COMMIT"),c}catch(a){throw await b.query("ROLLBACK"),a}finally{b.release()}}}let j=new i;async function h(a,b,c,d){try{await j.query(`INSERT INTO system_logs (log_level, message, component, metadata, created_at)
       VALUES ($1, $2, $3, $4, NOW())`,[a,b,c,d?JSON.stringify(d):null])}catch(a){console.error("Failed to log to database:",a)}}d()}catch(a){d(a)}})},47990:()=>{},55229:(a,b,c)=>{"use strict";c.a(a,async(a,d)=>{try{c.d(b,{AW:()=>n,P:()=>k,Yr:()=>l,yo:()=>m});var e=c(7462),f=a([e]);e=(f.then?(await f)():f)[0];class g{static table(a){let b=new g;return b.fromTable=a,b}select(a){return"string"==typeof a?this.selectFields=[a]:this.selectFields=a,this}where(a,b,c){return this.whereConditions.push({field:a,operator:b,value:c}),this}whereIn(a,b){return this.whereConditions.push({field:a,operator:"IN",values:b}),this}whereNotIn(a,b){return this.whereConditions.push({field:a,operator:"NOT IN",values:b}),this}whereNull(a){return this.whereConditions.push({field:a,operator:"IS NULL"}),this}whereNotNull(a){return this.whereConditions.push({field:a,operator:"IS NOT NULL"}),this}orderBy(a,b="ASC"){return this.orderByFields.push({field:a,direction:b}),this}join(a,b,c="INNER"){return this.joinClauses.push({type:c,table:a,on:b}),this}leftJoin(a,b){return this.join(a,b,"LEFT")}limit(a){return this.limitCount=a,this}offset(a){return this.offsetCount=a,this}build(){this.parameters=[];let a=1,b=`SELECT ${this.selectFields.join(", ")}`,c=`FROM ${this.fromTable}`;this.joinClauses.length>0&&(c+=" "+this.joinClauses.map(a=>`${a.type} JOIN ${a.table} ON ${a.on}`).join(" "));let d="";if(this.whereConditions.length>0){let b=this.whereConditions.map(b=>{switch(b.operator){case"IS NULL":case"IS NOT NULL":return`${b.field} ${b.operator}`;case"IN":case"NOT IN":if(!b.values||0===b.values.length)throw Error(`${b.operator} requires non-empty values array`);let c=b.values.map(()=>`$${a++}`).join(", ");return this.parameters.push(...b.values),`${b.field} ${b.operator} (${c})`;default:return this.parameters.push(b.value),`${b.field} ${b.operator} $${a++}`}});d=`WHERE ${b.join(" AND ")}`}let e="";if(this.orderByFields.length>0){let a=this.orderByFields.map(a=>`${a.field} ${a.direction}`).join(", ");e=`ORDER BY ${a}`}let f="";void 0!==this.limitCount&&(f=`LIMIT $${a++}`,this.parameters.push(this.limitCount));let g="";return void 0!==this.offsetCount&&(g=`OFFSET $${a++}`,this.parameters.push(this.offsetCount)),{query:[b,c,d,e,f,g].filter(Boolean).join(" "),params:this.parameters}}async execute(){let{query:a,params:b}=this.build();return await e.db.query(a,b)}async first(){return(await this.limit(1).execute()).rows[0]||null}async count(){let a=this.selectFields;this.selectFields=["COUNT(*) as count"];let b=await this.execute();return this.selectFields=a,parseInt(b.rows[0]?.count||"0")}constructor(){this.selectFields=["*"],this.fromTable="",this.whereConditions=[],this.orderByFields=[],this.joinClauses=[],this.parameters=[]}}class h{static into(a){let b=new h;return b.tableName=a,b}values(a){return this.insertData={...this.insertData,...a},this}returning(a){return"string"==typeof a?this.returnFields=[a]:this.returnFields=a,this}onConflict(a,b,c){return this.conflictTarget=a,this.conflictAction=b,this.updateData=c,this}onConflictDoNothing(a){return this.onConflict(a,"DO NOTHING")}onConflictDoUpdate(a,b){return this.onConflict(a,"DO UPDATE",b)}build(){let a=Object.keys(this.insertData),b=Object.values(this.insertData),c=a.map((a,b)=>`$${b+1}`).join(", "),d=`INSERT INTO ${this.tableName} (${a.join(", ")}) VALUES (${c})`;if(this.conflictTarget&&this.conflictAction&&(d+=` ON CONFLICT (${this.conflictTarget}) ${this.conflictAction}`,"DO UPDATE"===this.conflictAction&&this.updateData)){let a=Object.keys(this.updateData).map(a=>`${a} = EXCLUDED.${a}`).join(", ");d+=` SET ${a}`}return this.returnFields.length>0&&(d+=` RETURNING ${this.returnFields.join(", ")}`),{query:d,params:b}}async execute(){let{query:a,params:b}=this.build();return await e.db.query(a,b)}async first(){return(await this.execute()).rows[0]||null}constructor(){this.tableName="",this.insertData={},this.returnFields=["*"]}}class i{static table(a){let b=new i;return b.tableName=a,b}set(a){return this.updateData={...this.updateData,...a},this}where(a,b,c){return this.whereConditions.push({field:a,operator:b,value:c}),this}returning(a){return"string"==typeof a?this.returnFields=[a]:this.returnFields=a,this}build(){this.parameters=[];let a=1,b=Object.keys(this.updateData).map(b=>(this.parameters.push(this.updateData[b]),`${b} = $${a++}`)).join(", "),c=`UPDATE ${this.tableName} SET ${b}`;if(this.whereConditions.length>0){let b=this.whereConditions.map(b=>"IS NULL"===b.operator||"IS NOT NULL"===b.operator?`${b.field} ${b.operator}`:(this.parameters.push(b.value),`${b.field} ${b.operator} $${a++}`));c+=` WHERE ${b.join(" AND ")}`}return this.returnFields.length>0&&(c+=` RETURNING ${this.returnFields.join(", ")}`),{query:c,params:this.parameters}}async execute(){let{query:a,params:b}=this.build();return await e.db.query(a,b)}async first(){return(await this.execute()).rows[0]||null}constructor(){this.tableName="",this.updateData={},this.whereConditions=[],this.returnFields=["*"],this.parameters=[]}}class j{static from(a){let b=new j;return b.tableName=a,b}where(a,b,c){return this.whereConditions.push({field:a,operator:b,value:c}),this}returning(a){return"string"==typeof a?this.returnFields=[a]:this.returnFields=a,this}build(){this.parameters=[];let a=1,b=`DELETE FROM ${this.tableName}`;if(this.whereConditions.length>0){let c=this.whereConditions.map(b=>"IS NULL"===b.operator||"IS NOT NULL"===b.operator?`${b.field} ${b.operator}`:(this.parameters.push(b.value),`${b.field} ${b.operator} $${a++}`));b+=` WHERE ${c.join(" AND ")}`}return this.returnFields.length>0&&(b+=` RETURNING ${this.returnFields.join(", ")}`),{query:b,params:this.parameters}}async execute(){let{query:a,params:b}=this.build();return await e.db.query(a,b)}async first(){return(await this.execute()).rows[0]||null}constructor(){this.tableName="",this.whereConditions=[],this.returnFields=["*"],this.parameters=[]}}let k=g.table,l=h.into,m=i.table,n=j.from;d()}catch(a){d(a)}})},78335:()=>{},96487:()=>{},99986:(a,b,c)=>{"use strict";c.a(a,async(a,d)=>{try{c.d(b,{RE:()=>i});var e=c(55229),f=c(7462),g=a([e,f]);[e,f]=g.then?(await g)():g;class h{constructor(){this.maxBatchSize=100,this.flushInterval=5e3,this.logBuffer=[],this.environment="production",this.startPeriodicFlush()}async logError(a,b,c,d,e){let f={level:"error",component:a,message:b,metadata:{...c,...d&&{errorName:d.name,errorMessage:d.message,errorCode:d.code}},timestamp:new Date,stackTrace:d?.stack,userId:e?.userId,sessionId:e?.sessionId,requestId:e?.requestId,environment:this.environment};await this.addToBuffer(f),console.error(`[${a}] ${b}`,{metadata:c,stack:d?.stack,timestamp:f.timestamp.toISOString()})}async logInfo(a,b,c,d){let e={level:"info",component:a,message:b,metadata:c,timestamp:new Date,userId:d?.userId,sessionId:d?.sessionId,requestId:d?.requestId,environment:this.environment};await this.addToBuffer(e),"development"===this.environment&&console.log(`[${a}] ${b}`,c)}async logWarning(a,b,c,d){let e={level:"warning",component:a,message:b,metadata:c,timestamp:new Date,userId:d?.userId,sessionId:d?.sessionId,requestId:d?.requestId,environment:this.environment};await this.addToBuffer(e),console.warn(`[${a}] ${b}`,c)}async logDebug(a,b,c,d){if("development"!==this.environment)return;let e={level:"debug",component:a,message:b,metadata:c,timestamp:new Date,userId:d?.userId,sessionId:d?.sessionId,requestId:d?.requestId,environment:this.environment};await this.addToBuffer(e),console.debug(`[${a}] ${b}`,c)}async queryLogs(a={}){try{let{level:b,component:c,dateRange:d,search:f,limit:g=100,offset:h=0,userId:i,requestId:j}=a,k=(0,e.P)("system_logs").select(["id","level","component","message","metadata","timestamp","stack_trace","user_id","session_id","request_id","environment"]).orderBy("timestamp","DESC");b&&b.length>0&&(k=k.whereIn("level",b)),c&&c.length>0&&(k=k.whereIn("component",c)),d&&(k=k.where("timestamp",">=",d.start).where("timestamp","<=",d.end)),f&&(k=k.where("message","ILIKE",`%${f}%`)),i&&(k=k.where("user_id",i)),j&&(k=k.where("request_id",j));let l=k.clone().count("*"),m=await l.first(),n=parseInt(m?.count||"0"),o=(await k.limit(g).offset(h).execute()).map(a=>({id:a.id,level:a.level,component:a.component,message:a.message,metadata:a.metadata,timestamp:new Date(a.timestamp),stackTrace:a.stack_trace,userId:a.user_id,sessionId:a.session_id,requestId:a.request_id,environment:a.environment}));return{logs:o,total:n,hasMore:h+o.length<n}}catch(a){throw console.error("Failed to query logs:",a),Error(`Log query failed: ${a.message}`)}}async getLogStatistics(a){try{let b=(0,e.P)("system_logs");a&&(b=b.where("timestamp",">=",a.start).where("timestamp","<=",a.end));let c=await b.clone().select(["level"]).count("* as count").groupBy("level").execute(),d={totalLogs:0,errorCount:0,warningCount:0,infoCount:0,debugCount:0};c.forEach(a=>{let b=parseInt(a.count);switch(d.totalLogs+=b,a.level){case"error":d.errorCount=b;break;case"warning":d.warningCount=b;break;case"info":d.infoCount=b;break;case"debug":d.debugCount=b}});let f=await b.clone().select(["component"]).count("* as count").groupBy("component").orderBy("count","DESC").limit(10).execute(),g=await this.queryLogs({level:["error"],limit:10,...a&&{dateRange:a}});return{...d,topComponents:f.map(a=>({component:a.component,count:parseInt(a.count)})),recentErrors:g.logs}}catch(a){throw console.error("Failed to get log statistics:",a),Error(`Log statistics query failed: ${a.message}`)}}async cleanupOldLogs(a=30){try{let b=new Date;b.setDate(b.getDate()-a);let c=await (0,e.P)("system_logs").where("timestamp","<",b).delete();return await this.logInfo("LoggingService",`Cleaned up ${c} old log entries`,{retentionDays:a,cutoffDate:b.toISOString()}),c}catch(b){throw await this.logError("LoggingService","Failed to cleanup old logs",{retentionDays:a,error:b.message},b),b}}async exportLogs(a={}){try{let b=await this.queryLogs({...a,limit:1e4});return JSON.stringify(b.logs,null,2)}catch(b){throw await this.logError("LoggingService","Failed to export logs",{filters:a},b),b}}async addToBuffer(a){this.logBuffer.push(a),this.logBuffer.length>=this.maxBatchSize&&await this.flushBuffer()}async flushBuffer(){if(0===this.logBuffer.length)return;let a=[...this.logBuffer];this.logBuffer=[];try{await this.ensureLogsTable(),await (0,e.Yr)("system_logs").values(a.map(a=>({level:a.level,component:a.component,message:a.message,metadata:JSON.stringify(a.metadata||{}),timestamp:a.timestamp,stack_trace:a.stackTrace,user_id:a.userId,session_id:a.sessionId,request_id:a.requestId,environment:a.environment}))).execute()}catch(b){console.error("Failed to flush log buffer:",b),this.logBuffer.unshift(...a)}}startPeriodicFlush(){this.flushTimer&&clearInterval(this.flushTimer),this.flushTimer=setInterval(async()=>{await this.flushBuffer()},this.flushInterval)}async ensureLogsTable(){try{await f.db.query(`
        CREATE TABLE IF NOT EXISTS system_logs (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          level VARCHAR(20) NOT NULL,
          component VARCHAR(100) NOT NULL,
          message TEXT NOT NULL,
          metadata JSONB DEFAULT '{}',
          timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
          stack_trace TEXT,
          user_id VARCHAR(255),
          session_id VARCHAR(255),
          request_id VARCHAR(255),
          environment VARCHAR(50) NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `),await f.db.query(`
        CREATE INDEX IF NOT EXISTS idx_system_logs_timestamp ON system_logs(timestamp DESC);
        CREATE INDEX IF NOT EXISTS idx_system_logs_level ON system_logs(level);
        CREATE INDEX IF NOT EXISTS idx_system_logs_component ON system_logs(component);
        CREATE INDEX IF NOT EXISTS idx_system_logs_user_id ON system_logs(user_id);
        CREATE INDEX IF NOT EXISTS idx_system_logs_request_id ON system_logs(request_id);
        CREATE INDEX IF NOT EXISTS idx_system_logs_environment ON system_logs(environment);
      `)}catch(a){console.error("Failed to ensure logs table exists:",a)}}async shutdown(){this.flushTimer&&clearInterval(this.flushTimer),await this.flushBuffer()}}let i=new h;"undefined"!=typeof process&&(process.on("SIGTERM",async()=>{await i.shutdown()}),process.on("SIGINT",async()=>{await i.shutdown()})),d()}catch(a){d(a)}})}};